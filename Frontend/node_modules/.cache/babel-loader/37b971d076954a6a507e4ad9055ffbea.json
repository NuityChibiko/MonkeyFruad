{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.operation = exports.Operation = void 0;\n\nconst events_1 = require(\"events\");\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst operationProtos = require(\"../../protos/operations\");\n\nclass Operation extends events_1.EventEmitter {\n  /**\r\n   * Wrapper for a google.longrunnung.Operation.\r\n   *\r\n   * @constructor\r\n   *\r\n   * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\r\n   * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\r\n   * operations service client and unpacking mechanisms for the operation.\r\n   * @param {BackoffSettings} backoffSettings - The backoff settings used in\r\n   * in polling the operation.\r\n   * @param {CallOptions} callOptions - CallOptions used in making get operation\r\n   * requests.\r\n   */\n  constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n    super();\n    this.completeListeners = 0;\n    this.hasActiveListeners = false;\n    this.latestResponse = grpcOp;\n    this.name = this.latestResponse.name;\n    this.done = this.latestResponse.done;\n    this.error = this.latestResponse.error;\n    this.longrunningDescriptor = longrunningDescriptor;\n    this.result = null;\n    this.metadata = null;\n    this.backoffSettings = backoffSettings;\n\n    this._unpackResponse(grpcOp);\n\n    this._listenForEvents();\n\n    this._callOptions = callOptions;\n  }\n  /**\r\n   * Begin listening for events on the operation. This method keeps track of how\r\n   * many \"complete\" listeners are registered and removed, making sure polling\r\n   * is handled automatically.\r\n   *\r\n   * As long as there is one active \"complete\" listener, the connection is open.\r\n   * When there are no more listeners, the polling stops.\r\n   *\r\n   * @private\r\n   */\n\n\n  _listenForEvents() {\n    this.on('newListener', event => {\n      if (event === 'complete') {\n        this.completeListeners++;\n\n        if (!this.hasActiveListeners) {\n          this.hasActiveListeners = true;\n          this.startPolling_();\n        }\n      }\n    });\n    this.on('removeListener', event => {\n      if (event === 'complete' && --this.completeListeners === 0) {\n        this.hasActiveListeners = false;\n      }\n    });\n  }\n  /**\r\n   * Cancels current polling api call and cancels the operation.\r\n   *\r\n   * @return {Promise} the promise of the OperationsClient#cancelOperation api\r\n   * request.\r\n   */\n\n\n  cancel() {\n    if (this.currentCallPromise_) {\n      this.currentCallPromise_.cancel();\n    }\n\n    const operationsClient = this.longrunningDescriptor.operationsClient;\n    const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\n    cancelRequest.name = this.latestResponse.name;\n    return operationsClient.cancelOperation(cancelRequest);\n  }\n\n  getOperation(callback) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const operationsClient = this.longrunningDescriptor.operationsClient;\n\n    function promisifyResponse() {\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          if (self.latestResponse.error) {\n            const error = new googleError_1.GoogleError(self.latestResponse.error.message);\n            error.code = self.latestResponse.error.code;\n            reject(error);\n          } else {\n            resolve([self.result, self.metadata, self.latestResponse]);\n          }\n        });\n      }\n\n      return;\n    }\n\n    if (this.latestResponse.done) {\n      this._unpackResponse(this.latestResponse, callback);\n\n      return promisifyResponse();\n    }\n\n    const request = new operationProtos.google.longrunning.GetOperationRequest();\n    request.name = this.latestResponse.name;\n    this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\n    const noCallbackPromise = this.currentCallPromise_.then(responses => {\n      self.latestResponse = responses[0];\n\n      self._unpackResponse(responses[0], callback);\n\n      return promisifyResponse();\n    });\n\n    if (!callback) {\n      return noCallbackPromise;\n    }\n  }\n\n  _unpackResponse(op, callback) {\n    const responseDecoder = this.longrunningDescriptor.responseDecoder;\n    const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n    let response;\n    let metadata;\n\n    if (op.done) {\n      if (op.result === 'error') {\n        const error = new googleError_1.GoogleError(op.error.message);\n        error.code = op.error.code;\n        this.error = error;\n\n        if (callback) {\n          callback(error);\n        }\n\n        return;\n      }\n\n      if (responseDecoder && op.response) {\n        this.response = op.response;\n        response = responseDecoder(op.response.value);\n        this.result = response;\n        this.done = true;\n      }\n    }\n\n    if (metadataDecoder && op.metadata) {\n      metadata = metadataDecoder(op.metadata.value);\n      this.metadata = metadata;\n    }\n\n    if (callback) {\n      callback(null, response, metadata, op);\n    }\n  }\n  /**\r\n   * Poll `getOperation` to check the operation's status. This runs a loop to\r\n   * ping using the backoff strategy specified at initialization.\r\n   *\r\n   * Note: This method is automatically called once a \"complete\" event handler\r\n   * is registered on the operation.\r\n   *\r\n   * @private\r\n   */\n\n\n  startPolling_() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    let now = new Date();\n    const delayMult = this.backoffSettings.retryDelayMultiplier;\n    const maxDelay = this.backoffSettings.maxRetryDelayMillis;\n    let delay = this.backoffSettings.initialRetryDelayMillis;\n    let deadline = Infinity;\n\n    if (this.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n    }\n\n    let previousMetadataBytes;\n\n    if (this.latestResponse.metadata) {\n      previousMetadataBytes = this.latestResponse.metadata.value;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    function emit(event, ...args) {\n      self.emit(event, ...args);\n    } // Helper function to replace nodejs buffer's equals()\n\n\n    function arrayEquals(a, b) {\n      if (a.byteLength !== b.byteLength) {\n        return false;\n      }\n\n      for (let i = 0; i < a.byteLength; ++i) {\n        if (a[i] !== b[i]) return false;\n      }\n\n      return true;\n    }\n\n    function retry() {\n      if (!self.hasActiveListeners) {\n        return;\n      }\n\n      if (now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        setImmediate(emit, 'error', error);\n        return;\n      }\n\n      self.getOperation((err, result, metadata, rawResponse) => {\n        if (err) {\n          setImmediate(emit, 'error', err);\n          return;\n        }\n\n        if (!result) {\n          if (rawResponse.metadata && (!previousMetadataBytes || rawResponse && !arrayEquals(rawResponse.metadata.value, previousMetadataBytes))) {\n            setImmediate(emit, 'progress', metadata, rawResponse);\n            previousMetadataBytes = rawResponse.metadata.value;\n          } // special case: some APIs fail to set either result or error\n          // but set done = true (e.g. speech with silent file).\n          // Don't hang forever in this case.\n\n\n          if (rawResponse.done) {\n            const error = new googleError_1.GoogleError('Long running operation has finished but there was no result');\n            error.code = status_1.Status.UNKNOWN;\n            setImmediate(emit, 'error', error);\n            return;\n          }\n\n          setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            retry();\n          }, delay);\n          return;\n        }\n\n        setImmediate(emit, 'complete', result, metadata, rawResponse);\n      });\n    }\n\n    retry();\n  }\n  /**\r\n   * Wraps the `complete` and `error` events in a Promise.\r\n   *\r\n   * @return {promise} - Promise that resolves on operation completion and rejects\r\n   * on operation error.\r\n   */\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on('error', reject).on('complete', (result, metadata, rawResponse) => {\n        resolve([result, metadata, rawResponse]);\n      });\n    });\n  }\n\n}\n\nexports.Operation = Operation;\n/**\r\n * Method used to create Operation objects.\r\n *\r\n * @constructor\r\n *\r\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\r\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\r\n * operations service client and unpacking mechanisms for the operation.\r\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\r\n * in polling the operation.\r\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\r\n * requests.\r\n */\n\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n  return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\n\nexports.operation = operation;","map":{"version":3,"sources":["../../../src/longRunningCalls/longrunning.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.operation = exports.Operation = void 0;\r\nconst events_1 = require(\"events\");\r\nconst status_1 = require(\"../status\");\r\nconst googleError_1 = require(\"../googleError\");\r\nconst operationProtos = require(\"../../protos/operations\");\r\nclass Operation extends events_1.EventEmitter {\r\n    /**\r\n     * Wrapper for a google.longrunnung.Operation.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\r\n     * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\r\n     * operations service client and unpacking mechanisms for the operation.\r\n     * @param {BackoffSettings} backoffSettings - The backoff settings used in\r\n     * in polling the operation.\r\n     * @param {CallOptions} callOptions - CallOptions used in making get operation\r\n     * requests.\r\n     */\r\n    constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\r\n        super();\r\n        this.completeListeners = 0;\r\n        this.hasActiveListeners = false;\r\n        this.latestResponse = grpcOp;\r\n        this.name = this.latestResponse.name;\r\n        this.done = this.latestResponse.done;\r\n        this.error = this.latestResponse.error;\r\n        this.longrunningDescriptor = longrunningDescriptor;\r\n        this.result = null;\r\n        this.metadata = null;\r\n        this.backoffSettings = backoffSettings;\r\n        this._unpackResponse(grpcOp);\r\n        this._listenForEvents();\r\n        this._callOptions = callOptions;\r\n    }\r\n    /**\r\n     * Begin listening for events on the operation. This method keeps track of how\r\n     * many \"complete\" listeners are registered and removed, making sure polling\r\n     * is handled automatically.\r\n     *\r\n     * As long as there is one active \"complete\" listener, the connection is open.\r\n     * When there are no more listeners, the polling stops.\r\n     *\r\n     * @private\r\n     */\r\n    _listenForEvents() {\r\n        this.on('newListener', event => {\r\n            if (event === 'complete') {\r\n                this.completeListeners++;\r\n                if (!this.hasActiveListeners) {\r\n                    this.hasActiveListeners = true;\r\n                    this.startPolling_();\r\n                }\r\n            }\r\n        });\r\n        this.on('removeListener', event => {\r\n            if (event === 'complete' && --this.completeListeners === 0) {\r\n                this.hasActiveListeners = false;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Cancels current polling api call and cancels the operation.\r\n     *\r\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\r\n     * request.\r\n     */\r\n    cancel() {\r\n        if (this.currentCallPromise_) {\r\n            this.currentCallPromise_.cancel();\r\n        }\r\n        const operationsClient = this.longrunningDescriptor.operationsClient;\r\n        const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\r\n        cancelRequest.name = this.latestResponse.name;\r\n        return operationsClient.cancelOperation(cancelRequest);\r\n    }\r\n    getOperation(callback) {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const operationsClient = this.longrunningDescriptor.operationsClient;\r\n        function promisifyResponse() {\r\n            if (!callback) {\r\n                return new Promise((resolve, reject) => {\r\n                    if (self.latestResponse.error) {\r\n                        const error = new googleError_1.GoogleError(self.latestResponse.error.message);\r\n                        error.code = self.latestResponse.error.code;\r\n                        reject(error);\r\n                    }\r\n                    else {\r\n                        resolve([self.result, self.metadata, self.latestResponse]);\r\n                    }\r\n                });\r\n            }\r\n            return;\r\n        }\r\n        if (this.latestResponse.done) {\r\n            this._unpackResponse(this.latestResponse, callback);\r\n            return promisifyResponse();\r\n        }\r\n        const request = new operationProtos.google.longrunning.GetOperationRequest();\r\n        request.name = this.latestResponse.name;\r\n        this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\r\n        const noCallbackPromise = this.currentCallPromise_.then(responses => {\r\n            self.latestResponse = responses[0];\r\n            self._unpackResponse(responses[0], callback);\r\n            return promisifyResponse();\r\n        });\r\n        if (!callback) {\r\n            return noCallbackPromise;\r\n        }\r\n    }\r\n    _unpackResponse(op, callback) {\r\n        const responseDecoder = this.longrunningDescriptor.responseDecoder;\r\n        const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\r\n        let response;\r\n        let metadata;\r\n        if (op.done) {\r\n            if (op.result === 'error') {\r\n                const error = new googleError_1.GoogleError(op.error.message);\r\n                error.code = op.error.code;\r\n                this.error = error;\r\n                if (callback) {\r\n                    callback(error);\r\n                }\r\n                return;\r\n            }\r\n            if (responseDecoder && op.response) {\r\n                this.response = op.response;\r\n                response = responseDecoder(op.response.value);\r\n                this.result = response;\r\n                this.done = true;\r\n            }\r\n        }\r\n        if (metadataDecoder && op.metadata) {\r\n            metadata = metadataDecoder(op.metadata.value);\r\n            this.metadata = metadata;\r\n        }\r\n        if (callback) {\r\n            callback(null, response, metadata, op);\r\n        }\r\n    }\r\n    /**\r\n     * Poll `getOperation` to check the operation's status. This runs a loop to\r\n     * ping using the backoff strategy specified at initialization.\r\n     *\r\n     * Note: This method is automatically called once a \"complete\" event handler\r\n     * is registered on the operation.\r\n     *\r\n     * @private\r\n     */\r\n    startPolling_() {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        let now = new Date();\r\n        const delayMult = this.backoffSettings.retryDelayMultiplier;\r\n        const maxDelay = this.backoffSettings.maxRetryDelayMillis;\r\n        let delay = this.backoffSettings.initialRetryDelayMillis;\r\n        let deadline = Infinity;\r\n        if (this.backoffSettings.totalTimeoutMillis) {\r\n            deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\r\n        }\r\n        let previousMetadataBytes;\r\n        if (this.latestResponse.metadata) {\r\n            previousMetadataBytes = this.latestResponse.metadata.value;\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        function emit(event, ...args) {\r\n            self.emit(event, ...args);\r\n        }\r\n        // Helper function to replace nodejs buffer's equals()\r\n        function arrayEquals(a, b) {\r\n            if (a.byteLength !== b.byteLength) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < a.byteLength; ++i) {\r\n                if (a[i] !== b[i])\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        function retry() {\r\n            if (!self.hasActiveListeners) {\r\n                return;\r\n            }\r\n            if (now.getTime() >= deadline) {\r\n                const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\r\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\r\n                setImmediate(emit, 'error', error);\r\n                return;\r\n            }\r\n            self.getOperation((err, result, metadata, rawResponse) => {\r\n                if (err) {\r\n                    setImmediate(emit, 'error', err);\r\n                    return;\r\n                }\r\n                if (!result) {\r\n                    if (rawResponse.metadata &&\r\n                        (!previousMetadataBytes ||\r\n                            (rawResponse &&\r\n                                !arrayEquals(rawResponse.metadata.value, previousMetadataBytes)))) {\r\n                        setImmediate(emit, 'progress', metadata, rawResponse);\r\n                        previousMetadataBytes = rawResponse.metadata.value;\r\n                    }\r\n                    // special case: some APIs fail to set either result or error\r\n                    // but set done = true (e.g. speech with silent file).\r\n                    // Don't hang forever in this case.\r\n                    if (rawResponse.done) {\r\n                        const error = new googleError_1.GoogleError('Long running operation has finished but there was no result');\r\n                        error.code = status_1.Status.UNKNOWN;\r\n                        setImmediate(emit, 'error', error);\r\n                        return;\r\n                    }\r\n                    setTimeout(() => {\r\n                        now = new Date();\r\n                        delay = Math.min(delay * delayMult, maxDelay);\r\n                        retry();\r\n                    }, delay);\r\n                    return;\r\n                }\r\n                setImmediate(emit, 'complete', result, metadata, rawResponse);\r\n            });\r\n        }\r\n        retry();\r\n    }\r\n    /**\r\n     * Wraps the `complete` and `error` events in a Promise.\r\n     *\r\n     * @return {promise} - Promise that resolves on operation completion and rejects\r\n     * on operation error.\r\n     */\r\n    promise() {\r\n        return new Promise((resolve, reject) => {\r\n            this.on('error', reject).on('complete', (result, metadata, rawResponse) => {\r\n                resolve([result, metadata, rawResponse]);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.Operation = Operation;\r\n/**\r\n * Method used to create Operation objects.\r\n *\r\n * @constructor\r\n *\r\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\r\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\r\n * operations service client and unpacking mechanisms for the operation.\r\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\r\n * in polling the operation.\r\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\r\n * requests.\r\n */\r\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\r\n    return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\r\n}\r\nexports.operation = operation;\r\n//# sourceMappingURL=longrunning.js.map"]},"metadata":{},"sourceType":"script"}