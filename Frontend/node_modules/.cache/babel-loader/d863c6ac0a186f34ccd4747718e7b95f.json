{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\n\nclass PathTemplate {\n  /**\r\n   * @param {String} data the of the template\r\n   *\r\n   * @constructor\r\n   */\n  constructor(data) {\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\r\n   * Matches a fully-qualified path template string.\r\n   *\r\n   * @param {String} path a fully-qualified path template string\r\n   * @return {Object} contains const names matched to binding values\r\n   * @throws {TypeError} if path can't be matched to this template\r\n   */\n\n\n  match(path) {\n    let pathSegments = path.split('/');\n    const bindings = {};\n\n    if (pathSegments.length !== this.segments.length) {\n      // if the path contains a wildcard, then the length may differ by 1.\n      if (!this.data.includes('**')) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n      } else if (pathSegments.length !== this.segments.length + 1) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n      }\n    }\n\n    for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n      if (this.segments[index] !== pathSegments[0]) {\n        if (!this.segments[index].includes('*')) {\n          throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n        } else {\n          let segment = this.segments[index];\n          const variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\n\n          if (segment.includes('**')) {\n            bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\n            pathSegments = pathSegments.slice(2);\n          } else {\n            // atomic resource\n            if (variable.length === 1) {\n              bindings[variable[0]] = pathSegments[0];\n            } else {\n              // non-slash resource\n              // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n              // split the match pathSegments[0] -> value: ['bar', 'user2']\n              // compare the length of two arrays, and compare array items\n              const value = pathSegments[0].split(/[-_.~]/);\n\n              if (value.length !== variable.length) {\n                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n              }\n\n              for (const v of variable) {\n                bindings[v] = value[0];\n                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                value.shift();\n              } // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n\n\n              if (segment !== pathSegments[0]) {\n                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n              }\n            }\n\n            pathSegments.shift();\n          }\n        }\n      } else {\n        pathSegments.shift();\n      }\n    }\n\n    return bindings;\n  }\n  /**\r\n   * Renders a path template using the provided bindings.\r\n   *\r\n   * @param {Object} bindings a mapping of const names to binding strings\r\n   * @return {String} a rendered representation of the path template\r\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\r\n   *   parsed\r\n   */\n\n\n  render(bindings) {\n    if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n      throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n    }\n\n    let path = this.inspect();\n\n    for (const key of Object.keys(bindings)) {\n      const b = bindings[key].toString();\n\n      if (!this.bindings[key]) {\n        throw new TypeError(`render fails for not matching ${bindings[key]}`);\n      }\n\n      const variable = this.bindings[key];\n\n      if (variable === '*') {\n        if (!b.match(/[^/{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=*}`, `${b}`);\n      } else if (variable === '**') {\n        if (!b.match(/[^{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=**}`, `${b}`);\n      }\n    }\n\n    return path;\n  }\n  /**\r\n   * Renders the path template.\r\n   *\r\n   * @return {string} contains const names matched to binding values\r\n   */\n\n\n  inspect() {\n    return this.segments.join('/');\n  }\n  /**\r\n   * Parse the path template.\r\n   *\r\n   * @return {string[]} return segments of the input path.\r\n   * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\r\n   */\n\n\n  parsePathTemplate(data) {\n    const pathSegments = splitPathTemplate(data);\n    let index = 0;\n    let wildCardCount = 0;\n    const segments = [];\n    pathSegments.forEach(segment => {\n      // * or ** -> segments.push('{$0=*}');\n      //         -> bindings['$0'] = '*'\n      if (segment === '*' || segment === '**') {\n        this.bindings[`$${index}`] = segment;\n        segments.push(`{$${index}=${segment}}`);\n        index = index + 1;\n\n        if (segment === '**') {\n          wildCardCount = wildCardCount + 1;\n        }\n      } // {project}~{location} -> {project=*}~{location=*}\n      else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\n          // [project, location]\n          const variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\n\n          for (const v of variable) {\n            this.bindings[v] = '*';\n            segment = segment.replace(v, v + '=*');\n          }\n\n          segments.push(segment);\n        } // {project} / {project=*} -> segments.push('{project=*}');\n        //           -> bindings['project'] = '*'\n        else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\n            const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\n            this.bindings[variable[0]] = '*';\n            segments.push(`{${variable[0]}=*}`);\n          } // {project=**} -> segments.push('{project=**}');\n          //           -> bindings['project'] = '**'\n          else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\n              const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\n              this.bindings[variable[0]] = '**';\n              segments.push(`{${variable[0]}=**}`);\n              wildCardCount = wildCardCount + 1;\n            } // {hello=/what} -> segments.push('{hello=/what}');\n            //              -> no binding in this case\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\n                segments.push(segment);\n              } // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\n              //              -> no binding in this case\n              else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                  segments.push(segment);\n                }\n\n      if (wildCardCount > 1) {\n        throw new TypeError('Can not have more than one wildcard.');\n      }\n    });\n    return segments;\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\r\n * Split the path template by `/`.\r\n * It can not be simply splitted by `/` because there might be `/` in the segments.\r\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\r\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\r\n */\n\nfunction splitPathTemplate(data) {\n  let left = 0;\n  let right = 0;\n  let bracketCount = 0;\n  const segments = [];\n\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n\n      segments.push(data.substring(left));\n    }\n\n    right = right + 1;\n  }\n\n  return segments;\n}","map":{"version":3,"sources":["../../src/pathTemplate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PathTemplate = void 0;\r\nclass PathTemplate {\r\n    /**\r\n     * @param {String} data the of the template\r\n     *\r\n     * @constructor\r\n     */\r\n    constructor(data) {\r\n        this.bindings = {};\r\n        this.data = data;\r\n        this.segments = this.parsePathTemplate(data);\r\n        this.size = this.segments.length;\r\n    }\r\n    /**\r\n     * Matches a fully-qualified path template string.\r\n     *\r\n     * @param {String} path a fully-qualified path template string\r\n     * @return {Object} contains const names matched to binding values\r\n     * @throws {TypeError} if path can't be matched to this template\r\n     */\r\n    match(path) {\r\n        let pathSegments = path.split('/');\r\n        const bindings = {};\r\n        if (pathSegments.length !== this.segments.length) {\r\n            // if the path contains a wildcard, then the length may differ by 1.\r\n            if (!this.data.includes('**')) {\r\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\r\n            }\r\n            else if (pathSegments.length !== this.segments.length + 1) {\r\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\r\n            }\r\n        }\r\n        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\r\n            if (this.segments[index] !== pathSegments[0]) {\r\n                if (!this.segments[index].includes('*')) {\r\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\r\n                }\r\n                else {\r\n                    let segment = this.segments[index];\r\n                    const variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\r\n                    if (segment.includes('**')) {\r\n                        bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\r\n                        pathSegments = pathSegments.slice(2);\r\n                    }\r\n                    else {\r\n                        // atomic resource\r\n                        if (variable.length === 1) {\r\n                            bindings[variable[0]] = pathSegments[0];\r\n                        }\r\n                        else {\r\n                            // non-slash resource\r\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\r\n                            // split the match pathSegments[0] -> value: ['bar', 'user2']\r\n                            // compare the length of two arrays, and compare array items\r\n                            const value = pathSegments[0].split(/[-_.~]/);\r\n                            if (value.length !== variable.length) {\r\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\r\n                            }\r\n                            for (const v of variable) {\r\n                                bindings[v] = value[0];\r\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\r\n                                value.shift();\r\n                            }\r\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\r\n                            if (segment !== pathSegments[0]) {\r\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\r\n                            }\r\n                        }\r\n                        pathSegments.shift();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                pathSegments.shift();\r\n            }\r\n        }\r\n        return bindings;\r\n    }\r\n    /**\r\n     * Renders a path template using the provided bindings.\r\n     *\r\n     * @param {Object} bindings a mapping of const names to binding strings\r\n     * @return {String} a rendered representation of the path template\r\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\r\n     *   parsed\r\n     */\r\n    render(bindings) {\r\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\r\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\r\n        }\r\n        let path = this.inspect();\r\n        for (const key of Object.keys(bindings)) {\r\n            const b = bindings[key].toString();\r\n            if (!this.bindings[key]) {\r\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\r\n            }\r\n            const variable = this.bindings[key];\r\n            if (variable === '*') {\r\n                if (!b.match(/[^/{}]+/)) {\r\n                    throw new TypeError(`render fails for not matching ${b}`);\r\n                }\r\n                path = path.replace(`{${key}=*}`, `${b}`);\r\n            }\r\n            else if (variable === '**') {\r\n                if (!b.match(/[^{}]+/)) {\r\n                    throw new TypeError(`render fails for not matching ${b}`);\r\n                }\r\n                path = path.replace(`{${key}=**}`, `${b}`);\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    /**\r\n     * Renders the path template.\r\n     *\r\n     * @return {string} contains const names matched to binding values\r\n     */\r\n    inspect() {\r\n        return this.segments.join('/');\r\n    }\r\n    /**\r\n     * Parse the path template.\r\n     *\r\n     * @return {string[]} return segments of the input path.\r\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\r\n     */\r\n    parsePathTemplate(data) {\r\n        const pathSegments = splitPathTemplate(data);\r\n        let index = 0;\r\n        let wildCardCount = 0;\r\n        const segments = [];\r\n        pathSegments.forEach(segment => {\r\n            // * or ** -> segments.push('{$0=*}');\r\n            //         -> bindings['$0'] = '*'\r\n            if (segment === '*' || segment === '**') {\r\n                this.bindings[`$${index}`] = segment;\r\n                segments.push(`{$${index}=${segment}}`);\r\n                index = index + 1;\r\n                if (segment === '**') {\r\n                    wildCardCount = wildCardCount + 1;\r\n                }\r\n            }\r\n            // {project}~{location} -> {project=*}~{location=*}\r\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\r\n                // [project, location]\r\n                const variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\r\n                for (const v of variable) {\r\n                    this.bindings[v] = '*';\r\n                    segment = segment.replace(v, v + '=*');\r\n                }\r\n                segments.push(segment);\r\n            }\r\n            // {project} / {project=*} -> segments.push('{project=*}');\r\n            //           -> bindings['project'] = '*'\r\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\r\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\r\n                this.bindings[variable[0]] = '*';\r\n                segments.push(`{${variable[0]}=*}`);\r\n            }\r\n            // {project=**} -> segments.push('{project=**}');\r\n            //           -> bindings['project'] = '**'\r\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\r\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\r\n                this.bindings[variable[0]] = '**';\r\n                segments.push(`{${variable[0]}=**}`);\r\n                wildCardCount = wildCardCount + 1;\r\n            }\r\n            // {hello=/what} -> segments.push('{hello=/what}');\r\n            //              -> no binding in this case\r\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\r\n                segments.push(segment);\r\n            }\r\n            // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\r\n            //              -> no binding in this case\r\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\r\n                segments.push(segment);\r\n            }\r\n            if (wildCardCount > 1) {\r\n                throw new TypeError('Can not have more than one wildcard.');\r\n            }\r\n        });\r\n        return segments;\r\n    }\r\n}\r\nexports.PathTemplate = PathTemplate;\r\n/**\r\n * Split the path template by `/`.\r\n * It can not be simply splitted by `/` because there might be `/` in the segments.\r\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\r\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\r\n */\r\nfunction splitPathTemplate(data) {\r\n    let left = 0;\r\n    let right = 0;\r\n    let bracketCount = 0;\r\n    const segments = [];\r\n    while (right >= left && right < data.length) {\r\n        if (data.charAt(right) === '{') {\r\n            bracketCount = bracketCount + 1;\r\n        }\r\n        else if (data.charAt(right) === '}') {\r\n            bracketCount = bracketCount - 1;\r\n        }\r\n        else if (data.charAt(right) === '/') {\r\n            if (right === data.length - 1) {\r\n                throw new TypeError('Invalid path, it can not be ended by /');\r\n            }\r\n            if (bracketCount === 0) {\r\n                // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\r\n                segments.push(data.substring(left, right));\r\n                left = right + 1;\r\n            }\r\n        }\r\n        if (right === data.length - 1) {\r\n            if (bracketCount !== 0) {\r\n                throw new TypeError('Brackets are invalid.');\r\n            }\r\n            segments.push(data.substring(left));\r\n        }\r\n        right = right + 1;\r\n    }\r\n    return segments;\r\n}\r\n//# sourceMappingURL=pathTemplate.js.map"]},"metadata":{},"sourceType":"script"}