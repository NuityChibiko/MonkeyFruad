{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar defaults = {\n  allowDots: false,\n  allowPrototypes: false,\n  arrayLimit: 20,\n  decoder: utils.decode,\n  delimiter: '&',\n  depth: 5,\n  parameterLimit: 1000,\n  plainObjects: false,\n  strictNullHandling: false\n};\n\nvar parseValues = function parseQueryStringValues(str, options) {\n  var obj = {};\n  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n  var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n  var parts = cleanStr.split(options.delimiter, limit);\n\n  for (var i = 0; i < parts.length; ++i) {\n    var part = parts[i];\n    var bracketEqualsPos = part.indexOf(']=');\n    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n    var key, val;\n\n    if (pos === -1) {\n      key = options.decoder(part, defaults.decoder);\n      val = options.strictNullHandling ? null : '';\n    } else {\n      key = options.decoder(part.slice(0, pos), defaults.decoder);\n      val = options.decoder(part.slice(pos + 1), defaults.decoder);\n    }\n\n    if (has.call(obj, key)) {\n      obj[key] = [].concat(obj[key]).concat(val);\n    } else {\n      obj[key] = val;\n    }\n  }\n\n  return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n  var leaf = val;\n\n  for (var i = chain.length - 1; i >= 0; --i) {\n    var obj;\n    var root = chain[i];\n\n    if (root === '[]') {\n      obj = [];\n      obj = obj.concat(leaf);\n    } else {\n      obj = options.plainObjects ? Object.create(null) : {};\n      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n      var index = parseInt(cleanRoot, 10);\n\n      if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {\n        obj = [];\n        obj[index] = leaf;\n      } else {\n        obj[cleanRoot] = leaf;\n      }\n    }\n\n    leaf = obj;\n  }\n\n  return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n  if (!givenKey) {\n    return;\n  } // Transform dot notation to bracket notation\n\n\n  var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey; // The regex chunks\n\n  var brackets = /(\\[[^[\\]]*])/;\n  var child = /(\\[[^[\\]]*])/g; // Get the parent\n\n  var segment = brackets.exec(key);\n  var parent = segment ? key.slice(0, segment.index) : key; // Stash the parent if it exists\n\n  var keys = [];\n\n  if (parent) {\n    // If we aren't using plain objects, optionally prefix keys\n    // that would overwrite object prototype properties\n    if (!options.plainObjects && has.call(Object.prototype, parent)) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(parent);\n  } // Loop through children appending to the array until we hit depth\n\n\n  var i = 0;\n\n  while ((segment = child.exec(key)) !== null && i < options.depth) {\n    i += 1;\n\n    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n      if (!options.allowPrototypes) {\n        return;\n      }\n    }\n\n    keys.push(segment[1]);\n  } // If there's a remainder, just add whatever is left\n\n\n  if (segment) {\n    keys.push('[' + key.slice(segment.index) + ']');\n  }\n\n  return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n  var options = opts ? utils.assign({}, opts) : {};\n\n  if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n    throw new TypeError('Decoder has to be a function.');\n  }\n\n  options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;\n  options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n  options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n  options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n  options.parseArrays = options.parseArrays !== false;\n  options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n  options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n  options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n  options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n  options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n  options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n  if (str === '' || str === null || typeof str === 'undefined') {\n    return options.plainObjects ? Object.create(null) : {};\n  }\n\n  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n  var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object\n\n  var keys = Object.keys(tempObj);\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    var newObj = parseKeys(key, tempObj[key], options);\n    obj = utils.merge(obj, newObj, options);\n  }\n\n  return utils.compact(obj);\n};","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/qs/lib/parse.js"],"names":["utils","require","has","Object","prototype","hasOwnProperty","defaults","allowDots","allowPrototypes","arrayLimit","decoder","decode","delimiter","depth","parameterLimit","plainObjects","strictNullHandling","parseValues","parseQueryStringValues","str","options","obj","cleanStr","ignoreQueryPrefix","replace","limit","Infinity","undefined","parts","split","i","length","part","bracketEqualsPos","indexOf","pos","key","val","slice","call","concat","parseObject","chain","leaf","root","create","cleanRoot","charAt","index","parseInt","isNaN","String","parseArrays","parseKeys","parseQueryStringKeys","givenKey","brackets","child","segment","exec","parent","keys","push","module","exports","opts","assign","TypeError","isRegExp","tempObj","newObj","merge","compact"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AAEA,IAAIC,GAAG,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAA3B;AAEA,IAAIC,QAAQ,GAAG;AACXC,EAAAA,SAAS,EAAE,KADA;AAEXC,EAAAA,eAAe,EAAE,KAFN;AAGXC,EAAAA,UAAU,EAAE,EAHD;AAIXC,EAAAA,OAAO,EAAEV,KAAK,CAACW,MAJJ;AAKXC,EAAAA,SAAS,EAAE,GALA;AAMXC,EAAAA,KAAK,EAAE,CANI;AAOXC,EAAAA,cAAc,EAAE,IAPL;AAQXC,EAAAA,YAAY,EAAE,KARH;AASXC,EAAAA,kBAAkB,EAAE;AATT,CAAf;;AAYA,IAAIC,WAAW,GAAG,SAASC,sBAAT,CAAgCC,GAAhC,EAAqCC,OAArC,EAA8C;AAC5D,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,QAAQ,GAAGF,OAAO,CAACG,iBAAR,GAA4BJ,GAAG,CAACK,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAA5B,GAAqDL,GAApE;AACA,MAAIM,KAAK,GAAGL,OAAO,CAACN,cAAR,KAA2BY,QAA3B,GAAsCC,SAAtC,GAAkDP,OAAO,CAACN,cAAtE;AACA,MAAIc,KAAK,GAAGN,QAAQ,CAACO,KAAT,CAAeT,OAAO,CAACR,SAAvB,EAAkCa,KAAlC,CAAZ;;AAEA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,QAAIE,IAAI,GAAGJ,KAAK,CAACE,CAAD,CAAhB;AAEA,QAAIG,gBAAgB,GAAGD,IAAI,CAACE,OAAL,CAAa,IAAb,CAAvB;AACA,QAAIC,GAAG,GAAGF,gBAAgB,KAAK,CAAC,CAAtB,GAA0BD,IAAI,CAACE,OAAL,CAAa,GAAb,CAA1B,GAA8CD,gBAAgB,GAAG,CAA3E;AAEA,QAAIG,GAAJ,EAASC,GAAT;;AACA,QAAIF,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZC,MAAAA,GAAG,GAAGhB,OAAO,CAACV,OAAR,CAAgBsB,IAAhB,EAAsB1B,QAAQ,CAACI,OAA/B,CAAN;AACA2B,MAAAA,GAAG,GAAGjB,OAAO,CAACJ,kBAAR,GAA6B,IAA7B,GAAoC,EAA1C;AACH,KAHD,MAGO;AACHoB,MAAAA,GAAG,GAAGhB,OAAO,CAACV,OAAR,CAAgBsB,IAAI,CAACM,KAAL,CAAW,CAAX,EAAcH,GAAd,CAAhB,EAAoC7B,QAAQ,CAACI,OAA7C,CAAN;AACA2B,MAAAA,GAAG,GAAGjB,OAAO,CAACV,OAAR,CAAgBsB,IAAI,CAACM,KAAL,CAAWH,GAAG,GAAG,CAAjB,CAAhB,EAAqC7B,QAAQ,CAACI,OAA9C,CAAN;AACH;;AACD,QAAIR,GAAG,CAACqC,IAAJ,CAASlB,GAAT,EAAce,GAAd,CAAJ,EAAwB;AACpBf,MAAAA,GAAG,CAACe,GAAD,CAAH,GAAW,GAAGI,MAAH,CAAUnB,GAAG,CAACe,GAAD,CAAb,EAAoBI,MAApB,CAA2BH,GAA3B,CAAX;AACH,KAFD,MAEO;AACHhB,MAAAA,GAAG,CAACe,GAAD,CAAH,GAAWC,GAAX;AACH;AACJ;;AAED,SAAOhB,GAAP;AACH,CA5BD;;AA8BA,IAAIoB,WAAW,GAAG,UAAUC,KAAV,EAAiBL,GAAjB,EAAsBjB,OAAtB,EAA+B;AAC7C,MAAIuB,IAAI,GAAGN,GAAX;;AAEA,OAAK,IAAIP,CAAC,GAAGY,KAAK,CAACX,MAAN,GAAe,CAA5B,EAA+BD,CAAC,IAAI,CAApC,EAAuC,EAAEA,CAAzC,EAA4C;AACxC,QAAIT,GAAJ;AACA,QAAIuB,IAAI,GAAGF,KAAK,CAACZ,CAAD,CAAhB;;AAEA,QAAIc,IAAI,KAAK,IAAb,EAAmB;AACfvB,MAAAA,GAAG,GAAG,EAAN;AACAA,MAAAA,GAAG,GAAGA,GAAG,CAACmB,MAAJ,CAAWG,IAAX,CAAN;AACH,KAHD,MAGO;AACHtB,MAAAA,GAAG,GAAGD,OAAO,CAACL,YAAR,GAAuBZ,MAAM,CAAC0C,MAAP,CAAc,IAAd,CAAvB,GAA6C,EAAnD;AACA,UAAIC,SAAS,GAAGF,IAAI,CAACG,MAAL,CAAY,CAAZ,MAAmB,GAAnB,IAA0BH,IAAI,CAACG,MAAL,CAAYH,IAAI,CAACb,MAAL,GAAc,CAA1B,MAAiC,GAA3D,GAAiEa,IAAI,CAACN,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAjE,GAAqFM,IAArG;AACA,UAAII,KAAK,GAAGC,QAAQ,CAACH,SAAD,EAAY,EAAZ,CAApB;;AACA,UACI,CAACI,KAAK,CAACF,KAAD,CAAN,IACGJ,IAAI,KAAKE,SADZ,IAEGK,MAAM,CAACH,KAAD,CAAN,KAAkBF,SAFrB,IAGGE,KAAK,IAAI,CAHZ,IAII5B,OAAO,CAACgC,WAAR,IAAuBJ,KAAK,IAAI5B,OAAO,CAACX,UALhD,EAME;AACEY,QAAAA,GAAG,GAAG,EAAN;AACAA,QAAAA,GAAG,CAAC2B,KAAD,CAAH,GAAaL,IAAb;AACH,OATD,MASO;AACHtB,QAAAA,GAAG,CAACyB,SAAD,CAAH,GAAiBH,IAAjB;AACH;AACJ;;AAEDA,IAAAA,IAAI,GAAGtB,GAAP;AACH;;AAED,SAAOsB,IAAP;AACH,CAhCD;;AAkCA,IAAIU,SAAS,GAAG,SAASC,oBAAT,CAA8BC,QAA9B,EAAwClB,GAAxC,EAA6CjB,OAA7C,EAAsD;AAClE,MAAI,CAACmC,QAAL,EAAe;AACX;AACH,GAHiE,CAKlE;;;AACA,MAAInB,GAAG,GAAGhB,OAAO,CAACb,SAAR,GAAoBgD,QAAQ,CAAC/B,OAAT,CAAiB,aAAjB,EAAgC,MAAhC,CAApB,GAA8D+B,QAAxE,CANkE,CAQlE;;AAEA,MAAIC,QAAQ,GAAG,cAAf;AACA,MAAIC,KAAK,GAAG,eAAZ,CAXkE,CAalE;;AAEA,MAAIC,OAAO,GAAGF,QAAQ,CAACG,IAAT,CAAcvB,GAAd,CAAd;AACA,MAAIwB,MAAM,GAAGF,OAAO,GAAGtB,GAAG,CAACE,KAAJ,CAAU,CAAV,EAAaoB,OAAO,CAACV,KAArB,CAAH,GAAiCZ,GAArD,CAhBkE,CAkBlE;;AAEA,MAAIyB,IAAI,GAAG,EAAX;;AACA,MAAID,MAAJ,EAAY;AACR;AACA;AACA,QAAI,CAACxC,OAAO,CAACL,YAAT,IAAyBb,GAAG,CAACqC,IAAJ,CAASpC,MAAM,CAACC,SAAhB,EAA2BwD,MAA3B,CAA7B,EAAiE;AAC7D,UAAI,CAACxC,OAAO,CAACZ,eAAb,EAA8B;AAC1B;AACH;AACJ;;AAEDqD,IAAAA,IAAI,CAACC,IAAL,CAAUF,MAAV;AACH,GA/BiE,CAiClE;;;AAEA,MAAI9B,CAAC,GAAG,CAAR;;AACA,SAAO,CAAC4B,OAAO,GAAGD,KAAK,CAACE,IAAN,CAAWvB,GAAX,CAAX,MAAgC,IAAhC,IAAwCN,CAAC,GAAGV,OAAO,CAACP,KAA3D,EAAkE;AAC9DiB,IAAAA,CAAC,IAAI,CAAL;;AACA,QAAI,CAACV,OAAO,CAACL,YAAT,IAAyBb,GAAG,CAACqC,IAAJ,CAASpC,MAAM,CAACC,SAAhB,EAA2BsD,OAAO,CAAC,CAAD,CAAP,CAAWpB,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAA3B,CAA7B,EAAkF;AAC9E,UAAI,CAAClB,OAAO,CAACZ,eAAb,EAA8B;AAC1B;AACH;AACJ;;AACDqD,IAAAA,IAAI,CAACC,IAAL,CAAUJ,OAAO,CAAC,CAAD,CAAjB;AACH,GA5CiE,CA8ClE;;;AAEA,MAAIA,OAAJ,EAAa;AACTG,IAAAA,IAAI,CAACC,IAAL,CAAU,MAAM1B,GAAG,CAACE,KAAJ,CAAUoB,OAAO,CAACV,KAAlB,CAAN,GAAiC,GAA3C;AACH;;AAED,SAAOP,WAAW,CAACoB,IAAD,EAAOxB,GAAP,EAAYjB,OAAZ,CAAlB;AACH,CArDD;;AAuDA2C,MAAM,CAACC,OAAP,GAAiB,UAAU7C,GAAV,EAAe8C,IAAf,EAAqB;AAClC,MAAI7C,OAAO,GAAG6C,IAAI,GAAGjE,KAAK,CAACkE,MAAN,CAAa,EAAb,EAAiBD,IAAjB,CAAH,GAA4B,EAA9C;;AAEA,MAAI7C,OAAO,CAACV,OAAR,KAAoB,IAApB,IAA4BU,OAAO,CAACV,OAAR,KAAoBiB,SAAhD,IAA6D,OAAOP,OAAO,CAACV,OAAf,KAA2B,UAA5F,EAAwG;AACpG,UAAM,IAAIyD,SAAJ,CAAc,+BAAd,CAAN;AACH;;AAED/C,EAAAA,OAAO,CAACG,iBAAR,GAA4BH,OAAO,CAACG,iBAAR,KAA8B,IAA1D;AACAH,EAAAA,OAAO,CAACR,SAAR,GAAoB,OAAOQ,OAAO,CAACR,SAAf,KAA6B,QAA7B,IAAyCZ,KAAK,CAACoE,QAAN,CAAehD,OAAO,CAACR,SAAvB,CAAzC,GAA6EQ,OAAO,CAACR,SAArF,GAAiGN,QAAQ,CAACM,SAA9H;AACAQ,EAAAA,OAAO,CAACP,KAAR,GAAgB,OAAOO,OAAO,CAACP,KAAf,KAAyB,QAAzB,GAAoCO,OAAO,CAACP,KAA5C,GAAoDP,QAAQ,CAACO,KAA7E;AACAO,EAAAA,OAAO,CAACX,UAAR,GAAqB,OAAOW,OAAO,CAACX,UAAf,KAA8B,QAA9B,GAAyCW,OAAO,CAACX,UAAjD,GAA8DH,QAAQ,CAACG,UAA5F;AACAW,EAAAA,OAAO,CAACgC,WAAR,GAAsBhC,OAAO,CAACgC,WAAR,KAAwB,KAA9C;AACAhC,EAAAA,OAAO,CAACV,OAAR,GAAkB,OAAOU,OAAO,CAACV,OAAf,KAA2B,UAA3B,GAAwCU,OAAO,CAACV,OAAhD,GAA0DJ,QAAQ,CAACI,OAArF;AACAU,EAAAA,OAAO,CAACb,SAAR,GAAoB,OAAOa,OAAO,CAACb,SAAf,KAA6B,SAA7B,GAAyCa,OAAO,CAACb,SAAjD,GAA6DD,QAAQ,CAACC,SAA1F;AACAa,EAAAA,OAAO,CAACL,YAAR,GAAuB,OAAOK,OAAO,CAACL,YAAf,KAAgC,SAAhC,GAA4CK,OAAO,CAACL,YAApD,GAAmET,QAAQ,CAACS,YAAnG;AACAK,EAAAA,OAAO,CAACZ,eAAR,GAA0B,OAAOY,OAAO,CAACZ,eAAf,KAAmC,SAAnC,GAA+CY,OAAO,CAACZ,eAAvD,GAAyEF,QAAQ,CAACE,eAA5G;AACAY,EAAAA,OAAO,CAACN,cAAR,GAAyB,OAAOM,OAAO,CAACN,cAAf,KAAkC,QAAlC,GAA6CM,OAAO,CAACN,cAArD,GAAsER,QAAQ,CAACQ,cAAxG;AACAM,EAAAA,OAAO,CAACJ,kBAAR,GAA6B,OAAOI,OAAO,CAACJ,kBAAf,KAAsC,SAAtC,GAAkDI,OAAO,CAACJ,kBAA1D,GAA+EV,QAAQ,CAACU,kBAArH;;AAEA,MAAIG,GAAG,KAAK,EAAR,IAAcA,GAAG,KAAK,IAAtB,IAA8B,OAAOA,GAAP,KAAe,WAAjD,EAA8D;AAC1D,WAAOC,OAAO,CAACL,YAAR,GAAuBZ,MAAM,CAAC0C,MAAP,CAAc,IAAd,CAAvB,GAA6C,EAApD;AACH;;AAED,MAAIwB,OAAO,GAAG,OAAOlD,GAAP,KAAe,QAAf,GAA0BF,WAAW,CAACE,GAAD,EAAMC,OAAN,CAArC,GAAsDD,GAApE;AACA,MAAIE,GAAG,GAAGD,OAAO,CAACL,YAAR,GAAuBZ,MAAM,CAAC0C,MAAP,CAAc,IAAd,CAAvB,GAA6C,EAAvD,CAxBkC,CA0BlC;;AAEA,MAAIgB,IAAI,GAAG1D,MAAM,CAAC0D,IAAP,CAAYQ,OAAZ,CAAX;;AACA,OAAK,IAAIvC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,IAAI,CAAC9B,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,QAAIM,GAAG,GAAGyB,IAAI,CAAC/B,CAAD,CAAd;AACA,QAAIwC,MAAM,GAAGjB,SAAS,CAACjB,GAAD,EAAMiC,OAAO,CAACjC,GAAD,CAAb,EAAoBhB,OAApB,CAAtB;AACAC,IAAAA,GAAG,GAAGrB,KAAK,CAACuE,KAAN,CAAYlD,GAAZ,EAAiBiD,MAAjB,EAAyBlD,OAAzB,CAAN;AACH;;AAED,SAAOpB,KAAK,CAACwE,OAAN,CAAcnD,GAAd,CAAP;AACH,CApCD","sourcesContent":["'use strict';\r\n\r\nvar utils = require('./utils');\r\n\r\nvar has = Object.prototype.hasOwnProperty;\r\n\r\nvar defaults = {\r\n    allowDots: false,\r\n    allowPrototypes: false,\r\n    arrayLimit: 20,\r\n    decoder: utils.decode,\r\n    delimiter: '&',\r\n    depth: 5,\r\n    parameterLimit: 1000,\r\n    plainObjects: false,\r\n    strictNullHandling: false\r\n};\r\n\r\nvar parseValues = function parseQueryStringValues(str, options) {\r\n    var obj = {};\r\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\r\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\r\n    var parts = cleanStr.split(options.delimiter, limit);\r\n\r\n    for (var i = 0; i < parts.length; ++i) {\r\n        var part = parts[i];\r\n\r\n        var bracketEqualsPos = part.indexOf(']=');\r\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\r\n\r\n        var key, val;\r\n        if (pos === -1) {\r\n            key = options.decoder(part, defaults.decoder);\r\n            val = options.strictNullHandling ? null : '';\r\n        } else {\r\n            key = options.decoder(part.slice(0, pos), defaults.decoder);\r\n            val = options.decoder(part.slice(pos + 1), defaults.decoder);\r\n        }\r\n        if (has.call(obj, key)) {\r\n            obj[key] = [].concat(obj[key]).concat(val);\r\n        } else {\r\n            obj[key] = val;\r\n        }\r\n    }\r\n\r\n    return obj;\r\n};\r\n\r\nvar parseObject = function (chain, val, options) {\r\n    var leaf = val;\r\n\r\n    for (var i = chain.length - 1; i >= 0; --i) {\r\n        var obj;\r\n        var root = chain[i];\r\n\r\n        if (root === '[]') {\r\n            obj = [];\r\n            obj = obj.concat(leaf);\r\n        } else {\r\n            obj = options.plainObjects ? Object.create(null) : {};\r\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\r\n            var index = parseInt(cleanRoot, 10);\r\n            if (\r\n                !isNaN(index)\r\n                && root !== cleanRoot\r\n                && String(index) === cleanRoot\r\n                && index >= 0\r\n                && (options.parseArrays && index <= options.arrayLimit)\r\n            ) {\r\n                obj = [];\r\n                obj[index] = leaf;\r\n            } else {\r\n                obj[cleanRoot] = leaf;\r\n            }\r\n        }\r\n\r\n        leaf = obj;\r\n    }\r\n\r\n    return leaf;\r\n};\r\n\r\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\r\n    if (!givenKey) {\r\n        return;\r\n    }\r\n\r\n    // Transform dot notation to bracket notation\r\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\r\n\r\n    // The regex chunks\r\n\r\n    var brackets = /(\\[[^[\\]]*])/;\r\n    var child = /(\\[[^[\\]]*])/g;\r\n\r\n    // Get the parent\r\n\r\n    var segment = brackets.exec(key);\r\n    var parent = segment ? key.slice(0, segment.index) : key;\r\n\r\n    // Stash the parent if it exists\r\n\r\n    var keys = [];\r\n    if (parent) {\r\n        // If we aren't using plain objects, optionally prefix keys\r\n        // that would overwrite object prototype properties\r\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\r\n            if (!options.allowPrototypes) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        keys.push(parent);\r\n    }\r\n\r\n    // Loop through children appending to the array until we hit depth\r\n\r\n    var i = 0;\r\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\r\n        i += 1;\r\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\r\n            if (!options.allowPrototypes) {\r\n                return;\r\n            }\r\n        }\r\n        keys.push(segment[1]);\r\n    }\r\n\r\n    // If there's a remainder, just add whatever is left\r\n\r\n    if (segment) {\r\n        keys.push('[' + key.slice(segment.index) + ']');\r\n    }\r\n\r\n    return parseObject(keys, val, options);\r\n};\r\n\r\nmodule.exports = function (str, opts) {\r\n    var options = opts ? utils.assign({}, opts) : {};\r\n\r\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\r\n        throw new TypeError('Decoder has to be a function.');\r\n    }\r\n\r\n    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;\r\n    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\r\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\r\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\r\n    options.parseArrays = options.parseArrays !== false;\r\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\r\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\r\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\r\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\r\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\r\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\r\n\r\n    if (str === '' || str === null || typeof str === 'undefined') {\r\n        return options.plainObjects ? Object.create(null) : {};\r\n    }\r\n\r\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\r\n    var obj = options.plainObjects ? Object.create(null) : {};\r\n\r\n    // Iterate over the keys and setup the new object\r\n\r\n    var keys = Object.keys(tempObj);\r\n    for (var i = 0; i < keys.length; ++i) {\r\n        var key = keys[i];\r\n        var newObj = parseKeys(key, tempObj[key], options);\r\n        obj = utils.merge(obj, newObj, options);\r\n    }\r\n\r\n    return utils.compact(obj);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}