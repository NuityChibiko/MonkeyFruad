{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst picomatch = require('picomatch');\n\nconst normalizePath = require('normalize-path');\n/**\r\n * @typedef {(testString: string) => boolean} AnymatchFn\r\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\r\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\r\n */\n\n\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nconst arrify = item => Array.isArray(item) ? item : [item];\n/**\r\n * @param {AnymatchPattern} matcher\r\n * @param {object} options\r\n * @returns {AnymatchFn}\r\n */\n\n\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n\n  return string => false;\n};\n/**\r\n * @param {Array<Function>} patterns\r\n * @param {Array<Function>} negPatterns\r\n * @param {String|Array} args\r\n * @param {Boolean} returnIndex\r\n * @returns {boolean|number}\r\n */\n\n\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n\n  const _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\r\n * @param {AnymatchMatcher} matchers\r\n * @param {Array|string} testString\r\n * @param {object} options\r\n * @returns {boolean|number|Function}\r\n */\n\n\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/anymatch/index.js"],"names":["Object","defineProperty","exports","value","picomatch","require","normalizePath","BANG","DEFAULT_OPTIONS","returnIndex","arrify","item","Array","isArray","createPattern","matcher","options","glob","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","TypeError","prototype","toString","call","path","index","length","nglob","applied","concat","slice","pattern","anymatch","matchers","testString","opts","mtchers","negatedGlobs","filter","charAt","map","ri","default","module"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst picomatch = require('picomatch');\r\nconst normalizePath = require('normalize-path');\r\n\r\n/**\r\n * @typedef {(testString: string) => boolean} AnymatchFn\r\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\r\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\r\n */\r\nconst BANG = '!';\r\nconst DEFAULT_OPTIONS = {returnIndex: false};\r\nconst arrify = (item) => Array.isArray(item) ? item : [item];\r\n\r\n/**\r\n * @param {AnymatchPattern} matcher\r\n * @param {object} options\r\n * @returns {AnymatchFn}\r\n */\r\nconst createPattern = (matcher, options) => {\r\n  if (typeof matcher === 'function') {\r\n    return matcher;\r\n  }\r\n  if (typeof matcher === 'string') {\r\n    const glob = picomatch(matcher, options);\r\n    return (string) => matcher === string || glob(string);\r\n  }\r\n  if (matcher instanceof RegExp) {\r\n    return (string) => matcher.test(string);\r\n  }\r\n  return (string) => false;\r\n};\r\n\r\n/**\r\n * @param {Array<Function>} patterns\r\n * @param {Array<Function>} negPatterns\r\n * @param {String|Array} args\r\n * @param {Boolean} returnIndex\r\n * @returns {boolean|number}\r\n */\r\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\r\n  const isList = Array.isArray(args);\r\n  const _path = isList ? args[0] : args;\r\n  if (!isList && typeof _path !== 'string') {\r\n    throw new TypeError('anymatch: second argument must be a string: got ' +\r\n      Object.prototype.toString.call(_path))\r\n  }\r\n  const path = normalizePath(_path);\r\n\r\n  for (let index = 0; index < negPatterns.length; index++) {\r\n    const nglob = negPatterns[index];\r\n    if (nglob(path)) {\r\n      return returnIndex ? -1 : false;\r\n    }\r\n  }\r\n\r\n  const applied = isList && [path].concat(args.slice(1));\r\n  for (let index = 0; index < patterns.length; index++) {\r\n    const pattern = patterns[index];\r\n    if (isList ? pattern(...applied) : pattern(path)) {\r\n      return returnIndex ? index : true;\r\n    }\r\n  }\r\n\r\n  return returnIndex ? -1 : false;\r\n};\r\n\r\n/**\r\n * @param {AnymatchMatcher} matchers\r\n * @param {Array|string} testString\r\n * @param {object} options\r\n * @returns {boolean|number|Function}\r\n */\r\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\r\n  if (matchers == null) {\r\n    throw new TypeError('anymatch: specify first argument');\r\n  }\r\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\r\n  const returnIndex = opts.returnIndex || false;\r\n\r\n  // Early cache for matchers.\r\n  const mtchers = arrify(matchers);\r\n  const negatedGlobs = mtchers\r\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\r\n    .map(item => item.slice(1))\r\n    .map(item => picomatch(item, opts));\r\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\r\n\r\n  if (testString == null) {\r\n    return (testString, ri = false) => {\r\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\r\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n    }\r\n  }\r\n\r\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n};\r\n\r\nanymatch.default = anymatch;\r\nmodule.exports = anymatch;\r\n"]},"metadata":{},"sourceType":"script"}