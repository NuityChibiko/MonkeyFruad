{"ast":null,"code":"// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\n\nif (process.platform !== 'win32') {\n  module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT' // should detect profiler and enable/disable accordingly.\n  // see #21\n  // 'SIGPROF'\n  );\n}\n\nif (process.platform === 'linux') {\n  module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/signal-exit/signals.js"],"names":["module","exports","process","platform","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,GAAiB,CACf,SADe,EAEf,SAFe,EAGf,QAHe,EAIf,QAJe,EAKf,SALe,CAAjB;;AAQA,IAAIC,OAAO,CAACC,QAAR,KAAqB,OAAzB,EAAkC;AAChCH,EAAAA,MAAM,CAACC,OAAP,CAAeG,IAAf,CACE,WADF,EAEE,SAFF,EAGE,SAHF,EAIE,SAJF,EAKE,SALF,EAME,QANF,EAOE,SAPF,EAQE,QARF,CASE;AACA;AACA;AAXF;AAaD;;AAED,IAAIF,OAAO,CAACC,QAAR,KAAqB,OAAzB,EAAkC;AAChCH,EAAAA,MAAM,CAACC,OAAP,CAAeG,IAAf,CACE,OADF,EAEE,SAFF,EAGE,QAHF,EAIE,WAJF,EAKE,WALF;AAOD","sourcesContent":["// This is not the set of all possible signals.\r\n//\r\n// It IS, however, the set of all signals that trigger\r\n// an exit on either Linux or BSD systems.  Linux is a\r\n// superset of the signal names supported on BSD, and\r\n// the unknown signals just fail to register, so we can\r\n// catch that easily enough.\r\n//\r\n// Don't bother with SIGKILL.  It's uncatchable, which\r\n// means that we can't fire any callbacks anyway.\r\n//\r\n// If a user does happen to register a handler on a non-\r\n// fatal signal like SIGWINCH or something, and then\r\n// exit, it'll end up firing `process.emit('exit')`, so\r\n// the handler will be fired anyway.\r\n//\r\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\r\n// artificially, inherently leave the process in a\r\n// state from which it is not safe to try and enter JS\r\n// listeners.\r\nmodule.exports = [\r\n  'SIGABRT',\r\n  'SIGALRM',\r\n  'SIGHUP',\r\n  'SIGINT',\r\n  'SIGTERM'\r\n]\r\n\r\nif (process.platform !== 'win32') {\r\n  module.exports.push(\r\n    'SIGVTALRM',\r\n    'SIGXCPU',\r\n    'SIGXFSZ',\r\n    'SIGUSR2',\r\n    'SIGTRAP',\r\n    'SIGSYS',\r\n    'SIGQUIT',\r\n    'SIGIOT'\r\n    // should detect profiler and enable/disable accordingly.\r\n    // see #21\r\n    // 'SIGPROF'\r\n  )\r\n}\r\n\r\nif (process.platform === 'linux') {\r\n  module.exports.push(\r\n    'SIGIO',\r\n    'SIGPOLL',\r\n    'SIGPWR',\r\n    'SIGSTKFLT',\r\n    'SIGUNUSED'\r\n  )\r\n}\r\n"]},"metadata":{},"sourceType":"script"}