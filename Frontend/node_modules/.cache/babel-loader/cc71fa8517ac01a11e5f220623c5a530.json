{"ast":null,"code":"/*! firebase-admin v9.4.2 */\n\"use strict\";\n/*!\r\n * Copyright 2018 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSessionCookieVerifier = exports.createIdTokenVerifier = exports.FirebaseTokenVerifier = exports.SESSION_COOKIE_INFO = exports.ID_TOKEN_INFO = exports.ALGORITHM_RS256 = void 0;\n\nvar error_1 = require(\"../utils/error\");\n\nvar util = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar jwt = require(\"jsonwebtoken\");\n\nvar api_request_1 = require(\"../utils/api-request\"); // Audience to use for Firebase Auth Custom tokens\n\n\nvar FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\nexports.ALGORITHM_RS256 = 'RS256'; // URL containing the public keys for the Google certs (whose private keys are used to sign Firebase\n// Auth ID tokens)\n\nvar CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com'; // URL containing the public keys for Firebase session cookies. This will be updated to a different URL soon.\n\nvar SESSION_COOKIE_CERT_URL = 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys';\n/** User facing token information related to the Firebase ID token. */\n\nexports.ID_TOKEN_INFO = {\n  url: 'https://firebase.google.com/docs/auth/admin/verify-id-tokens',\n  verifyApiName: 'verifyIdToken()',\n  jwtName: 'Firebase ID token',\n  shortName: 'ID token',\n  expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED\n};\n/** User facing token information related to the Firebase session cookie. */\n\nexports.SESSION_COOKIE_INFO = {\n  url: 'https://firebase.google.com/docs/auth/admin/manage-cookies',\n  verifyApiName: 'verifySessionCookie()',\n  jwtName: 'Firebase session cookie',\n  shortName: 'session cookie',\n  expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED\n};\n/**\r\n * Class for verifying general purpose Firebase JWTs. This verifies ID tokens and session cookies.\r\n */\n\nvar FirebaseTokenVerifier =\n/** @class */\nfunction () {\n  function FirebaseTokenVerifier(clientCertUrl, algorithm, issuer, tokenInfo, app) {\n    this.clientCertUrl = clientCertUrl;\n    this.algorithm = algorithm;\n    this.issuer = issuer;\n    this.tokenInfo = tokenInfo;\n    this.app = app;\n\n    if (!validator.isURL(clientCertUrl)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided public client certificate URL is an invalid URL.');\n    } else if (!validator.isNonEmptyString(algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT algorithm is an empty string.');\n    } else if (!validator.isURL(issuer)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT issuer is an invalid URL.');\n    } else if (!validator.isNonNullObject(tokenInfo)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT information is not an object or null.');\n    } else if (!validator.isURL(tokenInfo.url)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT verification documentation URL is invalid.');\n    } else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT verify API name must be a non-empty string.');\n    } else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public full name must be a non-empty string.');\n    } else if (!validator.isNonEmptyString(tokenInfo.shortName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public short name must be a non-empty string.');\n    } else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !('code' in tokenInfo.expiredErrorCode)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT expiration error code must be a non-null ErrorInfo object.');\n    }\n\n    this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? 'an' : 'a'; // For backward compatibility, the project ID is validated in the verification call.\n  }\n  /**\r\n   * Verifies the format and signature of a Firebase Auth JWT token.\r\n   *\r\n   * @param {string} jwtToken The Firebase Auth JWT token to verify.\r\n   * @return {Promise<DecodedIdToken>} A promise fulfilled with the decoded claims of the Firebase Auth ID\r\n   *                           token.\r\n   */\n\n\n  FirebaseTokenVerifier.prototype.verifyJWT = function (jwtToken) {\n    var _this = this;\n\n    if (!validator.isString(jwtToken)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"First argument to \" + this.tokenInfo.verifyApiName + \" must be a \" + this.tokenInfo.jwtName + \" string.\");\n    }\n\n    return util.findProjectId(this.app).then(function (projectId) {\n      return _this.verifyJWTWithProjectId(jwtToken, projectId);\n    });\n  };\n  /**\r\n   * Override the JWT signing algorithm.\r\n   * @param algorithm the new signing algorithm.\r\n   */\n\n\n  FirebaseTokenVerifier.prototype.setAlgorithm = function (algorithm) {\n    this.algorithm = algorithm;\n  };\n\n  FirebaseTokenVerifier.prototype.verifyJWTWithProjectId = function (jwtToken, projectId) {\n    var _this = this;\n\n    if (!validator.isNonEmptyString(projectId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Must initialize app with a cert credential or set your Firebase project ID as the ' + (\"GOOGLE_CLOUD_PROJECT environment variable to call \" + this.tokenInfo.verifyApiName + \".\"));\n    }\n\n    var fullDecodedToken = jwt.decode(jwtToken, {\n      complete: true\n    });\n    var header = fullDecodedToken && fullDecodedToken.header;\n    var payload = fullDecodedToken && fullDecodedToken.payload;\n    var projectIdMatchMessage = \" Make sure the \" + this.tokenInfo.shortName + \" comes from the same \" + 'Firebase project as the service account used to authenticate this SDK.';\n    var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" + (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n    var errorMessage;\n\n    if (!fullDecodedToken) {\n      errorMessage = \"Decoding \" + this.tokenInfo.jwtName + \" failed. Make sure you passed the entire string JWT \" + (\"which represents \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\") + verifyJwtTokenDocsMessage;\n    } else if (typeof header.kid === 'undefined' && this.algorithm !== 'none') {\n      var isCustomToken = payload.aud === FIREBASE_AUDIENCE;\n      var isLegacyCustomToken = header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d;\n\n      if (isCustomToken) {\n        errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" + (this.tokenInfo.shortName + \", but was given a custom token.\");\n      } else if (isLegacyCustomToken) {\n        errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" + (this.tokenInfo.shortName + \", but was given a legacy custom token.\");\n      } else {\n        errorMessage = 'Firebase ID token has no \"kid\" claim.';\n      }\n\n      errorMessage += verifyJwtTokenDocsMessage;\n    } else if (header.alg !== this.algorithm) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect algorithm. Expected \\\"\" + this.algorithm + '\" but got ' + '\"' + header.alg + '\".' + verifyJwtTokenDocsMessage;\n    } else if (payload.aud !== projectId) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"aud\\\" (audience) claim. Expected \\\"\" + projectId + '\" but got \"' + payload.aud + '\".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;\n    } else if (payload.iss !== this.issuer + projectId) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"iss\\\" (issuer) claim. Expected \" + (\"\\\"\" + this.issuer + \"\\\"\") + projectId + '\" but got \"' + payload.iss + '\".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;\n    } else if (typeof payload.sub !== 'string') {\n      errorMessage = this.tokenInfo.jwtName + \" has no \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n    } else if (payload.sub === '') {\n      errorMessage = this.tokenInfo.jwtName + \" has an empty string \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n    } else if (payload.sub.length > 128) {\n      errorMessage = this.tokenInfo.jwtName + \" has \\\"sub\\\" (subject) claim longer than 128 characters.\" + verifyJwtTokenDocsMessage;\n    }\n\n    if (errorMessage) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n    } // When the algorithm is set to 'none' there will be no signature and therefore we don't check\n    // the public keys.\n\n\n    if (this.algorithm === 'none') {\n      return this.verifyJwtSignatureWithKey(jwtToken, null);\n    }\n\n    return this.fetchPublicKeys().then(function (publicKeys) {\n      if (!Object.prototype.hasOwnProperty.call(publicKeys, header.kid)) {\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, _this.tokenInfo.jwtName + \" has \\\"kid\\\" claim which does not correspond to a known public key. \" + (\"Most likely the \" + _this.tokenInfo.shortName + \" is expired, so get a fresh token from your \") + 'client app and try again.'));\n      } else {\n        return _this.verifyJwtSignatureWithKey(jwtToken, publicKeys[header.kid]);\n      }\n    });\n  };\n  /**\r\n   * Verifies the JWT signature using the provided public key.\r\n   * @param {string} jwtToken The JWT token to verify.\r\n   * @param {string} publicKey The public key certificate.\r\n   * @return {Promise<DecodedIdToken>} A promise that resolves with the decoded JWT claims on successful\r\n   *     verification.\r\n   */\n\n\n  FirebaseTokenVerifier.prototype.verifyJwtSignatureWithKey = function (jwtToken, publicKey) {\n    var _this = this;\n\n    var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" + (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n    return new Promise(function (resolve, reject) {\n      jwt.verify(jwtToken, publicKey || '', {\n        algorithms: [_this.algorithm]\n      }, function (error, decodedToken) {\n        if (error) {\n          if (error.name === 'TokenExpiredError') {\n            var errorMessage = _this.tokenInfo.jwtName + \" has expired. Get a fresh \" + _this.tokenInfo.shortName + (\" from your client app and try again (auth/\" + _this.tokenInfo.expiredErrorCode.code + \").\") + verifyJwtTokenDocsMessage;\n            return reject(new error_1.FirebaseAuthError(_this.tokenInfo.expiredErrorCode, errorMessage));\n          } else if (error.name === 'JsonWebTokenError') {\n            var errorMessage = _this.tokenInfo.jwtName + \" has invalid signature.\" + verifyJwtTokenDocsMessage;\n            return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n          }\n\n          return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message));\n        } else {\n          var decodedIdToken = decodedToken;\n          decodedIdToken.uid = decodedIdToken.sub;\n          resolve(decodedIdToken);\n        }\n      });\n    });\n  };\n  /**\r\n   * Fetches the public keys for the Google certs.\r\n   *\r\n   * @return {Promise<object>} A promise fulfilled with public keys for the Google certs.\r\n   */\n\n\n  FirebaseTokenVerifier.prototype.fetchPublicKeys = function () {\n    var _this = this;\n\n    var publicKeysExist = typeof this.publicKeys !== 'undefined';\n    var publicKeysExpiredExists = typeof this.publicKeysExpireAt !== 'undefined';\n    var publicKeysStillValid = publicKeysExpiredExists && Date.now() < this.publicKeysExpireAt;\n\n    if (publicKeysExist && publicKeysStillValid) {\n      return Promise.resolve(this.publicKeys);\n    }\n\n    var client = new api_request_1.HttpClient();\n    var request = {\n      method: 'GET',\n      url: this.clientCertUrl,\n      httpAgent: this.app.options.httpAgent\n    };\n    return client.send(request).then(function (resp) {\n      if (!resp.isJson() || resp.data.error) {\n        // Treat all non-json messages and messages with an 'error' field as\n        // error responses.\n        throw new api_request_1.HttpError(resp);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n        var cacheControlHeader = resp.headers['cache-control'];\n        var parts = cacheControlHeader.split(',');\n        parts.forEach(function (part) {\n          var subParts = part.trim().split('=');\n\n          if (subParts[0] === 'max-age') {\n            var maxAge = +subParts[1];\n            _this.publicKeysExpireAt = Date.now() + maxAge * 1000;\n          }\n        });\n      }\n\n      _this.publicKeys = resp.data;\n      return resp.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var errorMessage = 'Error fetching public keys for Google certs: ';\n        var resp = err.response;\n\n        if (resp.isJson() && resp.data.error) {\n          errorMessage += \"\" + resp.data.error;\n\n          if (resp.data.error_description) {\n            errorMessage += ' (' + resp.data.error_description + ')';\n          }\n        } else {\n          errorMessage += \"\" + resp.text;\n        }\n\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, errorMessage);\n      }\n\n      throw err;\n    });\n  };\n\n  return FirebaseTokenVerifier;\n}();\n\nexports.FirebaseTokenVerifier = FirebaseTokenVerifier;\n/**\r\n * Creates a new FirebaseTokenVerifier to verify Firebase ID tokens.\r\n *\r\n * @param {FirebaseApp} app Firebase app instance.\r\n * @return {FirebaseTokenVerifier}\r\n */\n\nfunction createIdTokenVerifier(app) {\n  return new FirebaseTokenVerifier(CLIENT_CERT_URL, exports.ALGORITHM_RS256, 'https://securetoken.google.com/', exports.ID_TOKEN_INFO, app);\n}\n\nexports.createIdTokenVerifier = createIdTokenVerifier;\n/**\r\n * Creates a new FirebaseTokenVerifier to verify Firebase session cookies.\r\n *\r\n * @param {FirebaseApp} app Firebase app instance.\r\n * @return {FirebaseTokenVerifier}\r\n */\n\nfunction createSessionCookieVerifier(app) {\n  return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, exports.ALGORITHM_RS256, 'https://session.firebase.google.com/', exports.SESSION_COOKIE_INFO, app);\n}\n\nexports.createSessionCookieVerifier = createSessionCookieVerifier;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/firebase-admin/lib/auth/token-verifier.js"],"names":["Object","defineProperty","exports","value","createSessionCookieVerifier","createIdTokenVerifier","FirebaseTokenVerifier","SESSION_COOKIE_INFO","ID_TOKEN_INFO","ALGORITHM_RS256","error_1","require","util","validator","jwt","api_request_1","FIREBASE_AUDIENCE","CLIENT_CERT_URL","SESSION_COOKIE_CERT_URL","url","verifyApiName","jwtName","shortName","expiredErrorCode","AuthClientErrorCode","ID_TOKEN_EXPIRED","SESSION_COOKIE_EXPIRED","clientCertUrl","algorithm","issuer","tokenInfo","app","isURL","FirebaseAuthError","INVALID_ARGUMENT","isNonEmptyString","isNonNullObject","shortNameArticle","charAt","match","prototype","verifyJWT","jwtToken","_this","isString","findProjectId","then","projectId","verifyJWTWithProjectId","setAlgorithm","INVALID_CREDENTIAL","fullDecodedToken","decode","complete","header","payload","projectIdMatchMessage","verifyJwtTokenDocsMessage","errorMessage","kid","isCustomToken","aud","isLegacyCustomToken","alg","v","d","iss","sub","length","Promise","reject","verifyJwtSignatureWithKey","fetchPublicKeys","publicKeys","hasOwnProperty","call","publicKey","resolve","verify","algorithms","error","decodedToken","name","code","message","decodedIdToken","uid","publicKeysExist","publicKeysExpiredExists","publicKeysExpireAt","publicKeysStillValid","Date","now","client","HttpClient","request","method","httpAgent","options","send","resp","isJson","data","HttpError","headers","cacheControlHeader","parts","split","forEach","part","subParts","trim","maxAge","catch","err","response","error_description","text","INTERNAL_ERROR"],"mappings":"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","sourcesContent":["/*! firebase-admin v9.4.2 */\r\n\"use strict\";\r\n/*!\r\n * Copyright 2018 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createSessionCookieVerifier = exports.createIdTokenVerifier = exports.FirebaseTokenVerifier = exports.SESSION_COOKIE_INFO = exports.ID_TOKEN_INFO = exports.ALGORITHM_RS256 = void 0;\r\nvar error_1 = require(\"../utils/error\");\r\nvar util = require(\"../utils/index\");\r\nvar validator = require(\"../utils/validator\");\r\nvar jwt = require(\"jsonwebtoken\");\r\nvar api_request_1 = require(\"../utils/api-request\");\r\n// Audience to use for Firebase Auth Custom tokens\r\nvar FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\r\nexports.ALGORITHM_RS256 = 'RS256';\r\n// URL containing the public keys for the Google certs (whose private keys are used to sign Firebase\r\n// Auth ID tokens)\r\nvar CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com';\r\n// URL containing the public keys for Firebase session cookies. This will be updated to a different URL soon.\r\nvar SESSION_COOKIE_CERT_URL = 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys';\r\n/** User facing token information related to the Firebase ID token. */\r\nexports.ID_TOKEN_INFO = {\r\n    url: 'https://firebase.google.com/docs/auth/admin/verify-id-tokens',\r\n    verifyApiName: 'verifyIdToken()',\r\n    jwtName: 'Firebase ID token',\r\n    shortName: 'ID token',\r\n    expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED,\r\n};\r\n/** User facing token information related to the Firebase session cookie. */\r\nexports.SESSION_COOKIE_INFO = {\r\n    url: 'https://firebase.google.com/docs/auth/admin/manage-cookies',\r\n    verifyApiName: 'verifySessionCookie()',\r\n    jwtName: 'Firebase session cookie',\r\n    shortName: 'session cookie',\r\n    expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED,\r\n};\r\n/**\r\n * Class for verifying general purpose Firebase JWTs. This verifies ID tokens and session cookies.\r\n */\r\nvar FirebaseTokenVerifier = /** @class */ (function () {\r\n    function FirebaseTokenVerifier(clientCertUrl, algorithm, issuer, tokenInfo, app) {\r\n        this.clientCertUrl = clientCertUrl;\r\n        this.algorithm = algorithm;\r\n        this.issuer = issuer;\r\n        this.tokenInfo = tokenInfo;\r\n        this.app = app;\r\n        if (!validator.isURL(clientCertUrl)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided public client certificate URL is an invalid URL.');\r\n        }\r\n        else if (!validator.isNonEmptyString(algorithm)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT algorithm is an empty string.');\r\n        }\r\n        else if (!validator.isURL(issuer)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT issuer is an invalid URL.');\r\n        }\r\n        else if (!validator.isNonNullObject(tokenInfo)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT information is not an object or null.');\r\n        }\r\n        else if (!validator.isURL(tokenInfo.url)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The provided JWT verification documentation URL is invalid.');\r\n        }\r\n        else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT verify API name must be a non-empty string.');\r\n        }\r\n        else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public full name must be a non-empty string.');\r\n        }\r\n        else if (!validator.isNonEmptyString(tokenInfo.shortName)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT public short name must be a non-empty string.');\r\n        }\r\n        else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !('code' in tokenInfo.expiredErrorCode)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'The JWT expiration error code must be a non-null ErrorInfo object.');\r\n        }\r\n        this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? 'an' : 'a';\r\n        // For backward compatibility, the project ID is validated in the verification call.\r\n    }\r\n    /**\r\n     * Verifies the format and signature of a Firebase Auth JWT token.\r\n     *\r\n     * @param {string} jwtToken The Firebase Auth JWT token to verify.\r\n     * @return {Promise<DecodedIdToken>} A promise fulfilled with the decoded claims of the Firebase Auth ID\r\n     *                           token.\r\n     */\r\n    FirebaseTokenVerifier.prototype.verifyJWT = function (jwtToken) {\r\n        var _this = this;\r\n        if (!validator.isString(jwtToken)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"First argument to \" + this.tokenInfo.verifyApiName + \" must be a \" + this.tokenInfo.jwtName + \" string.\");\r\n        }\r\n        return util.findProjectId(this.app)\r\n            .then(function (projectId) {\r\n            return _this.verifyJWTWithProjectId(jwtToken, projectId);\r\n        });\r\n    };\r\n    /**\r\n     * Override the JWT signing algorithm.\r\n     * @param algorithm the new signing algorithm.\r\n     */\r\n    FirebaseTokenVerifier.prototype.setAlgorithm = function (algorithm) {\r\n        this.algorithm = algorithm;\r\n    };\r\n    FirebaseTokenVerifier.prototype.verifyJWTWithProjectId = function (jwtToken, projectId) {\r\n        var _this = this;\r\n        if (!validator.isNonEmptyString(projectId)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Must initialize app with a cert credential or set your Firebase project ID as the ' +\r\n                (\"GOOGLE_CLOUD_PROJECT environment variable to call \" + this.tokenInfo.verifyApiName + \".\"));\r\n        }\r\n        var fullDecodedToken = jwt.decode(jwtToken, {\r\n            complete: true,\r\n        });\r\n        var header = fullDecodedToken && fullDecodedToken.header;\r\n        var payload = fullDecodedToken && fullDecodedToken.payload;\r\n        var projectIdMatchMessage = \" Make sure the \" + this.tokenInfo.shortName + \" comes from the same \" +\r\n            'Firebase project as the service account used to authenticate this SDK.';\r\n        var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" +\r\n            (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\r\n        var errorMessage;\r\n        if (!fullDecodedToken) {\r\n            errorMessage = \"Decoding \" + this.tokenInfo.jwtName + \" failed. Make sure you passed the entire string JWT \" +\r\n                (\"which represents \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\") + verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (typeof header.kid === 'undefined' && this.algorithm !== 'none') {\r\n            var isCustomToken = (payload.aud === FIREBASE_AUDIENCE);\r\n            var isLegacyCustomToken = (header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d);\r\n            if (isCustomToken) {\r\n                errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" +\r\n                    (this.tokenInfo.shortName + \", but was given a custom token.\");\r\n            }\r\n            else if (isLegacyCustomToken) {\r\n                errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" +\r\n                    (this.tokenInfo.shortName + \", but was given a legacy custom token.\");\r\n            }\r\n            else {\r\n                errorMessage = 'Firebase ID token has no \"kid\" claim.';\r\n            }\r\n            errorMessage += verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (header.alg !== this.algorithm) {\r\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect algorithm. Expected \\\"\" + this.algorithm + '\" but got ' +\r\n                '\"' + header.alg + '\".' + verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (payload.aud !== projectId) {\r\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"aud\\\" (audience) claim. Expected \\\"\" +\r\n                projectId + '\" but got \"' + payload.aud + '\".' + projectIdMatchMessage +\r\n                verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (payload.iss !== this.issuer + projectId) {\r\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"iss\\\" (issuer) claim. Expected \" +\r\n                (\"\\\"\" + this.issuer + \"\\\"\") + projectId + '\" but got \"' +\r\n                payload.iss + '\".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (typeof payload.sub !== 'string') {\r\n            errorMessage = this.tokenInfo.jwtName + \" has no \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (payload.sub === '') {\r\n            errorMessage = this.tokenInfo.jwtName + \" has an empty string \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\r\n        }\r\n        else if (payload.sub.length > 128) {\r\n            errorMessage = this.tokenInfo.jwtName + \" has \\\"sub\\\" (subject) claim longer than 128 characters.\" +\r\n                verifyJwtTokenDocsMessage;\r\n        }\r\n        if (errorMessage) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\r\n        }\r\n        // When the algorithm is set to 'none' there will be no signature and therefore we don't check\r\n        // the public keys.\r\n        if (this.algorithm === 'none') {\r\n            return this.verifyJwtSignatureWithKey(jwtToken, null);\r\n        }\r\n        return this.fetchPublicKeys().then(function (publicKeys) {\r\n            if (!Object.prototype.hasOwnProperty.call(publicKeys, header.kid)) {\r\n                return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, _this.tokenInfo.jwtName + \" has \\\"kid\\\" claim which does not correspond to a known public key. \" +\r\n                    (\"Most likely the \" + _this.tokenInfo.shortName + \" is expired, so get a fresh token from your \") +\r\n                    'client app and try again.'));\r\n            }\r\n            else {\r\n                return _this.verifyJwtSignatureWithKey(jwtToken, publicKeys[header.kid]);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Verifies the JWT signature using the provided public key.\r\n     * @param {string} jwtToken The JWT token to verify.\r\n     * @param {string} publicKey The public key certificate.\r\n     * @return {Promise<DecodedIdToken>} A promise that resolves with the decoded JWT claims on successful\r\n     *     verification.\r\n     */\r\n    FirebaseTokenVerifier.prototype.verifyJwtSignatureWithKey = function (jwtToken, publicKey) {\r\n        var _this = this;\r\n        var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" +\r\n            (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\r\n        return new Promise(function (resolve, reject) {\r\n            jwt.verify(jwtToken, publicKey || '', {\r\n                algorithms: [_this.algorithm],\r\n            }, function (error, decodedToken) {\r\n                if (error) {\r\n                    if (error.name === 'TokenExpiredError') {\r\n                        var errorMessage = _this.tokenInfo.jwtName + \" has expired. Get a fresh \" + _this.tokenInfo.shortName +\r\n                            (\" from your client app and try again (auth/\" + _this.tokenInfo.expiredErrorCode.code + \").\") +\r\n                            verifyJwtTokenDocsMessage;\r\n                        return reject(new error_1.FirebaseAuthError(_this.tokenInfo.expiredErrorCode, errorMessage));\r\n                    }\r\n                    else if (error.name === 'JsonWebTokenError') {\r\n                        var errorMessage = _this.tokenInfo.jwtName + \" has invalid signature.\" + verifyJwtTokenDocsMessage;\r\n                        return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\r\n                    }\r\n                    return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message));\r\n                }\r\n                else {\r\n                    var decodedIdToken = decodedToken;\r\n                    decodedIdToken.uid = decodedIdToken.sub;\r\n                    resolve(decodedIdToken);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Fetches the public keys for the Google certs.\r\n     *\r\n     * @return {Promise<object>} A promise fulfilled with public keys for the Google certs.\r\n     */\r\n    FirebaseTokenVerifier.prototype.fetchPublicKeys = function () {\r\n        var _this = this;\r\n        var publicKeysExist = (typeof this.publicKeys !== 'undefined');\r\n        var publicKeysExpiredExists = (typeof this.publicKeysExpireAt !== 'undefined');\r\n        var publicKeysStillValid = (publicKeysExpiredExists && Date.now() < this.publicKeysExpireAt);\r\n        if (publicKeysExist && publicKeysStillValid) {\r\n            return Promise.resolve(this.publicKeys);\r\n        }\r\n        var client = new api_request_1.HttpClient();\r\n        var request = {\r\n            method: 'GET',\r\n            url: this.clientCertUrl,\r\n            httpAgent: this.app.options.httpAgent,\r\n        };\r\n        return client.send(request).then(function (resp) {\r\n            if (!resp.isJson() || resp.data.error) {\r\n                // Treat all non-json messages and messages with an 'error' field as\r\n                // error responses.\r\n                throw new api_request_1.HttpError(resp);\r\n            }\r\n            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\r\n                var cacheControlHeader = resp.headers['cache-control'];\r\n                var parts = cacheControlHeader.split(',');\r\n                parts.forEach(function (part) {\r\n                    var subParts = part.trim().split('=');\r\n                    if (subParts[0] === 'max-age') {\r\n                        var maxAge = +subParts[1];\r\n                        _this.publicKeysExpireAt = Date.now() + (maxAge * 1000);\r\n                    }\r\n                });\r\n            }\r\n            _this.publicKeys = resp.data;\r\n            return resp.data;\r\n        }).catch(function (err) {\r\n            if (err instanceof api_request_1.HttpError) {\r\n                var errorMessage = 'Error fetching public keys for Google certs: ';\r\n                var resp = err.response;\r\n                if (resp.isJson() && resp.data.error) {\r\n                    errorMessage += \"\" + resp.data.error;\r\n                    if (resp.data.error_description) {\r\n                        errorMessage += ' (' + resp.data.error_description + ')';\r\n                    }\r\n                }\r\n                else {\r\n                    errorMessage += \"\" + resp.text;\r\n                }\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, errorMessage);\r\n            }\r\n            throw err;\r\n        });\r\n    };\r\n    return FirebaseTokenVerifier;\r\n}());\r\nexports.FirebaseTokenVerifier = FirebaseTokenVerifier;\r\n/**\r\n * Creates a new FirebaseTokenVerifier to verify Firebase ID tokens.\r\n *\r\n * @param {FirebaseApp} app Firebase app instance.\r\n * @return {FirebaseTokenVerifier}\r\n */\r\nfunction createIdTokenVerifier(app) {\r\n    return new FirebaseTokenVerifier(CLIENT_CERT_URL, exports.ALGORITHM_RS256, 'https://securetoken.google.com/', exports.ID_TOKEN_INFO, app);\r\n}\r\nexports.createIdTokenVerifier = createIdTokenVerifier;\r\n/**\r\n * Creates a new FirebaseTokenVerifier to verify Firebase session cookies.\r\n *\r\n * @param {FirebaseApp} app Firebase app instance.\r\n * @return {FirebaseTokenVerifier}\r\n */\r\nfunction createSessionCookieVerifier(app) {\r\n    return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, exports.ALGORITHM_RS256, 'https://session.firebase.google.com/', exports.SESSION_COOKIE_INFO, app);\r\n}\r\nexports.createSessionCookieVerifier = createSessionCookieVerifier;\r\n"]},"metadata":{},"sourceType":"script"}