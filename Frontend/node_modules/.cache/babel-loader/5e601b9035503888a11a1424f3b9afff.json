{"ast":null,"code":"var once = require('once');\n\nvar eos = require('end-of-stream');\n\nvar fs = require('fs'); // we only need fs to get the ReadStream and WriteStream prototypes\n\n\nvar noop = function () {};\n\nvar ancient = /^v?\\.0/.test(process.version);\n\nvar isFn = function (fn) {\n  return typeof fn === 'function';\n};\n\nvar isFS = function (stream) {\n  if (!ancient) return false; // newer node version do not need to care about fs is a special way\n\n  if (!fs) return false; // browser\n\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);\n};\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort);\n};\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n    if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks\n\n    if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy();\n    callback(err || new Error('stream was destroyed'));\n  };\n};\n\nvar call = function (fn) {\n  fn();\n};\n\nvar pipe = function (from, to) {\n  return from.pipe(to);\n};\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments);\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum');\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n};\n\nmodule.exports = pump;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/pump/index.js"],"names":["once","require","eos","fs","noop","ancient","test","process","version","isFn","fn","isFS","stream","ReadStream","WriteStream","close","isRequest","setHeader","abort","destroyer","reading","writing","callback","closed","on","readable","writable","err","destroyed","destroy","Error","call","pipe","from","to","pump","streams","Array","prototype","slice","arguments","length","pop","isArray","error","destroys","map","i","forEach","reduce","module","exports"],"mappings":"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","sourcesContent":["var once = require('once')\r\nvar eos = require('end-of-stream')\r\nvar fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\r\n\r\nvar noop = function () {}\r\nvar ancient = /^v?\\.0/.test(process.version)\r\n\r\nvar isFn = function (fn) {\r\n  return typeof fn === 'function'\r\n}\r\n\r\nvar isFS = function (stream) {\r\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\r\n  if (!fs) return false // browser\r\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\r\n}\r\n\r\nvar isRequest = function (stream) {\r\n  return stream.setHeader && isFn(stream.abort)\r\n}\r\n\r\nvar destroyer = function (stream, reading, writing, callback) {\r\n  callback = once(callback)\r\n\r\n  var closed = false\r\n  stream.on('close', function () {\r\n    closed = true\r\n  })\r\n\r\n  eos(stream, {readable: reading, writable: writing}, function (err) {\r\n    if (err) return callback(err)\r\n    closed = true\r\n    callback()\r\n  })\r\n\r\n  var destroyed = false\r\n  return function (err) {\r\n    if (closed) return\r\n    if (destroyed) return\r\n    destroyed = true\r\n\r\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\r\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\r\n\r\n    if (isFn(stream.destroy)) return stream.destroy()\r\n\r\n    callback(err || new Error('stream was destroyed'))\r\n  }\r\n}\r\n\r\nvar call = function (fn) {\r\n  fn()\r\n}\r\n\r\nvar pipe = function (from, to) {\r\n  return from.pipe(to)\r\n}\r\n\r\nvar pump = function () {\r\n  var streams = Array.prototype.slice.call(arguments)\r\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\r\n\r\n  if (Array.isArray(streams[0])) streams = streams[0]\r\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\r\n\r\n  var error\r\n  var destroys = streams.map(function (stream, i) {\r\n    var reading = i < streams.length - 1\r\n    var writing = i > 0\r\n    return destroyer(stream, reading, writing, function (err) {\r\n      if (!error) error = err\r\n      if (err) destroys.forEach(call)\r\n      if (reading) return\r\n      destroys.forEach(call)\r\n      callback(error)\r\n    })\r\n  })\r\n\r\n  return streams.reduce(pipe)\r\n}\r\n\r\nmodule.exports = pump\r\n"]},"metadata":{},"sourceType":"script"}