{"ast":null,"code":"/*! firebase-admin v9.4.2 */\n\"use strict\";\n/*!\r\n * Copyright 2020 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getApplicationDefault = exports.isApplicationDefault = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar util = require(\"../utils/validator\");\n\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token'; // NOTE: the Google Metadata Service uses HTTP over a vlan\n\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\n\nvar configDir = function () {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  var sys = os.platform();\n\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  } // On *nix the gcloud cli creates a . dir.\n\n\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n}();\n\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n/**\r\n * Implementation of Credential that uses a service account.\r\n */\n\nvar ServiceAccountCredential =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new ServiceAccountCredential from the given parameters.\r\n   *\r\n   * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\r\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\r\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\r\n   *   environment, as opposed to being explicitly specified by the developer.\r\n   *\r\n   * @constructor\r\n   */\n  function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    var serviceAccount = typeof serviceAccountPathOrObject === 'string' ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);\n    this.projectId = serviceAccount.projectId;\n    this.privateKey = serviceAccount.privateKey;\n    this.clientEmail = serviceAccount.clientEmail;\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  ServiceAccountCredential.prototype.getAccessToken = function () {\n    var token = this.createAuthJwt_();\n    var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    var request = {\n      method: 'POST',\n      url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ServiceAccountCredential.prototype.createAuthJwt_ = function () {\n    var claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    }; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n    var jwt = require('jsonwebtoken'); // This method is actually synchronous so we can capture and return the buffer.\n\n\n    return jwt.sign(claims, this.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  };\n\n  return ServiceAccountCredential;\n}();\n\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\r\n * A struct containing the properties necessary to use service account JSON credentials.\r\n */\n\nvar ServiceAccount =\n/** @class */\nfunction () {\n  function ServiceAccount(json) {\n    if (!util.isNonNullObject(json)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n    }\n\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.projectId)) {\n      errorMessage = 'Service account object must contain a string \"project_id\" property.';\n    } else if (!util.isNonEmptyString(this.privateKey)) {\n      errorMessage = 'Service account object must contain a string \"private_key\" property.';\n    } else if (!util.isNonEmptyString(this.clientEmail)) {\n      errorMessage = 'Service account object must contain a string \"client_email\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    } // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n    var forge = require('node-forge');\n\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n\n  ServiceAccount.fromPath = function (filePath) {\n    try {\n      return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n    }\n  };\n\n  return ServiceAccount;\n}();\n/**\r\n * Implementation of Credential that gets access tokens from the metadata service available\r\n * in the Google Cloud Platform. This authenticates the process as the default service account\r\n * of an App Engine instance or Google Compute Engine machine.\r\n */\n\n\nvar ComputeEngineCredential =\n/** @class */\nfunction () {\n  function ComputeEngineCredential(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  ComputeEngineCredential.prototype.getAccessToken = function () {\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  ComputeEngineCredential.prototype.getProjectId = function () {\n    var _this = this;\n\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n\n    var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n    return this.httpClient.send(request).then(function (resp) {\n      _this.projectId = resp.text;\n      return _this.projectId;\n    }).catch(function (err) {\n      var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\n    });\n  };\n\n  ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\n    return {\n      method: 'GET',\n      url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\n      headers: {\n        'Metadata-Flavor': 'Google'\n      },\n      httpAgent: this.httpAgent\n    };\n  };\n\n  return ComputeEngineCredential;\n}();\n\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\r\n * Implementation of Credential that gets access tokens from refresh tokens.\r\n */\n\nvar RefreshTokenCredential =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new RefreshTokenCredential from the given parameters.\r\n   *\r\n   * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\r\n   * @param httpAgent Optional http.Agent to use when calling the remote token server.\r\n   * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\r\n   *   environment, as opposed to being explicitly specified by the developer.\r\n   *\r\n   * @constructor\r\n   */\n  function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\n    if (implicit === void 0) {\n      implicit = false;\n    }\n\n    this.httpAgent = httpAgent;\n    this.implicit = implicit;\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n  }\n\n  RefreshTokenCredential.prototype.getAccessToken = function () {\n    var postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    var request = {\n      method: 'POST',\n      url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  return RefreshTokenCredential;\n}();\n\nexports.RefreshTokenCredential = RefreshTokenCredential;\n\nvar RefreshToken =\n/** @class */\nfunction () {\n  function RefreshToken(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    var errorMessage;\n\n    if (!util.isNonEmptyString(this.clientId)) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (!util.isNonEmptyString(this.clientSecret)) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (!util.isNonEmptyString(this.refreshToken)) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (!util.isNonEmptyString(this.type)) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n  /*\r\n   * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\r\n   * data at the path is invalid.\r\n   */\n\n\n  RefreshToken.fromPath = function (filePath) {\n    try {\n      return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  };\n\n  return RefreshToken;\n}();\n/**\r\n * Checks if the given credential was loaded via the application default credentials mechanism. This\r\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\r\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\r\n * instantiated.\r\n *\r\n * @param credential The credential instance to check.\r\n */\n\n\nfunction isApplicationDefault(credential) {\n  return credential instanceof ComputeEngineCredential || credential instanceof ServiceAccountCredential && credential.implicit || credential instanceof RefreshTokenCredential && credential.implicit;\n}\n\nexports.isApplicationDefault = isApplicationDefault;\n\nfunction getApplicationDefault(httpAgent) {\n  if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n    return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n  } // It is OK to not have this file. If it is present, it must be valid.\n\n\n  if (GCLOUD_CREDENTIAL_PATH) {\n    var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\n\n    if (refreshToken) {\n      return new RefreshTokenCredential(refreshToken, httpAgent, true);\n    }\n  }\n\n  return new ComputeEngineCredential(httpAgent);\n}\n\nexports.getApplicationDefault = getApplicationDefault;\n/**\r\n * Copies the specified property from one object to another.\r\n *\r\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\r\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\r\n *\r\n * @param to Target object to copy the property into.\r\n * @param from Source object to copy the property from.\r\n * @param key Name of the property to copy.\r\n * @param alt Alternative name of the property to copy.\r\n */\n\nfunction copyAttr(to, from, key, alt) {\n  var tmp = from[key] || from[alt];\n\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n/**\r\n * Obtain a new OAuth2 token by making a remote service call.\r\n */\n\n\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(function (resp) {\n    var json = resp.data;\n\n    if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n    }\n\n    return json;\n  }).catch(function (err) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\r\n * Constructs a human-readable error message from the given Error.\r\n */\n\n\nfunction getErrorMessage(err) {\n  var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n  return \"Error fetching access token: \" + detail;\n}\n/**\r\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\r\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\r\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\r\n */\n\n\nfunction getDetailFromResponse(response) {\n  if (response.isJson() && response.data.error) {\n    var json = response.data;\n    var detail = json.error;\n\n    if (json.error_description) {\n      detail += ' (' + json.error_description + ')';\n    }\n\n    return detail;\n  }\n\n  return response.text || 'Missing error payload';\n}\n\nfunction credentialFromFile(filePath, httpAgent) {\n  var credentialsFile = readCredentialFile(filePath);\n\n  if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n  }\n\n  if (credentialsFile.type === 'service_account') {\n    return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n  }\n\n  if (credentialsFile.type === 'authorized_user') {\n    return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n  }\n\n  throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\n\nfunction readCredentialFile(filePath, ignoreMissing) {\n  var fileText;\n\n  try {\n    fileText = fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    if (ignoreMissing) {\n      return null;\n    }\n\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n  }\n\n  try {\n    return JSON.parse(fileText);\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n  }\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/firebase-admin/lib/credential/credential-internal.js"],"names":["Object","defineProperty","exports","value","getApplicationDefault","isApplicationDefault","RefreshTokenCredential","ComputeEngineCredential","ServiceAccountCredential","fs","require","os","path","error_1","api_request_1","util","GOOGLE_TOKEN_AUDIENCE","GOOGLE_AUTH_TOKEN_HOST","GOOGLE_AUTH_TOKEN_PATH","GOOGLE_METADATA_SERVICE_HOST","GOOGLE_METADATA_SERVICE_TOKEN_PATH","GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH","configDir","sys","platform","length","substring","toLowerCase","process","env","APPDATA","HOME","resolve","GCLOUD_CREDENTIAL_SUFFIX","GCLOUD_CREDENTIAL_PATH","REFRESH_TOKEN_HOST","REFRESH_TOKEN_PATH","ONE_HOUR_IN_SECONDS","JWT_ALGORITHM","serviceAccountPathOrObject","httpAgent","implicit","serviceAccount","ServiceAccount","fromPath","projectId","privateKey","clientEmail","httpClient","HttpClient","prototype","getAccessToken","token","createAuthJwt_","postData","request","method","url","headers","data","requestAccessToken","claims","scope","join","jwt","sign","audience","expiresIn","issuer","algorithm","json","isNonNullObject","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","copyAttr","errorMessage","isNonEmptyString","forge","pki","privateKeyFromPem","error","filePath","JSON","parse","readFileSync","buildRequest","getProjectId","_this","Promise","send","then","resp","text","catch","err","detail","HttpError","getDetailFromResponse","response","message","urlPath","refreshTokenPathOrObject","refreshToken","RefreshToken","clientId","clientSecret","type","credential","GOOGLE_APPLICATION_CREDENTIALS","credentialFromFile","readCredentialFile","to","from","key","alt","tmp","client","access_token","expires_in","stringify","getErrorMessage","isJson","error_description","credentialsFile","ignoreMissing","fileText"],"mappings":"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","sourcesContent":["/*! firebase-admin v9.4.2 */\r\n\"use strict\";\r\n/*!\r\n * Copyright 2020 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getApplicationDefault = exports.isApplicationDefault = exports.RefreshTokenCredential = exports.ComputeEngineCredential = exports.ServiceAccountCredential = void 0;\r\nvar fs = require(\"fs\");\r\nvar os = require(\"os\");\r\nvar path = require(\"path\");\r\nvar error_1 = require(\"../utils/error\");\r\nvar api_request_1 = require(\"../utils/api-request\");\r\nvar util = require(\"../utils/validator\");\r\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\r\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\r\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\r\n// NOTE: the Google Metadata Service uses HTTP over a vlan\r\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\r\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\r\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\r\nvar configDir = (function () {\r\n    // Windows has a dedicated low-rights location for apps at ~/Application Data\r\n    var sys = os.platform();\r\n    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\r\n        return process.env.APPDATA;\r\n    }\r\n    // On *nix the gcloud cli creates a . dir.\r\n    return process.env.HOME && path.resolve(process.env.HOME, '.config');\r\n})();\r\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\r\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\r\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\r\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\r\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\r\nvar JWT_ALGORITHM = 'RS256';\r\n/**\r\n * Implementation of Credential that uses a service account.\r\n */\r\nvar ServiceAccountCredential = /** @class */ (function () {\r\n    /**\r\n     * Creates a new ServiceAccountCredential from the given parameters.\r\n     *\r\n     * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\r\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\r\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\r\n     *   environment, as opposed to being explicitly specified by the developer.\r\n     *\r\n     * @constructor\r\n     */\r\n    function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\r\n        if (implicit === void 0) { implicit = false; }\r\n        this.httpAgent = httpAgent;\r\n        this.implicit = implicit;\r\n        var serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?\r\n            ServiceAccount.fromPath(serviceAccountPathOrObject)\r\n            : new ServiceAccount(serviceAccountPathOrObject);\r\n        this.projectId = serviceAccount.projectId;\r\n        this.privateKey = serviceAccount.privateKey;\r\n        this.clientEmail = serviceAccount.clientEmail;\r\n        this.httpClient = new api_request_1.HttpClient();\r\n    }\r\n    ServiceAccountCredential.prototype.getAccessToken = function () {\r\n        var token = this.createAuthJwt_();\r\n        var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +\r\n            'grant-type%3Ajwt-bearer&assertion=' + token;\r\n        var request = {\r\n            method: 'POST',\r\n            url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded',\r\n            },\r\n            data: postData,\r\n            httpAgent: this.httpAgent,\r\n        };\r\n        return requestAccessToken(this.httpClient, request);\r\n    };\r\n    ServiceAccountCredential.prototype.createAuthJwt_ = function () {\r\n        var claims = {\r\n            scope: [\r\n                'https://www.googleapis.com/auth/cloud-platform',\r\n                'https://www.googleapis.com/auth/firebase.database',\r\n                'https://www.googleapis.com/auth/firebase.messaging',\r\n                'https://www.googleapis.com/auth/identitytoolkit',\r\n                'https://www.googleapis.com/auth/userinfo.email',\r\n            ].join(' '),\r\n        };\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        var jwt = require('jsonwebtoken');\r\n        // This method is actually synchronous so we can capture and return the buffer.\r\n        return jwt.sign(claims, this.privateKey, {\r\n            audience: GOOGLE_TOKEN_AUDIENCE,\r\n            expiresIn: ONE_HOUR_IN_SECONDS,\r\n            issuer: this.clientEmail,\r\n            algorithm: JWT_ALGORITHM,\r\n        });\r\n    };\r\n    return ServiceAccountCredential;\r\n}());\r\nexports.ServiceAccountCredential = ServiceAccountCredential;\r\n/**\r\n * A struct containing the properties necessary to use service account JSON credentials.\r\n */\r\nvar ServiceAccount = /** @class */ (function () {\r\n    function ServiceAccount(json) {\r\n        if (!util.isNonNullObject(json)) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\r\n        }\r\n        copyAttr(this, json, 'projectId', 'project_id');\r\n        copyAttr(this, json, 'privateKey', 'private_key');\r\n        copyAttr(this, json, 'clientEmail', 'client_email');\r\n        var errorMessage;\r\n        if (!util.isNonEmptyString(this.projectId)) {\r\n            errorMessage = 'Service account object must contain a string \"project_id\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.privateKey)) {\r\n            errorMessage = 'Service account object must contain a string \"private_key\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.clientEmail)) {\r\n            errorMessage = 'Service account object must contain a string \"client_email\" property.';\r\n        }\r\n        if (typeof errorMessage !== 'undefined') {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        var forge = require('node-forge');\r\n        try {\r\n            forge.pki.privateKeyFromPem(this.privateKey);\r\n        }\r\n        catch (error) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\r\n        }\r\n    }\r\n    ServiceAccount.fromPath = function (filePath) {\r\n        try {\r\n            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\r\n        }\r\n        catch (error) {\r\n            // Throw a nicely formed error message if the file contents cannot be parsed\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\r\n        }\r\n    };\r\n    return ServiceAccount;\r\n}());\r\n/**\r\n * Implementation of Credential that gets access tokens from the metadata service available\r\n * in the Google Cloud Platform. This authenticates the process as the default service account\r\n * of an App Engine instance or Google Compute Engine machine.\r\n */\r\nvar ComputeEngineCredential = /** @class */ (function () {\r\n    function ComputeEngineCredential(httpAgent) {\r\n        this.httpClient = new api_request_1.HttpClient();\r\n        this.httpAgent = httpAgent;\r\n    }\r\n    ComputeEngineCredential.prototype.getAccessToken = function () {\r\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\r\n        return requestAccessToken(this.httpClient, request);\r\n    };\r\n    ComputeEngineCredential.prototype.getProjectId = function () {\r\n        var _this = this;\r\n        if (this.projectId) {\r\n            return Promise.resolve(this.projectId);\r\n        }\r\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\r\n        return this.httpClient.send(request)\r\n            .then(function (resp) {\r\n            _this.projectId = resp.text;\r\n            return _this.projectId;\r\n        })\r\n            .catch(function (err) {\r\n            var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\r\n        });\r\n    };\r\n    ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\r\n        return {\r\n            method: 'GET',\r\n            url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\r\n            headers: {\r\n                'Metadata-Flavor': 'Google',\r\n            },\r\n            httpAgent: this.httpAgent,\r\n        };\r\n    };\r\n    return ComputeEngineCredential;\r\n}());\r\nexports.ComputeEngineCredential = ComputeEngineCredential;\r\n/**\r\n * Implementation of Credential that gets access tokens from refresh tokens.\r\n */\r\nvar RefreshTokenCredential = /** @class */ (function () {\r\n    /**\r\n     * Creates a new RefreshTokenCredential from the given parameters.\r\n     *\r\n     * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\r\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\r\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\r\n     *   environment, as opposed to being explicitly specified by the developer.\r\n     *\r\n     * @constructor\r\n     */\r\n    function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\r\n        if (implicit === void 0) { implicit = false; }\r\n        this.httpAgent = httpAgent;\r\n        this.implicit = implicit;\r\n        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?\r\n            RefreshToken.fromPath(refreshTokenPathOrObject)\r\n            : new RefreshToken(refreshTokenPathOrObject);\r\n        this.httpClient = new api_request_1.HttpClient();\r\n    }\r\n    RefreshTokenCredential.prototype.getAccessToken = function () {\r\n        var postData = 'client_id=' + this.refreshToken.clientId + '&' +\r\n            'client_secret=' + this.refreshToken.clientSecret + '&' +\r\n            'refresh_token=' + this.refreshToken.refreshToken + '&' +\r\n            'grant_type=refresh_token';\r\n        var request = {\r\n            method: 'POST',\r\n            url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded',\r\n            },\r\n            data: postData,\r\n            httpAgent: this.httpAgent,\r\n        };\r\n        return requestAccessToken(this.httpClient, request);\r\n    };\r\n    return RefreshTokenCredential;\r\n}());\r\nexports.RefreshTokenCredential = RefreshTokenCredential;\r\nvar RefreshToken = /** @class */ (function () {\r\n    function RefreshToken(json) {\r\n        copyAttr(this, json, 'clientId', 'client_id');\r\n        copyAttr(this, json, 'clientSecret', 'client_secret');\r\n        copyAttr(this, json, 'refreshToken', 'refresh_token');\r\n        copyAttr(this, json, 'type', 'type');\r\n        var errorMessage;\r\n        if (!util.isNonEmptyString(this.clientId)) {\r\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.clientSecret)) {\r\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.refreshToken)) {\r\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\r\n        }\r\n        else if (!util.isNonEmptyString(this.type)) {\r\n            errorMessage = 'Refresh token must contain a \"type\" property.';\r\n        }\r\n        if (typeof errorMessage !== 'undefined') {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\r\n        }\r\n    }\r\n    /*\r\n     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\r\n     * data at the path is invalid.\r\n     */\r\n    RefreshToken.fromPath = function (filePath) {\r\n        try {\r\n            return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\r\n        }\r\n        catch (error) {\r\n            // Throw a nicely formed error message if the file contents cannot be parsed\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\r\n        }\r\n    };\r\n    return RefreshToken;\r\n}());\r\n/**\r\n * Checks if the given credential was loaded via the application default credentials mechanism. This\r\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\r\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\r\n * instantiated.\r\n *\r\n * @param credential The credential instance to check.\r\n */\r\nfunction isApplicationDefault(credential) {\r\n    return credential instanceof ComputeEngineCredential ||\r\n        (credential instanceof ServiceAccountCredential && credential.implicit) ||\r\n        (credential instanceof RefreshTokenCredential && credential.implicit);\r\n}\r\nexports.isApplicationDefault = isApplicationDefault;\r\nfunction getApplicationDefault(httpAgent) {\r\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\r\n        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\r\n    }\r\n    // It is OK to not have this file. If it is present, it must be valid.\r\n    if (GCLOUD_CREDENTIAL_PATH) {\r\n        var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\r\n        if (refreshToken) {\r\n            return new RefreshTokenCredential(refreshToken, httpAgent, true);\r\n        }\r\n    }\r\n    return new ComputeEngineCredential(httpAgent);\r\n}\r\nexports.getApplicationDefault = getApplicationDefault;\r\n/**\r\n * Copies the specified property from one object to another.\r\n *\r\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\r\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\r\n *\r\n * @param to Target object to copy the property into.\r\n * @param from Source object to copy the property from.\r\n * @param key Name of the property to copy.\r\n * @param alt Alternative name of the property to copy.\r\n */\r\nfunction copyAttr(to, from, key, alt) {\r\n    var tmp = from[key] || from[alt];\r\n    if (typeof tmp !== 'undefined') {\r\n        to[key] = tmp;\r\n    }\r\n}\r\n/**\r\n * Obtain a new OAuth2 token by making a remote service call.\r\n */\r\nfunction requestAccessToken(client, request) {\r\n    return client.send(request).then(function (resp) {\r\n        var json = resp.data;\r\n        if (!json.access_token || !json.expires_in) {\r\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\r\n        }\r\n        return json;\r\n    }).catch(function (err) {\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\r\n    });\r\n}\r\n/**\r\n * Constructs a human-readable error message from the given Error.\r\n */\r\nfunction getErrorMessage(err) {\r\n    var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\r\n    return \"Error fetching access token: \" + detail;\r\n}\r\n/**\r\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\r\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\r\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\r\n */\r\nfunction getDetailFromResponse(response) {\r\n    if (response.isJson() && response.data.error) {\r\n        var json = response.data;\r\n        var detail = json.error;\r\n        if (json.error_description) {\r\n            detail += ' (' + json.error_description + ')';\r\n        }\r\n        return detail;\r\n    }\r\n    return response.text || 'Missing error payload';\r\n}\r\nfunction credentialFromFile(filePath, httpAgent) {\r\n    var credentialsFile = readCredentialFile(filePath);\r\n    if (typeof credentialsFile !== 'object' || credentialsFile === null) {\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\r\n    }\r\n    if (credentialsFile.type === 'service_account') {\r\n        return new ServiceAccountCredential(credentialsFile, httpAgent, true);\r\n    }\r\n    if (credentialsFile.type === 'authorized_user') {\r\n        return new RefreshTokenCredential(credentialsFile, httpAgent, true);\r\n    }\r\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\r\n}\r\nfunction readCredentialFile(filePath, ignoreMissing) {\r\n    var fileText;\r\n    try {\r\n        fileText = fs.readFileSync(filePath, 'utf8');\r\n    }\r\n    catch (error) {\r\n        if (ignoreMissing) {\r\n            return null;\r\n        }\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\r\n    }\r\n    try {\r\n        return JSON.parse(fileText);\r\n    }\r\n    catch (error) {\r\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}