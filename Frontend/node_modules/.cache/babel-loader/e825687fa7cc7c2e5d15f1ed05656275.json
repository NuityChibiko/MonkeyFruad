{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst warnings_1 = require(\"../warnings\");\n\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\n\nconst task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\r\n * BundleExecutor stores several timers for each bundle (calls are bundled based\r\n * on the options passed, each bundle has unique ID that is calculated based on\r\n * field values). Each timer fires and sends a call after certain amount of\r\n * time, and if a new request comes to the same bundle, the timer can be\r\n * restarted.\r\n */\n\n\nclass BundleExecutor {\n  /**\r\n   * Organizes requests for an api service that requires to bundle them.\r\n   *\r\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\r\n   *   uses when executing bundled functions.\r\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\r\n   * @constructor\r\n   */\n  constructor(bundleOptions, bundleDescriptor) {\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\r\n   * Schedule a method call.\r\n   *\r\n   * @param {function} apiCall - the function for an API call.\r\n   * @param {Object} request - the request object to be bundled with others.\r\n   * @param {APICallback} callback - the callback to be called when the method finished.\r\n   * @return {function()} - the function to cancel the scheduled invocation.\r\n   */\n\n\n  schedule(apiCall, request, callback) {\n    const bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n    callback = callback || noop;\n\n    if (bundleId === undefined) {\n      warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + `Invoking immediately. Request: ${JSON.stringify(request)} ` + `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n      return apiCall(request, callback);\n    }\n\n    if (request[this._descriptor.bundledField] === undefined) {\n      warnings_1.warn('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` + `Invoking immediately. Request: ${JSON.stringify(request)}`);\n      return apiCall(request, callback);\n    }\n\n    if (!(bundleId in this._tasks)) {\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n    }\n\n    let task = this._tasks[bundleId];\n    callback.id = String(this._invocationId++);\n    this._invocations[callback.id] = bundleId;\n    const bundledField = request[this._descriptor.bundledField];\n    const elementCount = bundledField.length;\n    let requestBytes = 0; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const self = this;\n    bundledField.forEach(obj => {\n      requestBytes += this._descriptor.byteLengthFunction(obj);\n    });\n    const countLimit = this._options.elementCountLimit || 0;\n    const byteLimit = this._options.requestByteLimit || 0;\n\n    if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n      let message;\n\n      if (countLimit > 0 && elementCount > countLimit) {\n        message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n      } else {\n        message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n      }\n\n      const error = new googleError_1.GoogleError(message);\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n      return {\n        cancel: noop\n      };\n    }\n\n    const existingCount = task.getElementCount();\n    const existingBytes = task.getRequestByteSize();\n\n    if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n      this._runNow(bundleId);\n\n      this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      task = this._tasks[bundleId];\n    }\n\n    task.extend(bundledField, requestBytes, callback);\n    const ret = {\n      cancel() {\n        self._cancel(callback.id);\n      }\n\n    };\n    const countThreshold = this._options.elementCountThreshold || 0;\n    const sizeThreshold = this._options.requestByteThreshold || 0;\n\n    if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n      this._runNow(bundleId);\n\n      return ret;\n    }\n\n    if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n      this._timers[bundleId] = setTimeout(() => {\n        delete this._timers[bundleId];\n\n        this._runNow(bundleId);\n      }, this._options.delayThreshold);\n    }\n\n    return ret;\n  }\n  /**\r\n   * Clears scheduled timeout if it exists.\r\n   *\r\n   * @param {String} bundleId - the id for the task whose timeout needs to be\r\n   *   cleared.\r\n   * @private\r\n   */\n\n\n  _maybeClearTimeout(bundleId) {\n    if (bundleId in this._timers) {\n      const timerId = this._timers[bundleId];\n      delete this._timers[bundleId];\n      clearTimeout(timerId);\n    }\n  }\n  /**\r\n   * Cancels an event.\r\n   *\r\n   * @param {String} id - The id for the event in the task.\r\n   * @private\r\n   */\n\n\n  _cancel(id) {\n    if (!(id in this._invocations)) {\n      return;\n    }\n\n    const bundleId = this._invocations[id];\n\n    if (!(bundleId in this._tasks)) {\n      return;\n    }\n\n    const task = this._tasks[bundleId];\n    delete this._invocations[id];\n\n    if (task.cancel(id)) {\n      this._maybeClearTimeout(bundleId);\n\n      delete this._tasks[bundleId];\n    }\n  }\n  /**\r\n   * Invokes a task.\r\n   *\r\n   * @param {String} bundleId - The id for the task.\r\n   * @private\r\n   */\n\n\n  _runNow(bundleId) {\n    if (!(bundleId in this._tasks)) {\n      warnings_1.warn('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n      return;\n    }\n\n    this._maybeClearTimeout(bundleId);\n\n    const task = this._tasks[bundleId];\n    delete this._tasks[bundleId];\n    task.run().forEach(id => {\n      delete this._invocations[id];\n    });\n  }\n\n}\n\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"sources":["../../../src/bundlingCalls/bundleExecutor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BundleExecutor = void 0;\r\nconst status_1 = require(\"../status\");\r\nconst googleError_1 = require(\"../googleError\");\r\nconst warnings_1 = require(\"../warnings\");\r\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\r\nconst task_1 = require(\"./task\");\r\nfunction noop() { }\r\n/**\r\n * BundleExecutor stores several timers for each bundle (calls are bundled based\r\n * on the options passed, each bundle has unique ID that is calculated based on\r\n * field values). Each timer fires and sends a call after certain amount of\r\n * time, and if a new request comes to the same bundle, the timer can be\r\n * restarted.\r\n */\r\nclass BundleExecutor {\r\n    /**\r\n     * Organizes requests for an api service that requires to bundle them.\r\n     *\r\n     * @param {BundleOptions} bundleOptions - configures strategy this instance\r\n     *   uses when executing bundled functions.\r\n     * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\r\n     * @constructor\r\n     */\r\n    constructor(bundleOptions, bundleDescriptor) {\r\n        this._options = bundleOptions;\r\n        this._descriptor = bundleDescriptor;\r\n        this._tasks = {};\r\n        this._timers = {};\r\n        this._invocations = {};\r\n        this._invocationId = 0;\r\n    }\r\n    /**\r\n     * Schedule a method call.\r\n     *\r\n     * @param {function} apiCall - the function for an API call.\r\n     * @param {Object} request - the request object to be bundled with others.\r\n     * @param {APICallback} callback - the callback to be called when the method finished.\r\n     * @return {function()} - the function to cancel the scheduled invocation.\r\n     */\r\n    schedule(apiCall, request, callback) {\r\n        const bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\r\n        callback = (callback || noop);\r\n        if (bundleId === undefined) {\r\n            warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' +\r\n                `Invoking immediately. Request: ${JSON.stringify(request)} ` +\r\n                `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\r\n            return apiCall(request, callback);\r\n        }\r\n        if (request[this._descriptor.bundledField] === undefined) {\r\n            warnings_1.warn('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` +\r\n                `Invoking immediately. Request: ${JSON.stringify(request)}`);\r\n            return apiCall(request, callback);\r\n        }\r\n        if (!(bundleId in this._tasks)) {\r\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\r\n        }\r\n        let task = this._tasks[bundleId];\r\n        callback.id = String(this._invocationId++);\r\n        this._invocations[callback.id] = bundleId;\r\n        const bundledField = request[this._descriptor.bundledField];\r\n        const elementCount = bundledField.length;\r\n        let requestBytes = 0;\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        bundledField.forEach(obj => {\r\n            requestBytes += this._descriptor.byteLengthFunction(obj);\r\n        });\r\n        const countLimit = this._options.elementCountLimit || 0;\r\n        const byteLimit = this._options.requestByteLimit || 0;\r\n        if ((countLimit > 0 && elementCount > countLimit) ||\r\n            (byteLimit > 0 && requestBytes >= byteLimit)) {\r\n            let message;\r\n            if (countLimit > 0 && elementCount > countLimit) {\r\n                message =\r\n                    'The number of elements ' +\r\n                        elementCount +\r\n                        ' exceeds the limit ' +\r\n                        this._options.elementCountLimit;\r\n            }\r\n            else {\r\n                message =\r\n                    'The required bytes ' +\r\n                        requestBytes +\r\n                        ' exceeds the limit ' +\r\n                        this._options.requestByteLimit;\r\n            }\r\n            const error = new googleError_1.GoogleError(message);\r\n            error.code = status_1.Status.INVALID_ARGUMENT;\r\n            callback(error);\r\n            return {\r\n                cancel: noop,\r\n            };\r\n        }\r\n        const existingCount = task.getElementCount();\r\n        const existingBytes = task.getRequestByteSize();\r\n        if ((countLimit > 0 && elementCount + existingCount >= countLimit) ||\r\n            (byteLimit > 0 && requestBytes + existingBytes >= byteLimit)) {\r\n            this._runNow(bundleId);\r\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\r\n            task = this._tasks[bundleId];\r\n        }\r\n        task.extend(bundledField, requestBytes, callback);\r\n        const ret = {\r\n            cancel() {\r\n                self._cancel(callback.id);\r\n            },\r\n        };\r\n        const countThreshold = this._options.elementCountThreshold || 0;\r\n        const sizeThreshold = this._options.requestByteThreshold || 0;\r\n        if ((countThreshold > 0 && task.getElementCount() >= countThreshold) ||\r\n            (sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold)) {\r\n            this._runNow(bundleId);\r\n            return ret;\r\n        }\r\n        if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\r\n            this._timers[bundleId] = setTimeout(() => {\r\n                delete this._timers[bundleId];\r\n                this._runNow(bundleId);\r\n            }, this._options.delayThreshold);\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * Clears scheduled timeout if it exists.\r\n     *\r\n     * @param {String} bundleId - the id for the task whose timeout needs to be\r\n     *   cleared.\r\n     * @private\r\n     */\r\n    _maybeClearTimeout(bundleId) {\r\n        if (bundleId in this._timers) {\r\n            const timerId = this._timers[bundleId];\r\n            delete this._timers[bundleId];\r\n            clearTimeout(timerId);\r\n        }\r\n    }\r\n    /**\r\n     * Cancels an event.\r\n     *\r\n     * @param {String} id - The id for the event in the task.\r\n     * @private\r\n     */\r\n    _cancel(id) {\r\n        if (!(id in this._invocations)) {\r\n            return;\r\n        }\r\n        const bundleId = this._invocations[id];\r\n        if (!(bundleId in this._tasks)) {\r\n            return;\r\n        }\r\n        const task = this._tasks[bundleId];\r\n        delete this._invocations[id];\r\n        if (task.cancel(id)) {\r\n            this._maybeClearTimeout(bundleId);\r\n            delete this._tasks[bundleId];\r\n        }\r\n    }\r\n    /**\r\n     * Invokes a task.\r\n     *\r\n     * @param {String} bundleId - The id for the task.\r\n     * @private\r\n     */\r\n    _runNow(bundleId) {\r\n        if (!(bundleId in this._tasks)) {\r\n            warnings_1.warn('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\r\n            return;\r\n        }\r\n        this._maybeClearTimeout(bundleId);\r\n        const task = this._tasks[bundleId];\r\n        delete this._tasks[bundleId];\r\n        task.run().forEach(id => {\r\n            delete this._invocations[id];\r\n        });\r\n    }\r\n}\r\nexports.BundleExecutor = BundleExecutor;\r\n//# sourceMappingURL=bundleExecutor.js.map"]},"metadata":{},"sourceType":"script"}