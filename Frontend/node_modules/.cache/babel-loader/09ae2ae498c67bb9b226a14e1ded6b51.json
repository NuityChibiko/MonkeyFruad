{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst reference_1 = require(\"./reference\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst validate_1 = require(\"./validate\");\n\nconst BUNDLE_VERSION = 1;\n/**\r\n * Builds a Firestore data bundle with results from the given document and query snapshots.\r\n */\n\nclass BundleBuilder {\n  constructor(bundleId) {\n    this.bundleId = bundleId; // Resulting documents for the bundle, keyed by full document path.\n\n    this.documents = new Map(); // Named queries saved in the bundle, keyed by query name.\n\n    this.namedQueries = new Map(); // The latest read time among all bundled documents and queries.\n\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\r\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\r\n   * Both the documents data and the query read time will be included in the bundle.\r\n   *\r\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\r\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\r\n   * @returns {BundleBuilder} This instance.\r\n   *\r\n   * @example\r\n   * const bundle = firestore.bundle('data-bundle');\r\n   * const docSnapshot = await firestore.doc('abc/123').get();\r\n   * const querySnapshot = await firestore.collection('coll').get();\r\n   *\r\n   * const bundleBuffer = bundle.add(docSnapshot); // Add a document\r\n   *                            .add('coll-query', querySnapshot) // Add a named query.\r\n   *                            .build()\r\n   * // Save `bundleBuffer` to CDN or stream it to clients.\r\n   */\n\n\n  add(documentOrName, querySnapshot) {\n    // eslint-disable-next-line prefer-rest-params\n    validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1); // eslint-disable-next-line prefer-rest-params\n\n    validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n\n    if (arguments.length === 1) {\n      validateDocumentSnapshot('documentOrName', documentOrName);\n      this.addBundledDocument(documentOrName);\n    } else {\n      validate_1.validateString('documentOrName', documentOrName);\n      validateQuerySnapshot('querySnapshot', querySnapshot);\n      this.addNamedQuery(documentOrName, querySnapshot);\n    }\n\n    return this;\n  }\n\n  addBundledDocument(snap, queryName) {\n    const originalDocument = this.documents.get(snap.id);\n    const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries; // Update with document built from `snap` because it is newer.\n\n    if (!originalDocument || timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n      const docProto = snap.toDocumentProto();\n      this.documents.set(snap.id, {\n        document: snap.exists ? docProto : undefined,\n        metadata: {\n          name: docProto.name,\n          readTime: snap.readTime.toProto().timestampValue,\n          exists: snap.exists\n        }\n      });\n    } // Update `queries` to include both original and `queryName`.\n\n\n    const newDocument = this.documents.get(snap.id);\n    newDocument.metadata.queries = originalQueries || [];\n\n    if (queryName) {\n      newDocument.metadata.queries.push(queryName);\n    }\n\n    if (snap.readTime > this.latestReadTime) {\n      this.latestReadTime = snap.readTime;\n    }\n  }\n\n  addNamedQuery(name, querySnap) {\n    if (this.namedQueries.has(name)) {\n      throw new Error(`Query name conflict: ${name} has already been added.`);\n    }\n\n    this.namedQueries.set(name, {\n      name,\n      bundledQuery: querySnap.query._toBundledQuery(),\n      readTime: querySnap.readTime.toProto().timestampValue\n    });\n\n    for (const snap of querySnap.docs) {\n      this.addBundledDocument(snap, name);\n    }\n\n    if (querySnap.readTime > this.latestReadTime) {\n      this.latestReadTime = querySnap.readTime;\n    }\n  }\n  /**\r\n   * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\r\n   * of the element.\r\n   * @private\r\n   */\n\n\n  elementToLengthPrefixedBuffer(bundleElement) {\n    const buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\n    const lengthBuffer = Buffer.from(buffer.length.toString());\n    return Buffer.concat([lengthBuffer, buffer]);\n  }\n\n  build() {\n    let bundleBuffer = Buffer.alloc(0);\n\n    for (const namedQuery of this.namedQueries.values()) {\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        namedQuery\n      })]);\n    }\n\n    for (const bundledDocument of this.documents.values()) {\n      const documentMetadata = bundledDocument.metadata;\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        documentMetadata\n      })]); // Write to the bundle if document exists.\n\n      const document = bundledDocument.document;\n\n      if (document) {\n        bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n          document\n        })]);\n      }\n    }\n\n    const metadata = {\n      id: this.bundleId,\n      createTime: this.latestReadTime.toProto().timestampValue,\n      version: BUNDLE_VERSION,\n      totalDocuments: this.documents.size,\n      totalBytes: bundleBuffer.length\n    }; // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n\n    bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n      metadata\n    }), bundleBuffer]);\n    return bundleBuffer;\n  }\n\n}\n\nexports.BundleBuilder = BundleBuilder;\n/**\r\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\r\n * @private\r\n */\n\nclass BundledDocument {\n  constructor(metadata, document) {\n    this.metadata = metadata;\n    this.document = document;\n  }\n\n}\n/**\r\n * Validates that 'value' is DocumentSnapshot.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n */\n\n\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n  }\n}\n/**\r\n * Validates that 'value' is QuerySnapshot.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n */\n\n\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof reference_1.QuerySnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/bundle.js"],"names":["Object","defineProperty","exports","value","document_1","require","reference_1","timestamp_1","validate_1","BUNDLE_VERSION","BundleBuilder","constructor","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","add","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","queryName","originalDocument","get","id","originalQueries","metadata","queries","fromProto","readTime","docProto","toDocumentProto","set","document","exists","undefined","name","toProto","timestampValue","newDocument","push","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","elementToLengthPrefixedBuffer","bundleElement","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","build","bundleBuffer","alloc","namedQuery","values","bundledDocument","documentMetadata","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2020 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     https://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst document_1 = require(\"./document\");\r\nconst reference_1 = require(\"./reference\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\nconst validate_1 = require(\"./validate\");\r\nconst BUNDLE_VERSION = 1;\r\n/**\r\n * Builds a Firestore data bundle with results from the given document and query snapshots.\r\n */\r\nclass BundleBuilder {\r\n    constructor(bundleId) {\r\n        this.bundleId = bundleId;\r\n        // Resulting documents for the bundle, keyed by full document path.\r\n        this.documents = new Map();\r\n        // Named queries saved in the bundle, keyed by query name.\r\n        this.namedQueries = new Map();\r\n        // The latest read time among all bundled documents and queries.\r\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\r\n    }\r\n    /**\r\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\r\n     * Both the documents data and the query read time will be included in the bundle.\r\n     *\r\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\r\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\r\n     * @returns {BundleBuilder} This instance.\r\n     *\r\n     * @example\r\n     * const bundle = firestore.bundle('data-bundle');\r\n     * const docSnapshot = await firestore.doc('abc/123').get();\r\n     * const querySnapshot = await firestore.collection('coll').get();\r\n     *\r\n     * const bundleBuffer = bundle.add(docSnapshot); // Add a document\r\n     *                            .add('coll-query', querySnapshot) // Add a named query.\r\n     *                            .build()\r\n     * // Save `bundleBuffer` to CDN or stream it to clients.\r\n     */\r\n    add(documentOrName, querySnapshot) {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1);\r\n        // eslint-disable-next-line prefer-rest-params\r\n        validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\r\n        if (arguments.length === 1) {\r\n            validateDocumentSnapshot('documentOrName', documentOrName);\r\n            this.addBundledDocument(documentOrName);\r\n        }\r\n        else {\r\n            validate_1.validateString('documentOrName', documentOrName);\r\n            validateQuerySnapshot('querySnapshot', querySnapshot);\r\n            this.addNamedQuery(documentOrName, querySnapshot);\r\n        }\r\n        return this;\r\n    }\r\n    addBundledDocument(snap, queryName) {\r\n        const originalDocument = this.documents.get(snap.id);\r\n        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;\r\n        // Update with document built from `snap` because it is newer.\r\n        if (!originalDocument ||\r\n            timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\r\n            const docProto = snap.toDocumentProto();\r\n            this.documents.set(snap.id, {\r\n                document: snap.exists ? docProto : undefined,\r\n                metadata: {\r\n                    name: docProto.name,\r\n                    readTime: snap.readTime.toProto().timestampValue,\r\n                    exists: snap.exists,\r\n                },\r\n            });\r\n        }\r\n        // Update `queries` to include both original and `queryName`.\r\n        const newDocument = this.documents.get(snap.id);\r\n        newDocument.metadata.queries = originalQueries || [];\r\n        if (queryName) {\r\n            newDocument.metadata.queries.push(queryName);\r\n        }\r\n        if (snap.readTime > this.latestReadTime) {\r\n            this.latestReadTime = snap.readTime;\r\n        }\r\n    }\r\n    addNamedQuery(name, querySnap) {\r\n        if (this.namedQueries.has(name)) {\r\n            throw new Error(`Query name conflict: ${name} has already been added.`);\r\n        }\r\n        this.namedQueries.set(name, {\r\n            name,\r\n            bundledQuery: querySnap.query._toBundledQuery(),\r\n            readTime: querySnap.readTime.toProto().timestampValue,\r\n        });\r\n        for (const snap of querySnap.docs) {\r\n            this.addBundledDocument(snap, name);\r\n        }\r\n        if (querySnap.readTime > this.latestReadTime) {\r\n            this.latestReadTime = querySnap.readTime;\r\n        }\r\n    }\r\n    /**\r\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\r\n     * of the element.\r\n     * @private\r\n     */\r\n    elementToLengthPrefixedBuffer(bundleElement) {\r\n        const buffer = Buffer.from(JSON.stringify(bundleElement), 'utf-8');\r\n        const lengthBuffer = Buffer.from(buffer.length.toString());\r\n        return Buffer.concat([lengthBuffer, buffer]);\r\n    }\r\n    build() {\r\n        let bundleBuffer = Buffer.alloc(0);\r\n        for (const namedQuery of this.namedQueries.values()) {\r\n            bundleBuffer = Buffer.concat([\r\n                bundleBuffer,\r\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\r\n            ]);\r\n        }\r\n        for (const bundledDocument of this.documents.values()) {\r\n            const documentMetadata = bundledDocument.metadata;\r\n            bundleBuffer = Buffer.concat([\r\n                bundleBuffer,\r\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\r\n            ]);\r\n            // Write to the bundle if document exists.\r\n            const document = bundledDocument.document;\r\n            if (document) {\r\n                bundleBuffer = Buffer.concat([\r\n                    bundleBuffer,\r\n                    this.elementToLengthPrefixedBuffer({ document }),\r\n                ]);\r\n            }\r\n        }\r\n        const metadata = {\r\n            id: this.bundleId,\r\n            createTime: this.latestReadTime.toProto().timestampValue,\r\n            version: BUNDLE_VERSION,\r\n            totalDocuments: this.documents.size,\r\n            totalBytes: bundleBuffer.length,\r\n        };\r\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\r\n        bundleBuffer = Buffer.concat([\r\n            this.elementToLengthPrefixedBuffer({ metadata }),\r\n            bundleBuffer,\r\n        ]);\r\n        return bundleBuffer;\r\n    }\r\n}\r\nexports.BundleBuilder = BundleBuilder;\r\n/**\r\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\r\n * @private\r\n */\r\nclass BundledDocument {\r\n    constructor(metadata, document) {\r\n        this.metadata = metadata;\r\n        this.document = document;\r\n    }\r\n}\r\n/**\r\n * Validates that 'value' is DocumentSnapshot.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n */\r\nfunction validateDocumentSnapshot(arg, value) {\r\n    if (!(value instanceof document_1.DocumentSnapshot)) {\r\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\r\n    }\r\n}\r\n/**\r\n * Validates that 'value' is QuerySnapshot.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n */\r\nfunction validateQuerySnapshot(arg, value) {\r\n    if (!(value instanceof reference_1.QuerySnapshot)) {\r\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\r\n    }\r\n}\r\n//# sourceMappingURL=bundle.js.map"]},"metadata":{},"sourceType":"script"}