{"ast":null,"code":"'use strict';\n\nconst stringify = require('./stringify');\n/**\r\n * Constants\r\n */\n\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n/**\r\n * parse\r\n */\n\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n  /**\r\n   * Helpers\r\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\r\n     * Invalid chars\r\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\r\n     * Escaped chars\r\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\r\n     * Right square bracket (literal): ']'\r\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\r\n     * Left square bracket: '['\r\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\r\n     * Parentheses\r\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\r\n     * Quotes: '|\"|`\r\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\r\n     * Left curly brace: '{'\r\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\r\n     * Right curly brace: '}'\r\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\r\n     * Comma: ','\r\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\r\n     * Dot: '.'\r\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\r\n     * Text\r\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/braces/lib/parse.js"],"names":["stringify","require","MAX_LENGTH","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_COMMA","CHAR_DOT","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_LEFT_CURLY_BRACE","CHAR_RIGHT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_DOUBLE_QUOTE","CHAR_SINGLE_QUOTE","CHAR_NO_BREAK_SPACE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","parse","input","options","TypeError","opts","max","maxLength","Math","min","length","SyntaxError","ast","type","nodes","stack","block","prev","brackets","index","depth","value","memo","advance","push","node","parent","keepEscaping","closed","next","pop","open","keepQuotes","dollar","slice","brace","close","commas","ranges","shift","siblings","range","invalid","args","before","forEach","isOpen","isClose","indexOf","splice","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,aAAD,CAAzB;AAEA;AACA;AACA;;;AAEA,MAAM;AACJC,EAAAA,UADI;AAEJC,EAAAA,cAFI;;AAEY;AAChBC,EAAAA,aAHI;;AAGW;AACfC,EAAAA,UAJI;;AAIQ;AACZC,EAAAA,QALI;;AAKM;AACVC,EAAAA,qBANI;;AAMmB;AACvBC,EAAAA,sBAPI;;AAOoB;AACxBC,EAAAA,qBARI;;AAQmB;AACvBC,EAAAA,sBATI;;AASoB;AACxBC,EAAAA,wBAVI;;AAUsB;AAC1BC,EAAAA,yBAXI;;AAWuB;AAC3BC,EAAAA,iBAZI;;AAYe;AACnBC,EAAAA,iBAbI;;AAae;AACnBC,EAAAA,mBAdI;AAeJC,EAAAA;AAfI,IAgBFf,OAAO,CAAC,aAAD,CAhBX;AAkBA;AACA;AACA;;;AAEA,MAAMgB,KAAK,GAAG,CAACC,KAAD,EAAQC,OAAO,GAAG,EAAlB,KAAyB;AACrC,MAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAIE,SAAJ,CAAc,mBAAd,CAAN;AACD;;AAED,MAAIC,IAAI,GAAGF,OAAO,IAAI,EAAtB;AACA,MAAIG,GAAG,GAAG,OAAOD,IAAI,CAACE,SAAZ,KAA0B,QAA1B,GAAqCC,IAAI,CAACC,GAAL,CAASvB,UAAT,EAAqBmB,IAAI,CAACE,SAA1B,CAArC,GAA4ErB,UAAtF;;AACA,MAAIgB,KAAK,CAACQ,MAAN,GAAeJ,GAAnB,EAAwB;AACtB,UAAM,IAAIK,WAAJ,CAAiB,iBAAgBT,KAAK,CAACQ,MAAO,8BAA6BJ,GAAI,GAA/E,CAAN;AACD;;AAED,MAAIM,GAAG,GAAG;AAAEC,IAAAA,IAAI,EAAE,MAAR;AAAgBX,IAAAA,KAAhB;AAAuBY,IAAAA,KAAK,EAAE;AAA9B,GAAV;AACA,MAAIC,KAAK,GAAG,CAACH,GAAD,CAAZ;AACA,MAAII,KAAK,GAAGJ,GAAZ;AACA,MAAIK,IAAI,GAAGL,GAAX;AACA,MAAIM,QAAQ,GAAG,CAAf;AACA,MAAIR,MAAM,GAAGR,KAAK,CAACQ,MAAnB;AACA,MAAIS,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAJ;AACA,MAAIC,IAAI,GAAG,EAAX;AAEA;AACF;AACA;;AAEE,QAAMC,OAAO,GAAG,MAAMrB,KAAK,CAACiB,KAAK,EAAN,CAA3B;;AACA,QAAMK,IAAI,GAAGC,IAAI,IAAI;AACnB,QAAIA,IAAI,CAACZ,IAAL,KAAc,MAAd,IAAwBI,IAAI,CAACJ,IAAL,KAAc,KAA1C,EAAiD;AAC/CI,MAAAA,IAAI,CAACJ,IAAL,GAAY,MAAZ;AACD;;AAED,QAAII,IAAI,IAAIA,IAAI,CAACJ,IAAL,KAAc,MAAtB,IAAgCY,IAAI,CAACZ,IAAL,KAAc,MAAlD,EAA0D;AACxDI,MAAAA,IAAI,CAACI,KAAL,IAAcI,IAAI,CAACJ,KAAnB;AACA;AACD;;AAEDL,IAAAA,KAAK,CAACF,KAAN,CAAYU,IAAZ,CAAiBC,IAAjB;AACAA,IAAAA,IAAI,CAACC,MAAL,GAAcV,KAAd;AACAS,IAAAA,IAAI,CAACR,IAAL,GAAYA,IAAZ;AACAA,IAAAA,IAAI,GAAGQ,IAAP;AACA,WAAOA,IAAP;AACD,GAfD;;AAiBAD,EAAAA,IAAI,CAAC;AAAEX,IAAAA,IAAI,EAAE;AAAR,GAAD,CAAJ;;AAEA,SAAOM,KAAK,GAAGT,MAAf,EAAuB;AACrBM,IAAAA,KAAK,GAAGD,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAAb;AACAW,IAAAA,KAAK,GAAGE,OAAO,EAAf;AAEA;AACJ;AACA;;AAEI,QAAIF,KAAK,KAAKrB,6BAAV,IAA2CqB,KAAK,KAAKtB,mBAAzD,EAA8E;AAC5E;AACD;AAED;AACJ;AACA;;;AAEI,QAAIsB,KAAK,KAAKlC,cAAd,EAA8B;AAC5BqC,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA,KAAK,EAAE,CAAClB,OAAO,CAACwB,YAAR,GAAuBN,KAAvB,GAA+B,EAAhC,IAAsCE,OAAO;AAApE,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIF,KAAK,KAAKzB,yBAAd,EAAyC;AACvC4B,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA,KAAK,EAAE,OAAOA;AAA9B,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIA,KAAK,KAAK1B,wBAAd,EAAwC;AACtCuB,MAAAA,QAAQ;AAER,UAAIU,MAAM,GAAG,IAAb;AACA,UAAIC,IAAJ;;AAEA,aAAOV,KAAK,GAAGT,MAAR,KAAmBmB,IAAI,GAAGN,OAAO,EAAjC,CAAP,EAA6C;AAC3CF,QAAAA,KAAK,IAAIQ,IAAT;;AAEA,YAAIA,IAAI,KAAKlC,wBAAb,EAAuC;AACrCuB,UAAAA,QAAQ;AACR;AACD;;AAED,YAAIW,IAAI,KAAK1C,cAAb,EAA6B;AAC3BkC,UAAAA,KAAK,IAAIE,OAAO,EAAhB;AACA;AACD;;AAED,YAAIM,IAAI,KAAKjC,yBAAb,EAAwC;AACtCsB,UAAAA,QAAQ;;AAER,cAAIA,QAAQ,KAAK,CAAjB,EAAoB;AAClB;AACD;AACF;AACF;;AAEDM,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA;AAAhB,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIA,KAAK,KAAK9B,qBAAd,EAAqC;AACnCyB,MAAAA,KAAK,GAAGQ,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,OAAR;AAAiBC,QAAAA,KAAK,EAAE;AAAxB,OAAD,CAAZ;AACAC,MAAAA,KAAK,CAACS,IAAN,CAAWR,KAAX;AACAQ,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA;AAAhB,OAAD,CAAJ;AACA;AACD;;AAED,QAAIA,KAAK,KAAK7B,sBAAd,EAAsC;AACpC,UAAIwB,KAAK,CAACH,IAAN,KAAe,OAAnB,EAA4B;AAC1BW,QAAAA,IAAI,CAAC;AAAEX,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA;AAAhB,SAAD,CAAJ;AACA;AACD;;AACDL,MAAAA,KAAK,GAAGD,KAAK,CAACe,GAAN,EAAR;AACAN,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA;AAAhB,OAAD,CAAJ;AACAL,MAAAA,KAAK,GAAGD,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAAb;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIW,KAAK,KAAKxB,iBAAV,IAA+BwB,KAAK,KAAKvB,iBAAzC,IAA8DuB,KAAK,KAAKjC,aAA5E,EAA2F;AACzF,UAAI2C,IAAI,GAAGV,KAAX;AACA,UAAIQ,IAAJ;;AAEA,UAAI1B,OAAO,CAAC6B,UAAR,KAAuB,IAA3B,EAAiC;AAC/BX,QAAAA,KAAK,GAAG,EAAR;AACD;;AAED,aAAOF,KAAK,GAAGT,MAAR,KAAmBmB,IAAI,GAAGN,OAAO,EAAjC,CAAP,EAA6C;AAC3C,YAAIM,IAAI,KAAK1C,cAAb,EAA6B;AAC3BkC,UAAAA,KAAK,IAAIQ,IAAI,GAAGN,OAAO,EAAvB;AACA;AACD;;AAED,YAAIM,IAAI,KAAKE,IAAb,EAAmB;AACjB,cAAI5B,OAAO,CAAC6B,UAAR,KAAuB,IAA3B,EAAiCX,KAAK,IAAIQ,IAAT;AACjC;AACD;;AAEDR,QAAAA,KAAK,IAAIQ,IAAT;AACD;;AAEDL,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA;AAAhB,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIA,KAAK,KAAK5B,qBAAd,EAAqC;AACnC2B,MAAAA,KAAK;AAEL,UAAIa,MAAM,GAAGhB,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACI,KAAL,CAAWa,KAAX,CAAiB,CAAC,CAAlB,MAAyB,GAAvC,IAA8ClB,KAAK,CAACiB,MAAN,KAAiB,IAA5E;AACA,UAAIE,KAAK,GAAG;AACVtB,QAAAA,IAAI,EAAE,OADI;AAEVkB,QAAAA,IAAI,EAAE,IAFI;AAGVK,QAAAA,KAAK,EAAE,KAHG;AAIVH,QAAAA,MAJU;AAKVb,QAAAA,KALU;AAMViB,QAAAA,MAAM,EAAE,CANE;AAOVC,QAAAA,MAAM,EAAE,CAPE;AAQVxB,QAAAA,KAAK,EAAE;AARG,OAAZ;AAWAE,MAAAA,KAAK,GAAGQ,IAAI,CAACW,KAAD,CAAZ;AACApB,MAAAA,KAAK,CAACS,IAAN,CAAWR,KAAX;AACAQ,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,MAAR;AAAgBQ,QAAAA;AAAhB,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIA,KAAK,KAAK3B,sBAAd,EAAsC;AACpC,UAAIsB,KAAK,CAACH,IAAN,KAAe,OAAnB,EAA4B;AAC1BW,QAAAA,IAAI,CAAC;AAAEX,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA;AAAhB,SAAD,CAAJ;AACA;AACD;;AAED,UAAIR,IAAI,GAAG,OAAX;AACAG,MAAAA,KAAK,GAAGD,KAAK,CAACe,GAAN,EAAR;AACAd,MAAAA,KAAK,CAACoB,KAAN,GAAc,IAAd;AAEAZ,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAF;AAAQQ,QAAAA;AAAR,OAAD,CAAJ;AACAD,MAAAA,KAAK;AAELJ,MAAAA,KAAK,GAAGD,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAAb;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIW,KAAK,KAAKhC,UAAV,IAAwB+B,KAAK,GAAG,CAApC,EAAuC;AACrC,UAAIJ,KAAK,CAACsB,MAAN,GAAe,CAAnB,EAAsB;AACpBtB,QAAAA,KAAK,CAACsB,MAAN,GAAe,CAAf;AACA,YAAIP,IAAI,GAAGf,KAAK,CAACF,KAAN,CAAYyB,KAAZ,EAAX;AACAvB,QAAAA,KAAK,CAACF,KAAN,GAAc,CAACiB,IAAD,EAAO;AAAElB,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA,KAAK,EAAErC,SAAS,CAACgC,KAAD;AAAhC,SAAP,CAAd;AACD;;AAEDQ,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,OAAR;AAAiBQ,QAAAA;AAAjB,OAAD,CAAJ;AACAL,MAAAA,KAAK,CAACqB,MAAN;AACA;AACD;AAED;AACJ;AACA;;;AAEI,QAAIhB,KAAK,KAAK/B,QAAV,IAAsB8B,KAAK,GAAG,CAA9B,IAAmCJ,KAAK,CAACqB,MAAN,KAAiB,CAAxD,EAA2D;AACzD,UAAIG,QAAQ,GAAGxB,KAAK,CAACF,KAArB;;AAEA,UAAIM,KAAK,KAAK,CAAV,IAAeoB,QAAQ,CAAC9B,MAAT,KAAoB,CAAvC,EAA0C;AACxCc,QAAAA,IAAI,CAAC;AAAEX,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA;AAAhB,SAAD,CAAJ;AACA;AACD;;AAED,UAAIJ,IAAI,CAACJ,IAAL,KAAc,KAAlB,EAAyB;AACvBG,QAAAA,KAAK,CAACyB,KAAN,GAAc,EAAd;AACAxB,QAAAA,IAAI,CAACI,KAAL,IAAcA,KAAd;AACAJ,QAAAA,IAAI,CAACJ,IAAL,GAAY,OAAZ;;AAEA,YAAIG,KAAK,CAACF,KAAN,CAAYJ,MAAZ,KAAuB,CAAvB,IAA4BM,KAAK,CAACF,KAAN,CAAYJ,MAAZ,KAAuB,CAAvD,EAA0D;AACxDM,UAAAA,KAAK,CAAC0B,OAAN,GAAgB,IAAhB;AACA1B,UAAAA,KAAK,CAACsB,MAAN,GAAe,CAAf;AACArB,UAAAA,IAAI,CAACJ,IAAL,GAAY,MAAZ;AACA;AACD;;AAEDG,QAAAA,KAAK,CAACsB,MAAN;AACAtB,QAAAA,KAAK,CAAC2B,IAAN,GAAa,EAAb;AACA;AACD;;AAED,UAAI1B,IAAI,CAACJ,IAAL,KAAc,OAAlB,EAA2B;AACzB2B,QAAAA,QAAQ,CAACV,GAAT;AAEA,YAAIc,MAAM,GAAGJ,QAAQ,CAACA,QAAQ,CAAC9B,MAAT,GAAkB,CAAnB,CAArB;AACAkC,QAAAA,MAAM,CAACvB,KAAP,IAAgBJ,IAAI,CAACI,KAAL,GAAaA,KAA7B;AACAJ,QAAAA,IAAI,GAAG2B,MAAP;AACA5B,QAAAA,KAAK,CAACsB,MAAN;AACA;AACD;;AAEDd,MAAAA,IAAI,CAAC;AAAEX,QAAAA,IAAI,EAAE,KAAR;AAAeQ,QAAAA;AAAf,OAAD,CAAJ;AACA;AACD;AAED;AACJ;AACA;;;AAEIG,IAAAA,IAAI,CAAC;AAAEX,MAAAA,IAAI,EAAE,MAAR;AAAgBQ,MAAAA;AAAhB,KAAD,CAAJ;AACD,GAlRoC,CAoRrC;;;AACA,KAAG;AACDL,IAAAA,KAAK,GAAGD,KAAK,CAACe,GAAN,EAAR;;AAEA,QAAId,KAAK,CAACH,IAAN,KAAe,MAAnB,EAA2B;AACzBG,MAAAA,KAAK,CAACF,KAAN,CAAY+B,OAAZ,CAAoBpB,IAAI,IAAI;AAC1B,YAAI,CAACA,IAAI,CAACX,KAAV,EAAiB;AACf,cAAIW,IAAI,CAACZ,IAAL,KAAc,MAAlB,EAA0BY,IAAI,CAACqB,MAAL,GAAc,IAAd;AAC1B,cAAIrB,IAAI,CAACZ,IAAL,KAAc,OAAlB,EAA2BY,IAAI,CAACsB,OAAL,GAAe,IAAf;AAC3B,cAAI,CAACtB,IAAI,CAACX,KAAV,EAAiBW,IAAI,CAACZ,IAAL,GAAY,MAAZ;AACjBY,UAAAA,IAAI,CAACiB,OAAL,GAAe,IAAf;AACD;AACF,OAPD,EADyB,CAUzB;;AACA,UAAIhB,MAAM,GAAGX,KAAK,CAACA,KAAK,CAACL,MAAN,GAAe,CAAhB,CAAlB;AACA,UAAIS,KAAK,GAAGO,MAAM,CAACZ,KAAP,CAAakC,OAAb,CAAqBhC,KAArB,CAAZ,CAZyB,CAazB;;AACAU,MAAAA,MAAM,CAACZ,KAAP,CAAamC,MAAb,CAAoB9B,KAApB,EAA2B,CAA3B,EAA8B,GAAGH,KAAK,CAACF,KAAvC;AACD;AACF,GAnBD,QAmBSC,KAAK,CAACL,MAAN,GAAe,CAnBxB;;AAqBAc,EAAAA,IAAI,CAAC;AAAEX,IAAAA,IAAI,EAAE;AAAR,GAAD,CAAJ;AACA,SAAOD,GAAP;AACD,CA5SD;;AA8SAsC,MAAM,CAACC,OAAP,GAAiBlD,KAAjB","sourcesContent":["'use strict';\r\n\r\nconst stringify = require('./stringify');\r\n\r\n/**\r\n * Constants\r\n */\r\n\r\nconst {\r\n  MAX_LENGTH,\r\n  CHAR_BACKSLASH, /* \\ */\r\n  CHAR_BACKTICK, /* ` */\r\n  CHAR_COMMA, /* , */\r\n  CHAR_DOT, /* . */\r\n  CHAR_LEFT_PARENTHESES, /* ( */\r\n  CHAR_RIGHT_PARENTHESES, /* ) */\r\n  CHAR_LEFT_CURLY_BRACE, /* { */\r\n  CHAR_RIGHT_CURLY_BRACE, /* } */\r\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\r\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\r\n  CHAR_DOUBLE_QUOTE, /* \" */\r\n  CHAR_SINGLE_QUOTE, /* ' */\r\n  CHAR_NO_BREAK_SPACE,\r\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\r\n} = require('./constants');\r\n\r\n/**\r\n * parse\r\n */\r\n\r\nconst parse = (input, options = {}) => {\r\n  if (typeof input !== 'string') {\r\n    throw new TypeError('Expected a string');\r\n  }\r\n\r\n  let opts = options || {};\r\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n  if (input.length > max) {\r\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\r\n  }\r\n\r\n  let ast = { type: 'root', input, nodes: [] };\r\n  let stack = [ast];\r\n  let block = ast;\r\n  let prev = ast;\r\n  let brackets = 0;\r\n  let length = input.length;\r\n  let index = 0;\r\n  let depth = 0;\r\n  let value;\r\n  let memo = {};\r\n\r\n  /**\r\n   * Helpers\r\n   */\r\n\r\n  const advance = () => input[index++];\r\n  const push = node => {\r\n    if (node.type === 'text' && prev.type === 'dot') {\r\n      prev.type = 'text';\r\n    }\r\n\r\n    if (prev && prev.type === 'text' && node.type === 'text') {\r\n      prev.value += node.value;\r\n      return;\r\n    }\r\n\r\n    block.nodes.push(node);\r\n    node.parent = block;\r\n    node.prev = prev;\r\n    prev = node;\r\n    return node;\r\n  };\r\n\r\n  push({ type: 'bos' });\r\n\r\n  while (index < length) {\r\n    block = stack[stack.length - 1];\r\n    value = advance();\r\n\r\n    /**\r\n     * Invalid chars\r\n     */\r\n\r\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Escaped chars\r\n     */\r\n\r\n    if (value === CHAR_BACKSLASH) {\r\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Right square bracket (literal): ']'\r\n     */\r\n\r\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\r\n      push({ type: 'text', value: '\\\\' + value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Left square bracket: '['\r\n     */\r\n\r\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\r\n      brackets++;\r\n\r\n      let closed = true;\r\n      let next;\r\n\r\n      while (index < length && (next = advance())) {\r\n        value += next;\r\n\r\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\r\n          brackets++;\r\n          continue;\r\n        }\r\n\r\n        if (next === CHAR_BACKSLASH) {\r\n          value += advance();\r\n          continue;\r\n        }\r\n\r\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\r\n          brackets--;\r\n\r\n          if (brackets === 0) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Parentheses\r\n     */\r\n\r\n    if (value === CHAR_LEFT_PARENTHESES) {\r\n      block = push({ type: 'paren', nodes: [] });\r\n      stack.push(block);\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    if (value === CHAR_RIGHT_PARENTHESES) {\r\n      if (block.type !== 'paren') {\r\n        push({ type: 'text', value });\r\n        continue;\r\n      }\r\n      block = stack.pop();\r\n      push({ type: 'text', value });\r\n      block = stack[stack.length - 1];\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Quotes: '|\"|`\r\n     */\r\n\r\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\r\n      let open = value;\r\n      let next;\r\n\r\n      if (options.keepQuotes !== true) {\r\n        value = '';\r\n      }\r\n\r\n      while (index < length && (next = advance())) {\r\n        if (next === CHAR_BACKSLASH) {\r\n          value += next + advance();\r\n          continue;\r\n        }\r\n\r\n        if (next === open) {\r\n          if (options.keepQuotes === true) value += next;\r\n          break;\r\n        }\r\n\r\n        value += next;\r\n      }\r\n\r\n      push({ type: 'text', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Left curly brace: '{'\r\n     */\r\n\r\n    if (value === CHAR_LEFT_CURLY_BRACE) {\r\n      depth++;\r\n\r\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\r\n      let brace = {\r\n        type: 'brace',\r\n        open: true,\r\n        close: false,\r\n        dollar,\r\n        depth,\r\n        commas: 0,\r\n        ranges: 0,\r\n        nodes: []\r\n      };\r\n\r\n      block = push(brace);\r\n      stack.push(block);\r\n      push({ type: 'open', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Right curly brace: '}'\r\n     */\r\n\r\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\r\n      if (block.type !== 'brace') {\r\n        push({ type: 'text', value });\r\n        continue;\r\n      }\r\n\r\n      let type = 'close';\r\n      block = stack.pop();\r\n      block.close = true;\r\n\r\n      push({ type, value });\r\n      depth--;\r\n\r\n      block = stack[stack.length - 1];\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Comma: ','\r\n     */\r\n\r\n    if (value === CHAR_COMMA && depth > 0) {\r\n      if (block.ranges > 0) {\r\n        block.ranges = 0;\r\n        let open = block.nodes.shift();\r\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\r\n      }\r\n\r\n      push({ type: 'comma', value });\r\n      block.commas++;\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Dot: '.'\r\n     */\r\n\r\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\r\n      let siblings = block.nodes;\r\n\r\n      if (depth === 0 || siblings.length === 0) {\r\n        push({ type: 'text', value });\r\n        continue;\r\n      }\r\n\r\n      if (prev.type === 'dot') {\r\n        block.range = [];\r\n        prev.value += value;\r\n        prev.type = 'range';\r\n\r\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\r\n          block.invalid = true;\r\n          block.ranges = 0;\r\n          prev.type = 'text';\r\n          continue;\r\n        }\r\n\r\n        block.ranges++;\r\n        block.args = [];\r\n        continue;\r\n      }\r\n\r\n      if (prev.type === 'range') {\r\n        siblings.pop();\r\n\r\n        let before = siblings[siblings.length - 1];\r\n        before.value += prev.value + value;\r\n        prev = before;\r\n        block.ranges--;\r\n        continue;\r\n      }\r\n\r\n      push({ type: 'dot', value });\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * Text\r\n     */\r\n\r\n    push({ type: 'text', value });\r\n  }\r\n\r\n  // Mark imbalanced braces and brackets as invalid\r\n  do {\r\n    block = stack.pop();\r\n\r\n    if (block.type !== 'root') {\r\n      block.nodes.forEach(node => {\r\n        if (!node.nodes) {\r\n          if (node.type === 'open') node.isOpen = true;\r\n          if (node.type === 'close') node.isClose = true;\r\n          if (!node.nodes) node.type = 'text';\r\n          node.invalid = true;\r\n        }\r\n      });\r\n\r\n      // get the location of the block on parent.nodes (block's siblings)\r\n      let parent = stack[stack.length - 1];\r\n      let index = parent.nodes.indexOf(block);\r\n      // replace the (invalid) block with it's nodes\r\n      parent.nodes.splice(index, 1, ...block.nodes);\r\n    }\r\n  } while (stack.length > 0);\r\n\r\n  push({ type: 'eos' });\r\n  return ast;\r\n};\r\n\r\nmodule.exports = parse;\r\n"]},"metadata":{},"sourceType":"script"}