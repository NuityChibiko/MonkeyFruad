{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst dateFormat = require(\"date-and-time\");\n\nconst url = require(\"url\");\n\nconst util_1 = require(\"./util\");\n/*\r\n * Default signing version for getSignedUrl is 'v2'.\r\n */\n\n\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\r\n * @const {string}\r\n * @private\r\n */\n\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\n\nclass URLSigner {\n  constructor(authClient, bucket, file) {\n    this.bucket = bucket;\n    this.file = file;\n    this.authClient = authClient;\n  }\n\n  getSignedUrl(cfg) {\n    const expiresInSeconds = this.parseExpires(cfg.expires);\n    const method = cfg.method;\n    const accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\n\n    if (expiresInSeconds < accessibleAtInSeconds) {\n      throw new Error('An expiration date cannot be before accessible date.');\n    }\n\n    let customHost; // Default style is `path`.\n\n    const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n\n    if (cfg.cname) {\n      customHost = cfg.cname;\n    } else if (isVirtualHostedStyle) {\n      customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n    }\n\n    const secondsToMilliseconds = 1000;\n    const config = Object.assign({}, cfg, {\n      method,\n      expiration: expiresInSeconds,\n      accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\n      bucket: this.bucket.name,\n      file: this.file ? util_1.encodeURI(this.file.name, false) : undefined\n    });\n\n    if (customHost) {\n      config.cname = customHost;\n    }\n\n    const version = cfg.version || DEFAULT_SIGNING_VERSION;\n    let promise;\n\n    if (version === 'v2') {\n      promise = this.getSignedUrlV2(config);\n    } else if (version === 'v4') {\n      promise = this.getSignedUrlV4(config);\n    } else {\n      throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n    }\n\n    return promise.then(query => {\n      query = Object.assign(query, cfg.queryParams);\n      const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n      signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      signedUrl.search = util_1.qsStringify(query);\n      return signedUrl.href;\n    });\n  }\n\n  getSignedUrlV2(config) {\n    const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n    const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n    const blobToSign = [config.method, config.contentMd5 || '', config.contentType || '', config.expiration, canonicalHeadersString + resourcePath].join('\\n');\n\n    const sign = async () => {\n      const authClient = this.authClient;\n\n      try {\n        const signature = await authClient.sign(blobToSign);\n        const credentials = await authClient.getCredentials();\n        return {\n          GoogleAccessId: credentials.client_email,\n          Expires: config.expiration,\n          Signature: signature\n        };\n      } catch (err) {\n        const signingErr = new SigningError(err.message);\n        signingErr.stack = err.stack;\n        throw signingErr;\n      }\n    };\n\n    return sign();\n  }\n\n  getSignedUrlV4(config) {\n    config.accessibleAt = config.accessibleAt ? config.accessibleAt : new Date();\n    const millisecondsToSeconds = 1.0 / 1000.0;\n    const expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds; // v4 limit expiration to be 7 days maximum\n\n    if (expiresPeriodInSeconds > SEVEN_DAYS) {\n      throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n    }\n\n    const extensionHeaders = Object.assign({}, config.extensionHeaders);\n    const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n    extensionHeaders.host = fqdn.host;\n\n    if (config.contentMd5) {\n      extensionHeaders['content-md5'] = config.contentMd5;\n    }\n\n    if (config.contentType) {\n      extensionHeaders['content-type'] = config.contentType;\n    }\n\n    let contentSha256;\n    const sha256Header = extensionHeaders['x-goog-content-sha256'];\n\n    if (sha256Header) {\n      if (typeof sha256Header !== 'string' || !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n        throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n      }\n\n      contentSha256 = sha256Header;\n    }\n\n    const signedHeaders = Object.keys(extensionHeaders).map(header => header.toLowerCase()).sort().join(';');\n    const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n    const datestamp = dateFormat.format(config.accessibleAt, 'YYYYMMDD', true);\n    const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n\n    const sign = async () => {\n      const credentials = await this.authClient.getCredentials();\n      const credential = `${credentials.client_email}/${credentialScope}`;\n      const dateISO = dateFormat.format(config.accessibleAt ? config.accessibleAt : new Date(), 'YYYYMMDD[T]HHmmss[Z]', true);\n      const queryParams = {\n        'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n        'X-Goog-Credential': credential,\n        'X-Goog-Date': dateISO,\n        'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n        'X-Goog-SignedHeaders': signedHeaders,\n        ...(config.queryParams || {})\n      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n      const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n      const hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n      const blobToSign = ['GOOG4-RSA-SHA256', dateISO, credentialScope, hash].join('\\n');\n\n      try {\n        const signature = await this.authClient.sign(blobToSign);\n        const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n        const signedQuery = Object.assign({}, queryParams, {\n          'X-Goog-Signature': signatureHex\n        });\n        return signedQuery;\n      } catch (err) {\n        const signingErr = new SigningError(err.message);\n        signingErr.stack = err.stack;\n        throw signingErr;\n      }\n    };\n\n    return sign();\n  }\n  /**\r\n   * Create canonical headers for signing v4 url.\r\n   *\r\n   * The canonical headers for v4-signing a request demands header names are\r\n   * first lowercased, followed by sorting the header names.\r\n   * Then, construct the canonical headers part of the request:\r\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\r\n   *  ..\r\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\r\n   *\r\n   * @param headers\r\n   * @private\r\n   */\n\n\n  getCanonicalHeaders(headers) {\n    // Sort headers by their lowercased names\n    const sortedHeaders = util_1.objectEntries(headers) // Convert header names to lowercase\n    .map(([headerName, value]) => [headerName.toLowerCase(), value]).sort((a, b) => a[0].localeCompare(b[0]));\n    return sortedHeaders.filter(([, value]) => value !== undefined).map(([headerName, value]) => {\n      // - Convert Array (multi-valued header) into string, delimited by\n      //      ',' (no space).\n      // - Trim leading and trailing spaces.\n      // - Convert sequential (2+) spaces into a single space\n      const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n      return `${headerName}:${canonicalValue}\\n`;\n    }).join('');\n  }\n\n  getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n    return [method, path, query, headers, signedHeaders, contentSha256 || 'UNSIGNED-PAYLOAD'].join('\\n');\n  }\n\n  getCanonicalQueryParams(query) {\n    return util_1.objectEntries(query).map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)]).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([key, value]) => `${key}=${value}`).join('&');\n  }\n\n  getResourcePath(cname, bucket, file) {\n    if (cname) {\n      return '/' + (file || '');\n    } else if (file) {\n      return `/${bucket}/${file}`;\n    } else {\n      return `/${bucket}`;\n    }\n  }\n\n  parseExpires(expires, current = new Date()) {\n    const expiresInMSeconds = new Date(expires).valueOf();\n\n    if (isNaN(expiresInMSeconds)) {\n      throw new Error('The expiration date provided was invalid.');\n    }\n\n    if (expiresInMSeconds < current.valueOf()) {\n      throw new Error('An expiration date cannot be in the past.');\n    }\n\n    return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n  }\n\n  parseAccessibleAt(accessibleAt) {\n    const accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\n\n    if (isNaN(accessibleAtInMSeconds)) {\n      throw new Error('The accessible at date provided was invalid.');\n    }\n\n    return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\n  }\n\n}\n\nexports.URLSigner = URLSigner;\n/**\r\n * Custom error type for errors related to getting signed errors and policies.\r\n *\r\n * @private\r\n */\n\nclass SigningError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'SigningError';\n  }\n\n}\n\nexports.SigningError = SigningError;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/storage/build/src/signer.js"],"names":["Object","defineProperty","exports","value","SigningError","URLSigner","PATH_STYLED_HOST","crypto","require","dateFormat","url","util_1","DEFAULT_SIGNING_VERSION","SEVEN_DAYS","constructor","authClient","bucket","file","getSignedUrl","cfg","expiresInSeconds","parseExpires","expires","method","accessibleAtInSeconds","parseAccessibleAt","accessibleAt","Error","customHost","isVirtualHostedStyle","virtualHostedStyle","cname","name","secondsToMilliseconds","config","assign","expiration","Date","encodeURI","undefined","version","promise","getSignedUrlV2","getSignedUrlV4","then","query","queryParams","signedUrl","URL","pathname","getResourcePath","search","qsStringify","href","canonicalHeadersString","getCanonicalHeaders","extensionHeaders","resourcePath","blobToSign","contentMd5","contentType","join","sign","signature","credentials","getCredentials","GoogleAccessId","client_email","Expires","Signature","err","signingErr","message","stack","millisecondsToSeconds","expiresPeriodInSeconds","valueOf","fqdn","host","contentSha256","sha256Header","test","signedHeaders","keys","map","header","toLowerCase","sort","extensionHeadersString","datestamp","format","credentialScope","credential","dateISO","toString","canonicalQueryParams","getCanonicalQueryParams","canonicalRequest","getCanonicalRequest","hash","createHash","update","digest","signatureHex","Buffer","from","signedQuery","headers","sortedHeaders","objectEntries","headerName","a","b","localeCompare","filter","canonicalValue","trim","replace","path","key","current","expiresInMSeconds","isNaN","Math","round","accessibleAtInMSeconds","floor","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2020 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst dateFormat = require(\"date-and-time\");\r\nconst url = require(\"url\");\r\nconst util_1 = require(\"./util\");\r\n/*\r\n * Default signing version for getSignedUrl is 'v2'.\r\n */\r\nconst DEFAULT_SIGNING_VERSION = 'v2';\r\nconst SEVEN_DAYS = 604800;\r\n/**\r\n * @const {string}\r\n * @private\r\n */\r\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\r\nclass URLSigner {\r\n    constructor(authClient, bucket, file) {\r\n        this.bucket = bucket;\r\n        this.file = file;\r\n        this.authClient = authClient;\r\n    }\r\n    getSignedUrl(cfg) {\r\n        const expiresInSeconds = this.parseExpires(cfg.expires);\r\n        const method = cfg.method;\r\n        const accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\r\n        if (expiresInSeconds < accessibleAtInSeconds) {\r\n            throw new Error('An expiration date cannot be before accessible date.');\r\n        }\r\n        let customHost;\r\n        // Default style is `path`.\r\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\r\n        if (cfg.cname) {\r\n            customHost = cfg.cname;\r\n        }\r\n        else if (isVirtualHostedStyle) {\r\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\r\n        }\r\n        const secondsToMilliseconds = 1000;\r\n        const config = Object.assign({}, cfg, {\r\n            method,\r\n            expiration: expiresInSeconds,\r\n            accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\r\n            bucket: this.bucket.name,\r\n            file: this.file ? util_1.encodeURI(this.file.name, false) : undefined,\r\n        });\r\n        if (customHost) {\r\n            config.cname = customHost;\r\n        }\r\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\r\n        let promise;\r\n        if (version === 'v2') {\r\n            promise = this.getSignedUrlV2(config);\r\n        }\r\n        else if (version === 'v4') {\r\n            promise = this.getSignedUrlV4(config);\r\n        }\r\n        else {\r\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\r\n        }\r\n        return promise.then(query => {\r\n            query = Object.assign(query, cfg.queryParams);\r\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\r\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            signedUrl.search = util_1.qsStringify(query);\r\n            return signedUrl.href;\r\n        });\r\n    }\r\n    getSignedUrlV2(config) {\r\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\r\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\r\n        const blobToSign = [\r\n            config.method,\r\n            config.contentMd5 || '',\r\n            config.contentType || '',\r\n            config.expiration,\r\n            canonicalHeadersString + resourcePath,\r\n        ].join('\\n');\r\n        const sign = async () => {\r\n            const authClient = this.authClient;\r\n            try {\r\n                const signature = await authClient.sign(blobToSign);\r\n                const credentials = await authClient.getCredentials();\r\n                return {\r\n                    GoogleAccessId: credentials.client_email,\r\n                    Expires: config.expiration,\r\n                    Signature: signature,\r\n                };\r\n            }\r\n            catch (err) {\r\n                const signingErr = new SigningError(err.message);\r\n                signingErr.stack = err.stack;\r\n                throw signingErr;\r\n            }\r\n        };\r\n        return sign();\r\n    }\r\n    getSignedUrlV4(config) {\r\n        config.accessibleAt = config.accessibleAt\r\n            ? config.accessibleAt\r\n            : new Date();\r\n        const millisecondsToSeconds = 1.0 / 1000.0;\r\n        const expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds;\r\n        // v4 limit expiration to be 7 days maximum\r\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\r\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\r\n        }\r\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\r\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\r\n        extensionHeaders.host = fqdn.host;\r\n        if (config.contentMd5) {\r\n            extensionHeaders['content-md5'] = config.contentMd5;\r\n        }\r\n        if (config.contentType) {\r\n            extensionHeaders['content-type'] = config.contentType;\r\n        }\r\n        let contentSha256;\r\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\r\n        if (sha256Header) {\r\n            if (typeof sha256Header !== 'string' ||\r\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\r\n                throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\r\n            }\r\n            contentSha256 = sha256Header;\r\n        }\r\n        const signedHeaders = Object.keys(extensionHeaders)\r\n            .map(header => header.toLowerCase())\r\n            .sort()\r\n            .join(';');\r\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\r\n        const datestamp = dateFormat.format(config.accessibleAt, 'YYYYMMDD', true);\r\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\r\n        const sign = async () => {\r\n            const credentials = await this.authClient.getCredentials();\r\n            const credential = `${credentials.client_email}/${credentialScope}`;\r\n            const dateISO = dateFormat.format(config.accessibleAt ? config.accessibleAt : new Date(), 'YYYYMMDD[T]HHmmss[Z]', true);\r\n            const queryParams = {\r\n                'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\r\n                'X-Goog-Credential': credential,\r\n                'X-Goog-Date': dateISO,\r\n                'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\r\n                'X-Goog-SignedHeaders': signedHeaders,\r\n                ...(config.queryParams || {}),\r\n            };\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\r\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\r\n            const hash = crypto\r\n                .createHash('sha256')\r\n                .update(canonicalRequest)\r\n                .digest('hex');\r\n            const blobToSign = [\r\n                'GOOG4-RSA-SHA256',\r\n                dateISO,\r\n                credentialScope,\r\n                hash,\r\n            ].join('\\n');\r\n            try {\r\n                const signature = await this.authClient.sign(blobToSign);\r\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\r\n                const signedQuery = Object.assign({}, queryParams, {\r\n                    'X-Goog-Signature': signatureHex,\r\n                });\r\n                return signedQuery;\r\n            }\r\n            catch (err) {\r\n                const signingErr = new SigningError(err.message);\r\n                signingErr.stack = err.stack;\r\n                throw signingErr;\r\n            }\r\n        };\r\n        return sign();\r\n    }\r\n    /**\r\n     * Create canonical headers for signing v4 url.\r\n     *\r\n     * The canonical headers for v4-signing a request demands header names are\r\n     * first lowercased, followed by sorting the header names.\r\n     * Then, construct the canonical headers part of the request:\r\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\r\n     *  ..\r\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\r\n     *\r\n     * @param headers\r\n     * @private\r\n     */\r\n    getCanonicalHeaders(headers) {\r\n        // Sort headers by their lowercased names\r\n        const sortedHeaders = util_1.objectEntries(headers)\r\n            // Convert header names to lowercase\r\n            .map(([headerName, value]) => [\r\n            headerName.toLowerCase(),\r\n            value,\r\n        ])\r\n            .sort((a, b) => a[0].localeCompare(b[0]));\r\n        return sortedHeaders\r\n            .filter(([, value]) => value !== undefined)\r\n            .map(([headerName, value]) => {\r\n            // - Convert Array (multi-valued header) into string, delimited by\r\n            //      ',' (no space).\r\n            // - Trim leading and trailing spaces.\r\n            // - Convert sequential (2+) spaces into a single space\r\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\r\n            return `${headerName}:${canonicalValue}\\n`;\r\n        })\r\n            .join('');\r\n    }\r\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\r\n        return [\r\n            method,\r\n            path,\r\n            query,\r\n            headers,\r\n            signedHeaders,\r\n            contentSha256 || 'UNSIGNED-PAYLOAD',\r\n        ].join('\\n');\r\n    }\r\n    getCanonicalQueryParams(query) {\r\n        return util_1.objectEntries(query)\r\n            .map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)])\r\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\r\n            .map(([key, value]) => `${key}=${value}`)\r\n            .join('&');\r\n    }\r\n    getResourcePath(cname, bucket, file) {\r\n        if (cname) {\r\n            return '/' + (file || '');\r\n        }\r\n        else if (file) {\r\n            return `/${bucket}/${file}`;\r\n        }\r\n        else {\r\n            return `/${bucket}`;\r\n        }\r\n    }\r\n    parseExpires(expires, current = new Date()) {\r\n        const expiresInMSeconds = new Date(expires).valueOf();\r\n        if (isNaN(expiresInMSeconds)) {\r\n            throw new Error('The expiration date provided was invalid.');\r\n        }\r\n        if (expiresInMSeconds < current.valueOf()) {\r\n            throw new Error('An expiration date cannot be in the past.');\r\n        }\r\n        return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\r\n    }\r\n    parseAccessibleAt(accessibleAt) {\r\n        const accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\r\n        if (isNaN(accessibleAtInMSeconds)) {\r\n            throw new Error('The accessible at date provided was invalid.');\r\n        }\r\n        return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\r\n    }\r\n}\r\nexports.URLSigner = URLSigner;\r\n/**\r\n * Custom error type for errors related to getting signed errors and policies.\r\n *\r\n * @private\r\n */\r\nclass SigningError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'SigningError';\r\n    }\r\n}\r\nexports.SigningError = SigningError;\r\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}