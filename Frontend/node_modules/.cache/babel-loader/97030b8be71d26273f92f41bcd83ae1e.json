{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst logger_1 = require(\"./logger\");\n\nconst util_1 = require(\"./util\");\n\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\r\n * An auto-resizing pool that distributes concurrent operations over multiple\r\n * clients of type `T`.\r\n *\r\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\r\n * automatically initializes multiple clients if we issue more than 100\r\n * concurrent operations.\r\n *\r\n * @private\r\n */\n\nclass ClientPool {\n  /**\r\n   * @param concurrentOperationLimit The number of operations that each client\r\n   * can handle.\r\n   * @param maxIdleClients The maximum number of idle clients to keep before\r\n   * garbage collecting.\r\n   * @param clientFactory A factory function called as needed when new clients\r\n   * are required.\r\n   * @param clientDestructor A cleanup function that is called when a client is\r\n   * disposed of.\r\n   */\n  constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.maxIdleClients = maxIdleClients;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    /**\r\n     * Stores each active clients and how many operations it has outstanding.\r\n     */\n\n    this.activeClients = new Map();\n    /**\r\n     * A set of clients that have seen RST_STREAM errors (see\r\n     * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\r\n     * no longer be used.\r\n     */\n\n    this.failedClients = new Set();\n    /**\r\n     * Whether the Firestore instance has been terminated. Once terminated, the\r\n     * ClientPool can longer schedule new operations.\r\n     */\n\n    this.terminated = false;\n    /**\r\n     * Deferred promise that is resolved when there are no active operations on\r\n     * the client pool after terminate() has been called.\r\n     */\n\n    this.terminateDeferred = new util_1.Deferred();\n  }\n  /**\r\n   * Returns an already existing client if it has less than the maximum number\r\n   * of concurrent operations or initializes and returns a new client.\r\n   *\r\n   * @private\r\n   */\n\n\n  acquire(requestTag) {\n    let selectedClient = null;\n    let selectedClientRequestCount = -1;\n\n    for (const [client, requestCount] of this.activeClients) {\n      // Use the \"most-full\" client that can still accommodate the request\n      // in order to maximize the number of idle clients as operations start to\n      // complete.\n      if (!this.failedClients.has(client) && requestCount > selectedClientRequestCount && requestCount < this.concurrentOperationLimit) {\n        selectedClient = client;\n        selectedClientRequestCount = requestCount;\n      }\n    }\n\n    if (selectedClient) {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n    } else {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n      selectedClient = this.clientFactory();\n      selectedClientRequestCount = 0;\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n\n    this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n    return selectedClient;\n  }\n  /**\r\n   * Reduces the number of operations for the provided client, potentially\r\n   * removing it from the pool of active clients.\r\n   * @private\r\n   */\n\n\n  async release(requestTag, client) {\n    const requestCount = this.activeClients.get(client) || 0;\n    assert(requestCount > 0, 'No active requests');\n    this.activeClients.set(client, requestCount - 1);\n\n    if (this.terminated && this.opCount === 0) {\n      this.terminateDeferred.resolve();\n    }\n\n    if (this.shouldGarbageCollectClient(client)) {\n      this.activeClients.delete(client);\n      this.failedClients.delete(client);\n      await this.clientDestructor(client);\n      logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n    }\n  }\n  /**\r\n   * Given the current operation counts, determines if the given client should\r\n   * be garbage collected.\r\n   * @private\r\n   */\n\n\n  shouldGarbageCollectClient(client) {\n    // Don't garbage collect clients that have active requests.\n    if (this.activeClients.get(client) !== 0) {\n      return false;\n    } // Idle clients that have received RST_STREAM errors are always garbage\n    // collected.\n\n\n    if (this.failedClients.has(client)) {\n      return true;\n    } // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n    // more than 100 idle capacity with default settings) .\n\n\n    let idleCapacityCount = 0;\n\n    for (const [, count] of this.activeClients) {\n      idleCapacityCount += this.concurrentOperationLimit - count;\n    }\n\n    return idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit;\n  }\n  /**\r\n   * The number of currently registered clients.\r\n   *\r\n   * @return Number of currently registered clients.\r\n   * @private\r\n   */\n  // Visible for testing.\n\n\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\r\n   * The number of currently active operations.\r\n   *\r\n   * @return Number of currently active operations.\r\n   * @private\r\n   */\n  // Visible for testing.\n\n\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(count => activeOperationCount += count);\n    return activeOperationCount;\n  }\n  /**\r\n   * Runs the provided operation in this pool. This function may create an\r\n   * additional client if all existing clients already operate at the concurrent\r\n   * operation limit.\r\n   *\r\n   * @param requestTag A unique client-assigned identifier for this operation.\r\n   * @param op A callback function that returns a Promise. The client T will\r\n   * be returned to the pool when callback finishes.\r\n   * @return A Promise that resolves with the result of `op`.\r\n   * @private\r\n   */\n\n\n  run(requestTag, op) {\n    if (this.terminated) {\n      return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n    }\n\n    const client = this.acquire(requestTag);\n    return op(client).catch(async err => {\n      var _a;\n\n      if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n        // Once a client has seen a RST_STREAM error, the GRPC channel can\n        // no longer be used. We mark the client as failed, which ensures that\n        // we open a new GRPC channel for the next request.\n        this.failedClients.add(client);\n      }\n\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n\n  async terminate() {\n    this.terminated = true; // Wait for all pending operations to complete before terminating.\n\n    if (this.opCount > 0) {\n      logger_1.logger('ClientPool.terminate',\n      /* requestTag= */\n      null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n      await this.terminateDeferred.promise;\n    }\n\n    for (const [client] of this.activeClients) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n\n}\n\nexports.ClientPool = ClientPool;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/pool.js"],"names":["Object","defineProperty","exports","value","assert","require","logger_1","util_1","CLIENT_TERMINATED_ERROR_MSG","ClientPool","constructor","concurrentOperationLimit","maxIdleClients","clientFactory","clientDestructor","Promise","resolve","activeClients","Map","failedClients","Set","terminated","terminateDeferred","Deferred","acquire","requestTag","selectedClient","selectedClientRequestCount","client","requestCount","has","logger","set","release","get","opCount","shouldGarbageCollectClient","delete","idleCapacityCount","count","size","activeOperationCount","forEach","run","op","reject","Error","catch","err","_a","message","match","add","then","res","terminate","promise"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert = require(\"assert\");\r\nconst logger_1 = require(\"./logger\");\r\nconst util_1 = require(\"./util\");\r\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\r\n/**\r\n * An auto-resizing pool that distributes concurrent operations over multiple\r\n * clients of type `T`.\r\n *\r\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\r\n * automatically initializes multiple clients if we issue more than 100\r\n * concurrent operations.\r\n *\r\n * @private\r\n */\r\nclass ClientPool {\r\n    /**\r\n     * @param concurrentOperationLimit The number of operations that each client\r\n     * can handle.\r\n     * @param maxIdleClients The maximum number of idle clients to keep before\r\n     * garbage collecting.\r\n     * @param clientFactory A factory function called as needed when new clients\r\n     * are required.\r\n     * @param clientDestructor A cleanup function that is called when a client is\r\n     * disposed of.\r\n     */\r\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\r\n        this.concurrentOperationLimit = concurrentOperationLimit;\r\n        this.maxIdleClients = maxIdleClients;\r\n        this.clientFactory = clientFactory;\r\n        this.clientDestructor = clientDestructor;\r\n        /**\r\n         * Stores each active clients and how many operations it has outstanding.\r\n         */\r\n        this.activeClients = new Map();\r\n        /**\r\n         * A set of clients that have seen RST_STREAM errors (see\r\n         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\r\n         * no longer be used.\r\n         */\r\n        this.failedClients = new Set();\r\n        /**\r\n         * Whether the Firestore instance has been terminated. Once terminated, the\r\n         * ClientPool can longer schedule new operations.\r\n         */\r\n        this.terminated = false;\r\n        /**\r\n         * Deferred promise that is resolved when there are no active operations on\r\n         * the client pool after terminate() has been called.\r\n         */\r\n        this.terminateDeferred = new util_1.Deferred();\r\n    }\r\n    /**\r\n     * Returns an already existing client if it has less than the maximum number\r\n     * of concurrent operations or initializes and returns a new client.\r\n     *\r\n     * @private\r\n     */\r\n    acquire(requestTag) {\r\n        let selectedClient = null;\r\n        let selectedClientRequestCount = -1;\r\n        for (const [client, requestCount] of this.activeClients) {\r\n            // Use the \"most-full\" client that can still accommodate the request\r\n            // in order to maximize the number of idle clients as operations start to\r\n            // complete.\r\n            if (!this.failedClients.has(client) &&\r\n                requestCount > selectedClientRequestCount &&\r\n                requestCount < this.concurrentOperationLimit) {\r\n                selectedClient = client;\r\n                selectedClientRequestCount = requestCount;\r\n            }\r\n        }\r\n        if (selectedClient) {\r\n            logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\r\n        }\r\n        else {\r\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\r\n            selectedClient = this.clientFactory();\r\n            selectedClientRequestCount = 0;\r\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\r\n        }\r\n        this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\r\n        return selectedClient;\r\n    }\r\n    /**\r\n     * Reduces the number of operations for the provided client, potentially\r\n     * removing it from the pool of active clients.\r\n     * @private\r\n     */\r\n    async release(requestTag, client) {\r\n        const requestCount = this.activeClients.get(client) || 0;\r\n        assert(requestCount > 0, 'No active requests');\r\n        this.activeClients.set(client, requestCount - 1);\r\n        if (this.terminated && this.opCount === 0) {\r\n            this.terminateDeferred.resolve();\r\n        }\r\n        if (this.shouldGarbageCollectClient(client)) {\r\n            this.activeClients.delete(client);\r\n            this.failedClients.delete(client);\r\n            await this.clientDestructor(client);\r\n            logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\r\n        }\r\n    }\r\n    /**\r\n     * Given the current operation counts, determines if the given client should\r\n     * be garbage collected.\r\n     * @private\r\n     */\r\n    shouldGarbageCollectClient(client) {\r\n        // Don't garbage collect clients that have active requests.\r\n        if (this.activeClients.get(client) !== 0) {\r\n            return false;\r\n        }\r\n        // Idle clients that have received RST_STREAM errors are always garbage\r\n        // collected.\r\n        if (this.failedClients.has(client)) {\r\n            return true;\r\n        }\r\n        // Otherwise, only garbage collect if we have too much idle capacity (e.g.\r\n        // more than 100 idle capacity with default settings) .\r\n        let idleCapacityCount = 0;\r\n        for (const [, count] of this.activeClients) {\r\n            idleCapacityCount += this.concurrentOperationLimit - count;\r\n        }\r\n        return (idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit);\r\n    }\r\n    /**\r\n     * The number of currently registered clients.\r\n     *\r\n     * @return Number of currently registered clients.\r\n     * @private\r\n     */\r\n    // Visible for testing.\r\n    get size() {\r\n        return this.activeClients.size;\r\n    }\r\n    /**\r\n     * The number of currently active operations.\r\n     *\r\n     * @return Number of currently active operations.\r\n     * @private\r\n     */\r\n    // Visible for testing.\r\n    get opCount() {\r\n        let activeOperationCount = 0;\r\n        this.activeClients.forEach(count => (activeOperationCount += count));\r\n        return activeOperationCount;\r\n    }\r\n    /**\r\n     * Runs the provided operation in this pool. This function may create an\r\n     * additional client if all existing clients already operate at the concurrent\r\n     * operation limit.\r\n     *\r\n     * @param requestTag A unique client-assigned identifier for this operation.\r\n     * @param op A callback function that returns a Promise. The client T will\r\n     * be returned to the pool when callback finishes.\r\n     * @return A Promise that resolves with the result of `op`.\r\n     * @private\r\n     */\r\n    run(requestTag, op) {\r\n        if (this.terminated) {\r\n            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\r\n        }\r\n        const client = this.acquire(requestTag);\r\n        return op(client)\r\n            .catch(async (err) => {\r\n            var _a;\r\n            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\r\n                // Once a client has seen a RST_STREAM error, the GRPC channel can\r\n                // no longer be used. We mark the client as failed, which ensures that\r\n                // we open a new GRPC channel for the next request.\r\n                this.failedClients.add(client);\r\n            }\r\n            await this.release(requestTag, client);\r\n            return Promise.reject(err);\r\n        })\r\n            .then(async (res) => {\r\n            await this.release(requestTag, client);\r\n            return res;\r\n        });\r\n    }\r\n    async terminate() {\r\n        this.terminated = true;\r\n        // Wait for all pending operations to complete before terminating.\r\n        if (this.opCount > 0) {\r\n            logger_1.logger('ClientPool.terminate', \r\n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\r\n            await this.terminateDeferred.promise;\r\n        }\r\n        for (const [client] of this.activeClients) {\r\n            this.activeClients.delete(client);\r\n            await this.clientDestructor(client);\r\n        }\r\n    }\r\n}\r\nexports.ClientPool = ClientPool;\r\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"script"}