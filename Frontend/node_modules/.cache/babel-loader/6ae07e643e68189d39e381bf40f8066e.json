{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OngoingCallPromise = exports.OngoingCall = void 0;\n\nconst status_1 = require(\"./status\");\n\nconst googleError_1 = require(\"./googleError\");\n\nclass OngoingCall {\n  /**\r\n   * OngoingCall manages callback, API calls, and cancellation\r\n   * of the API calls.\r\n   * @param {APICallback=} callback\r\n   *   The callback to be called asynchronously when the API call\r\n   *   finishes.\r\n   * @constructor\r\n   * @property {APICallback} callback\r\n   *   The callback function to be called.\r\n   * @private\r\n   */\n  constructor(callback) {\n    this.callback = callback;\n    this.completed = false;\n  }\n  /**\r\n   * Cancels the ongoing promise.\r\n   */\n\n\n  cancel() {\n    if (this.completed) {\n      return;\n    }\n\n    this.completed = true;\n\n    if (this.cancelFunc) {\n      this.cancelFunc();\n    } else {\n      const error = new googleError_1.GoogleError('cancelled');\n      error.code = status_1.Status.CANCELLED;\n      this.callback(error);\n    }\n  }\n  /**\r\n   * Call calls the specified function. Result will be used to fulfill\r\n   * the promise.\r\n   *\r\n   * @param {SimpleCallbackFunction} func\r\n   *   A function for an API call.\r\n   * @param {Object} argument\r\n   *   A request object.\r\n   */\n\n\n  call(func, argument) {\n    if (this.completed) {\n      return;\n    } // eslint-disable-next-line\n\n\n    const canceller = func(argument, (...args) => {\n      this.completed = true;\n      setImmediate(this.callback, ...args);\n    });\n\n    this.cancelFunc = () => canceller.cancel();\n  }\n\n}\n\nexports.OngoingCall = OngoingCall;\n\nclass OngoingCallPromise extends OngoingCall {\n  /**\r\n   * GaxPromise is GRPCCallbackWrapper, but it holds a promise when\r\n   * the API call finishes.\r\n   * @constructor\r\n   * @private\r\n   */\n  constructor() {\n    let resolveCallback;\n    let rejectCallback;\n\n    const callback = (err, response, next, rawResponse) => {\n      if (err) {\n        rejectCallback(err);\n      } else if (response !== undefined) {\n        resolveCallback([response, next || null, rawResponse || null]);\n      } else {\n        throw new googleError_1.GoogleError('Neither error nor response are defined');\n      }\n    };\n\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    super(callback);\n    this.promise = promise;\n\n    this.promise.cancel = () => {\n      this.cancel();\n    };\n  }\n\n}\n\nexports.OngoingCallPromise = OngoingCallPromise;","map":{"version":3,"sources":["../../src/call.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAEH,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAWA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,MAAa,WAAb,CAAwB;AAKtB;;;;;;;;;;AAUG;AACH,EAAA,WAAA,CAAY,QAAZ,EAAiC;AAC/B,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,SAAL,GAAiB,KAAjB;AACD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,QAAI,KAAK,SAAT,EAAoB;AAClB;AACD;;AACD,SAAK,SAAL,GAAiB,IAAjB;;AACA,QAAI,KAAK,UAAT,EAAqB;AACnB,WAAK,UAAL;AACD,KAFD,MAEO;AACL,YAAM,KAAK,GAAG,IAAI,aAAA,CAAA,WAAJ,CAAgB,WAAhB,CAAd;AACA,MAAA,KAAK,CAAC,IAAN,GAAa,QAAA,CAAA,MAAA,CAAO,SAApB;AACA,WAAK,QAAL,CAAe,KAAf;AACD;AACF;AAED;;;;;;;;AAQG;;;AACH,EAAA,IAAI,CAAC,IAAD,EAA+B,QAA/B,EAAoD;AACtD,QAAI,KAAK,SAAT,EAAoB;AAClB;AACD,KAHqD,CAItD;;;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,QAAD,EAAW,CAAC,GAAG,IAAJ,KAAmB;AAClD,WAAK,SAAL,GAAiB,IAAjB;AACA,MAAA,YAAY,CAAC,KAAK,QAAN,EAAiB,GAAG,IAApB,CAAZ;AACD,KAHqB,CAAtB;;AAIA,SAAK,UAAL,GAAkB,MAAM,SAAS,CAAC,MAAV,EAAxB;AACD;;AAzDqB;;AAAxB,OAAA,CAAA,WAAA,GAAA,WAAA;;AAgEA,MAAa,kBAAb,SAAwC,WAAxC,CAAmD;AAEjD;;;;;AAKG;AACH,EAAA,WAAA,GAAA;AACE,QAAI,eAAJ;AAGA,QAAI,cAAJ;;AACA,UAAM,QAAQ,GAAgB,CAC5B,GAD4B,EAE5B,QAF4B,EAG5B,IAH4B,EAI5B,WAJ4B,KAK1B;AACF,UAAI,GAAJ,EAAS;AACP,QAAA,cAAc,CAAC,GAAD,CAAd;AACD,OAFD,MAEO,IAAI,QAAQ,KAAK,SAAjB,EAA4B;AACjC,QAAA,eAAe,CAAC,CAAC,QAAD,EAAW,IAAI,IAAI,IAAnB,EAAyB,WAAW,IAAI,IAAxC,CAAD,CAAf;AACD,OAFM,MAEA;AACL,cAAM,IAAI,aAAA,CAAA,WAAJ,CAAgB,wCAAhB,CAAN;AACD;AACF,KAbD;;AAcA,UAAM,OAAO,GAAG,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC9C,MAAA,eAAe,GAAG,OAAlB;AACA,MAAA,cAAc,GAAG,MAAjB;AACD,KAHe,CAAhB;AAIA,UAAM,QAAN;AACA,SAAK,OAAL,GAAe,OAAf;;AACA,SAAK,OAAL,CAAa,MAAb,GAAsB,MAAK;AACzB,WAAK,MAAL;AACD,KAFD;AAGD;;AApCgD;;AAAnD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OngoingCallPromise = exports.OngoingCall = void 0;\r\nconst status_1 = require(\"./status\");\r\nconst googleError_1 = require(\"./googleError\");\r\nclass OngoingCall {\r\n    /**\r\n     * OngoingCall manages callback, API calls, and cancellation\r\n     * of the API calls.\r\n     * @param {APICallback=} callback\r\n     *   The callback to be called asynchronously when the API call\r\n     *   finishes.\r\n     * @constructor\r\n     * @property {APICallback} callback\r\n     *   The callback function to be called.\r\n     * @private\r\n     */\r\n    constructor(callback) {\r\n        this.callback = callback;\r\n        this.completed = false;\r\n    }\r\n    /**\r\n     * Cancels the ongoing promise.\r\n     */\r\n    cancel() {\r\n        if (this.completed) {\r\n            return;\r\n        }\r\n        this.completed = true;\r\n        if (this.cancelFunc) {\r\n            this.cancelFunc();\r\n        }\r\n        else {\r\n            const error = new googleError_1.GoogleError('cancelled');\r\n            error.code = status_1.Status.CANCELLED;\r\n            this.callback(error);\r\n        }\r\n    }\r\n    /**\r\n     * Call calls the specified function. Result will be used to fulfill\r\n     * the promise.\r\n     *\r\n     * @param {SimpleCallbackFunction} func\r\n     *   A function for an API call.\r\n     * @param {Object} argument\r\n     *   A request object.\r\n     */\r\n    call(func, argument) {\r\n        if (this.completed) {\r\n            return;\r\n        }\r\n        // eslint-disable-next-line\r\n        const canceller = func(argument, (...args) => {\r\n            this.completed = true;\r\n            setImmediate(this.callback, ...args);\r\n        });\r\n        this.cancelFunc = () => canceller.cancel();\r\n    }\r\n}\r\nexports.OngoingCall = OngoingCall;\r\nclass OngoingCallPromise extends OngoingCall {\r\n    /**\r\n     * GaxPromise is GRPCCallbackWrapper, but it holds a promise when\r\n     * the API call finishes.\r\n     * @constructor\r\n     * @private\r\n     */\r\n    constructor() {\r\n        let resolveCallback;\r\n        let rejectCallback;\r\n        const callback = (err, response, next, rawResponse) => {\r\n            if (err) {\r\n                rejectCallback(err);\r\n            }\r\n            else if (response !== undefined) {\r\n                resolveCallback([response, next || null, rawResponse || null]);\r\n            }\r\n            else {\r\n                throw new googleError_1.GoogleError('Neither error nor response are defined');\r\n            }\r\n        };\r\n        const promise = new Promise((resolve, reject) => {\r\n            resolveCallback = resolve;\r\n            rejectCallback = reject;\r\n        });\r\n        super(callback);\r\n        this.promise = promise;\r\n        this.promise.cancel = () => {\r\n            this.cancel();\r\n        };\r\n    }\r\n}\r\nexports.OngoingCallPromise = OngoingCallPromise;\r\n//# sourceMappingURL=call.js.map"]},"metadata":{},"sourceType":"script"}