{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"./validate\");\n/*!\r\n * Number of nanoseconds in a millisecond.\r\n *\r\n * @type {number}\r\n */\n\n\nconst MS_TO_NANOS = 1000000;\n/*!\r\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 0001-01-01T00:00:00Z.\r\n *\r\n * @type {number}\r\n */\n\nconst MIN_SECONDS = -62135596800;\n/*!\r\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @type {number}\r\n */\n\nconst MAX_SECONDS = 253402300799;\n/**\r\n * A Timestamp represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\r\n * Calendar which extends the Gregorian calendar backwards to year one. It is\r\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\r\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\r\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\r\n */\n\nclass Timestamp {\n  /**\r\n   * Creates a new timestamp.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\r\n   *\r\n   * @param {number} seconds The number of seconds of UTC time since Unix epoch\r\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n   * 9999-12-31T23:59:59Z inclusive.\r\n   * @param {number} nanoseconds The non-negative fractions of a second at\r\n   * nanosecond resolution. Negative second values with fractions must still\r\n   * have non-negative nanoseconds values that count forward in time. Must be\r\n   * from 0 to 999,999,999 inclusive.\r\n   */\n  constructor(seconds, nanoseconds) {\n    validate_1.validateInteger('seconds', seconds, {\n      minValue: MIN_SECONDS,\n      maxValue: MAX_SECONDS\n    });\n    validate_1.validateInteger('nanoseconds', nanoseconds, {\n      minValue: 0,\n      maxValue: 999999999\n    });\n    this._seconds = seconds;\n    this._nanoseconds = nanoseconds;\n  }\n  /**\r\n   * Creates a new timestamp with the current date, with millisecond precision.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ updateTime:Firestore.Timestamp.now() });\r\n   *\r\n   * @return {Timestamp} A new `Timestamp` representing the current date.\r\n   */\n\n\n  static now() {\n    return Timestamp.fromMillis(Date.now());\n  }\n  /**\r\n   * Creates a new timestamp from the given date.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\r\n   * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\r\n   *\r\n   * @param {Date} date The date to initialize the `Timestamp` from.\r\n   * @return {Timestamp} A new `Timestamp` representing the same point in time\r\n   * as the given date.\r\n   */\n\n\n  static fromDate(date) {\n    return Timestamp.fromMillis(date.getTime());\n  }\n  /**\r\n   * Creates a new timestamp from the given number of milliseconds.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\r\n   *\r\n   * @param {number} milliseconds Number of milliseconds since Unix epoch\r\n   * 1970-01-01T00:00:00Z.\r\n   * @return {Timestamp}  A new `Timestamp` representing the same point in time\r\n   * as the given number of milliseconds.\r\n   */\n\n\n  static fromMillis(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = (milliseconds - seconds * 1000) * MS_TO_NANOS;\n    return new Timestamp(seconds, nanos);\n  }\n  /**\r\n   * Generates a `Timestamp` object from a Timestamp proto.\r\n   *\r\n   * @private\r\n   * @param {Object} timestamp The `Timestamp` Protobuf object.\r\n   */\n\n\n  static fromProto(timestamp) {\n    return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\n  }\n  /**\r\n   * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let updated = snap.updateTime;\r\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n   * });\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  get seconds() {\n    return this._seconds;\n  }\n  /**\r\n   * The non-negative fractions of a second at nanosecond resolution.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let updated = snap.updateTime;\r\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n   * });\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  get nanoseconds() {\n    return this._nanoseconds;\n  }\n  /**\r\n   * Returns a new `Date` corresponding to this timestamp. This may lose\r\n   * precision.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\r\n   * });\r\n   *\r\n   * @return {Date} JavaScript `Date` object representing the same point in time\r\n   * as this `Timestamp`, with millisecond precision.\r\n   */\n\n\n  toDate() {\n    return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n  }\n  /**\r\n   * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   let startTime = snap.get('startTime');\r\n   *   let endTime = snap.get('endTime');\r\n   *   console.log(`Duration: ${endTime - startTime}`);\r\n   * });\r\n   *\r\n   * @return {number} The point in time corresponding to this timestamp,\r\n   * represented as the number of milliseconds since Unix epoch\r\n   * 1970-01-01T00:00:00Z.\r\n   */\n\n\n  toMillis() {\n    return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n  }\n  /**\r\n   * Returns 'true' if this `Timestamp` is equal to the provided one.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(snap => {\r\n   *   if (snap.createTime.isEqual(snap.updateTime)) {\r\n   *     console.log('Document is in its initial state.');\r\n   *   }\r\n   * });\r\n   *\r\n   * @param {any} other The `Timestamp` to compare against.\r\n   * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\r\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof Timestamp && this._seconds === other.seconds && this._nanoseconds === other.nanoseconds;\n  }\n  /**\r\n   * Generates the Protobuf `Timestamp` object for this timestamp.\r\n   *\r\n   * @private\r\n   * @returns {Object} The `Timestamp` Protobuf object.\r\n   */\n\n\n  toProto() {\n    const timestamp = {};\n\n    if (this.seconds) {\n      timestamp.seconds = this.seconds;\n    }\n\n    if (this.nanoseconds) {\n      timestamp.nanos = this.nanoseconds;\n    }\n\n    return {\n      timestampValue: timestamp\n    };\n  }\n  /**\r\n   * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\r\n   * using the `>`, `<=`, `>=` and `>` operators.\r\n   *\r\n   * @return {string} a string encoding of this object.\r\n   */\n\n\n  valueOf() {\n    // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n    // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n    // with zeroes to be a consistent length. Strings with this format then have a lexiographical\n    // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n    // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n    // which would affect its lexiographical ordering.\n    const adjustedSeconds = this.seconds - MIN_SECONDS; // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n\n    const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n    const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n    return formattedSeconds + '.' + formattedNanoseconds;\n  }\n\n}\n\nexports.Timestamp = Timestamp;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/timestamp.js"],"names":["Object","defineProperty","exports","value","validate_1","require","MS_TO_NANOS","MIN_SECONDS","MAX_SECONDS","Timestamp","constructor","seconds","nanoseconds","validateInteger","minValue","maxValue","_seconds","_nanoseconds","now","fromMillis","Date","fromDate","date","getTime","milliseconds","Math","floor","nanos","fromProto","timestamp","Number","toDate","round","toMillis","isEqual","other","toProto","timestampValue","valueOf","adjustedSeconds","formattedSeconds","String","padStart","formattedNanoseconds"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst validate_1 = require(\"./validate\");\r\n/*!\r\n * Number of nanoseconds in a millisecond.\r\n *\r\n * @type {number}\r\n */\r\nconst MS_TO_NANOS = 1000000;\r\n/*!\r\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 0001-01-01T00:00:00Z.\r\n *\r\n * @type {number}\r\n */\r\nconst MIN_SECONDS = -62135596800;\r\n/*!\r\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\r\n *\r\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @type {number}\r\n */\r\nconst MAX_SECONDS = 253402300799;\r\n/**\r\n * A Timestamp represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\r\n * Calendar which extends the Gregorian calendar backwards to year one. It is\r\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\r\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\r\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\r\n */\r\nclass Timestamp {\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\r\n     *\r\n     * @param {number} seconds The number of seconds of UTC time since Unix epoch\r\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     * 9999-12-31T23:59:59Z inclusive.\r\n     * @param {number} nanoseconds The non-negative fractions of a second at\r\n     * nanosecond resolution. Negative second values with fractions must still\r\n     * have non-negative nanoseconds values that count forward in time. Must be\r\n     * from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(seconds, nanoseconds) {\r\n        validate_1.validateInteger('seconds', seconds, {\r\n            minValue: MIN_SECONDS,\r\n            maxValue: MAX_SECONDS,\r\n        });\r\n        validate_1.validateInteger('nanoseconds', nanoseconds, {\r\n            minValue: 0,\r\n            maxValue: 999999999,\r\n        });\r\n        this._seconds = seconds;\r\n        this._nanoseconds = nanoseconds;\r\n    }\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ updateTime:Firestore.Timestamp.now() });\r\n     *\r\n     * @return {Timestamp} A new `Timestamp` representing the current date.\r\n     */\r\n    static now() {\r\n        return Timestamp.fromMillis(Date.now());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\r\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\r\n     *\r\n     * @param {Date} date The date to initialize the `Timestamp` from.\r\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\r\n     * as the given date.\r\n     */\r\n    static fromDate(date) {\r\n        return Timestamp.fromMillis(date.getTime());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\r\n     *\r\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\r\n     * 1970-01-01T00:00:00Z.\r\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\r\n     * as the given number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const nanos = (milliseconds - seconds * 1000) * MS_TO_NANOS;\r\n        return new Timestamp(seconds, nanos);\r\n    }\r\n    /**\r\n     * Generates a `Timestamp` object from a Timestamp proto.\r\n     *\r\n     * @private\r\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\r\n     */\r\n    static fromProto(timestamp) {\r\n        return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\r\n    }\r\n    /**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let updated = snap.updateTime;\r\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n     * });\r\n     *\r\n     * @type {number}\r\n     */\r\n    get seconds() {\r\n        return this._seconds;\r\n    }\r\n    /**\r\n     * The non-negative fractions of a second at nanosecond resolution.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let updated = snap.updateTime;\r\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\r\n     * });\r\n     *\r\n     * @type {number}\r\n     */\r\n    get nanoseconds() {\r\n        return this._nanoseconds;\r\n    }\r\n    /**\r\n     * Returns a new `Date` corresponding to this timestamp. This may lose\r\n     * precision.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\r\n     * });\r\n     *\r\n     * @return {Date} JavaScript `Date` object representing the same point in time\r\n     * as this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate() {\r\n        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\r\n    }\r\n    /**\r\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   let startTime = snap.get('startTime');\r\n     *   let endTime = snap.get('endTime');\r\n     *   console.log(`Duration: ${endTime - startTime}`);\r\n     * });\r\n     *\r\n     * @return {number} The point in time corresponding to this timestamp,\r\n     * represented as the number of milliseconds since Unix epoch\r\n     * 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis() {\r\n        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\r\n    }\r\n    /**\r\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(snap => {\r\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\r\n     *     console.log('Document is in its initial state.');\r\n     *   }\r\n     * });\r\n     *\r\n     * @param {any} other The `Timestamp` to compare against.\r\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (this === other ||\r\n            (other instanceof Timestamp &&\r\n                this._seconds === other.seconds &&\r\n                this._nanoseconds === other.nanoseconds));\r\n    }\r\n    /**\r\n     * Generates the Protobuf `Timestamp` object for this timestamp.\r\n     *\r\n     * @private\r\n     * @returns {Object} The `Timestamp` Protobuf object.\r\n     */\r\n    toProto() {\r\n        const timestamp = {};\r\n        if (this.seconds) {\r\n            timestamp.seconds = this.seconds;\r\n        }\r\n        if (this.nanoseconds) {\r\n            timestamp.nanos = this.nanoseconds;\r\n        }\r\n        return { timestampValue: timestamp };\r\n    }\r\n    /**\r\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\r\n     * using the `>`, `<=`, `>=` and `>` operators.\r\n     *\r\n     * @return {string} a string encoding of this object.\r\n     */\r\n    valueOf() {\r\n        // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\r\n        // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\r\n        // with zeroes to be a consistent length. Strings with this format then have a lexiographical\r\n        // ordering that matches the expected ordering. The <seconds> translation is done to avoid\r\n        // having a leading negative sign (i.e. a leading '-' character) in its string representation,\r\n        // which would affect its lexiographical ordering.\r\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\r\n        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\r\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\r\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\r\n        return formattedSeconds + '.' + formattedNanoseconds;\r\n    }\r\n}\r\nexports.Timestamp = Timestamp;\r\n//# sourceMappingURL=timestamp.js.map"]},"metadata":{},"sourceType":"script"}