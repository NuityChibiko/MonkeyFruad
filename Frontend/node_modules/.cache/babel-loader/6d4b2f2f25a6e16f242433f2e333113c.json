{"ast":null,"code":"/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\n'use strict';\n\nvar Store = require('./store').Store;\n\nvar permuteDomain = require('./permuteDomain').permuteDomain;\n\nvar pathMatch = require('./pathMatch').pathMatch;\n\nvar util = require('util');\n\nfunction MemoryCookieStore() {\n  Store.call(this);\n  this.idx = {};\n}\n\nutil.inherits(MemoryCookieStore, Store);\nexports.MemoryCookieStore = MemoryCookieStore;\nMemoryCookieStore.prototype.idx = null; // Since it's just a struct in RAM, this Store is synchronous\n\nMemoryCookieStore.prototype.synchronous = true; // force a default depth:\n\nMemoryCookieStore.prototype.inspect = function () {\n  return \"{ idx: \" + util.inspect(this.idx, false, 2) + ' }';\n}; // Use the new custom inspection symbol to add the custom inspect function if\n// available.\n\n\nif (util.inspect.custom) {\n  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;\n}\n\nMemoryCookieStore.prototype.findCookie = function (domain, path, key, cb) {\n  if (!this.idx[domain]) {\n    return cb(null, undefined);\n  }\n\n  if (!this.idx[domain][path]) {\n    return cb(null, undefined);\n  }\n\n  return cb(null, this.idx[domain][path][key] || null);\n};\n\nMemoryCookieStore.prototype.findCookies = function (domain, path, cb) {\n  var results = [];\n\n  if (!domain) {\n    return cb(null, []);\n  }\n\n  var pathMatcher;\n\n  if (!path) {\n    // null means \"all paths\"\n    pathMatcher = function matchAll(domainIndex) {\n      for (var curPath in domainIndex) {\n        var pathIndex = domainIndex[curPath];\n\n        for (var key in pathIndex) {\n          results.push(pathIndex[key]);\n        }\n      }\n    };\n  } else {\n    pathMatcher = function matchRFC(domainIndex) {\n      //NOTE: we should use path-match algorithm from S5.1.4 here\n      //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n      Object.keys(domainIndex).forEach(function (cookiePath) {\n        if (pathMatch(path, cookiePath)) {\n          var pathIndex = domainIndex[cookiePath];\n\n          for (var key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      });\n    };\n  }\n\n  var domains = permuteDomain(domain) || [domain];\n  var idx = this.idx;\n  domains.forEach(function (curDomain) {\n    var domainIndex = idx[curDomain];\n\n    if (!domainIndex) {\n      return;\n    }\n\n    pathMatcher(domainIndex);\n  });\n  cb(null, results);\n};\n\nMemoryCookieStore.prototype.putCookie = function (cookie, cb) {\n  if (!this.idx[cookie.domain]) {\n    this.idx[cookie.domain] = {};\n  }\n\n  if (!this.idx[cookie.domain][cookie.path]) {\n    this.idx[cookie.domain][cookie.path] = {};\n  }\n\n  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n  cb(null);\n};\n\nMemoryCookieStore.prototype.updateCookie = function (oldCookie, newCookie, cb) {\n  // updateCookie() may avoid updating cookies that are identical.  For example,\n  // lastAccessed may not be important to some stores and an equality\n  // comparison could exclude that field.\n  this.putCookie(newCookie, cb);\n};\n\nMemoryCookieStore.prototype.removeCookie = function (domain, path, key, cb) {\n  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\n    delete this.idx[domain][path][key];\n  }\n\n  cb(null);\n};\n\nMemoryCookieStore.prototype.removeCookies = function (domain, path, cb) {\n  if (this.idx[domain]) {\n    if (path) {\n      delete this.idx[domain][path];\n    } else {\n      delete this.idx[domain];\n    }\n  }\n\n  return cb(null);\n};\n\nMemoryCookieStore.prototype.removeAllCookies = function (cb) {\n  this.idx = {};\n  return cb(null);\n};\n\nMemoryCookieStore.prototype.getAllCookies = function (cb) {\n  var cookies = [];\n  var idx = this.idx;\n  var domains = Object.keys(idx);\n  domains.forEach(function (domain) {\n    var paths = Object.keys(idx[domain]);\n    paths.forEach(function (path) {\n      var keys = Object.keys(idx[domain][path]);\n      keys.forEach(function (key) {\n        if (key !== null) {\n          cookies.push(idx[domain][path][key]);\n        }\n      });\n    });\n  }); // Sort by creationIndex so deserializing retains the creation order.\n  // When implementing your own store, this SHOULD retain the order too\n\n  cookies.sort(function (a, b) {\n    return (a.creationIndex || 0) - (b.creationIndex || 0);\n  });\n  cb(null, cookies);\n};","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/request/node_modules/tough-cookie/lib/memstore.js"],"names":["Store","require","permuteDomain","pathMatch","util","MemoryCookieStore","call","idx","inherits","exports","prototype","synchronous","inspect","custom","findCookie","domain","path","key","cb","undefined","findCookies","results","pathMatcher","matchAll","domainIndex","curPath","pathIndex","push","matchRFC","Object","keys","forEach","cookiePath","domains","curDomain","putCookie","cookie","updateCookie","oldCookie","newCookie","removeCookie","removeCookies","removeAllCookies","getAllCookies","cookies","paths","sort","a","b","creationIndex"],"mappings":"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","sourcesContent":["/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n'use strict';\r\nvar Store = require('./store').Store;\r\nvar permuteDomain = require('./permuteDomain').permuteDomain;\r\nvar pathMatch = require('./pathMatch').pathMatch;\r\nvar util = require('util');\r\n\r\nfunction MemoryCookieStore() {\r\n  Store.call(this);\r\n  this.idx = {};\r\n}\r\nutil.inherits(MemoryCookieStore, Store);\r\nexports.MemoryCookieStore = MemoryCookieStore;\r\nMemoryCookieStore.prototype.idx = null;\r\n\r\n// Since it's just a struct in RAM, this Store is synchronous\r\nMemoryCookieStore.prototype.synchronous = true;\r\n\r\n// force a default depth:\r\nMemoryCookieStore.prototype.inspect = function() {\r\n  return \"{ idx: \"+util.inspect(this.idx, false, 2)+' }';\r\n};\r\n\r\n// Use the new custom inspection symbol to add the custom inspect function if\r\n// available.\r\nif (util.inspect.custom) {\r\n  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;\r\n}\r\n\r\nMemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {\r\n  if (!this.idx[domain]) {\r\n    return cb(null,undefined);\r\n  }\r\n  if (!this.idx[domain][path]) {\r\n    return cb(null,undefined);\r\n  }\r\n  return cb(null,this.idx[domain][path][key]||null);\r\n};\r\n\r\nMemoryCookieStore.prototype.findCookies = function(domain, path, cb) {\r\n  var results = [];\r\n  if (!domain) {\r\n    return cb(null,[]);\r\n  }\r\n\r\n  var pathMatcher;\r\n  if (!path) {\r\n    // null means \"all paths\"\r\n    pathMatcher = function matchAll(domainIndex) {\r\n      for (var curPath in domainIndex) {\r\n        var pathIndex = domainIndex[curPath];\r\n        for (var key in pathIndex) {\r\n          results.push(pathIndex[key]);\r\n        }\r\n      }\r\n    };\r\n\r\n  } else {\r\n    pathMatcher = function matchRFC(domainIndex) {\r\n       //NOTE: we should use path-match algorithm from S5.1.4 here\r\n       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\r\n       Object.keys(domainIndex).forEach(function (cookiePath) {\r\n         if (pathMatch(path, cookiePath)) {\r\n           var pathIndex = domainIndex[cookiePath];\r\n\r\n           for (var key in pathIndex) {\r\n             results.push(pathIndex[key]);\r\n           }\r\n         }\r\n       });\r\n     };\r\n  }\r\n\r\n  var domains = permuteDomain(domain) || [domain];\r\n  var idx = this.idx;\r\n  domains.forEach(function(curDomain) {\r\n    var domainIndex = idx[curDomain];\r\n    if (!domainIndex) {\r\n      return;\r\n    }\r\n    pathMatcher(domainIndex);\r\n  });\r\n\r\n  cb(null,results);\r\n};\r\n\r\nMemoryCookieStore.prototype.putCookie = function(cookie, cb) {\r\n  if (!this.idx[cookie.domain]) {\r\n    this.idx[cookie.domain] = {};\r\n  }\r\n  if (!this.idx[cookie.domain][cookie.path]) {\r\n    this.idx[cookie.domain][cookie.path] = {};\r\n  }\r\n  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\r\n  cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {\r\n  // updateCookie() may avoid updating cookies that are identical.  For example,\r\n  // lastAccessed may not be important to some stores and an equality\r\n  // comparison could exclude that field.\r\n  this.putCookie(newCookie,cb);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {\r\n  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\r\n    delete this.idx[domain][path][key];\r\n  }\r\n  cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {\r\n  if (this.idx[domain]) {\r\n    if (path) {\r\n      delete this.idx[domain][path];\r\n    } else {\r\n      delete this.idx[domain];\r\n    }\r\n  }\r\n  return cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeAllCookies = function(cb) {\r\n  this.idx = {};\r\n  return cb(null);\r\n}\r\n\r\nMemoryCookieStore.prototype.getAllCookies = function(cb) {\r\n  var cookies = [];\r\n  var idx = this.idx;\r\n\r\n  var domains = Object.keys(idx);\r\n  domains.forEach(function(domain) {\r\n    var paths = Object.keys(idx[domain]);\r\n    paths.forEach(function(path) {\r\n      var keys = Object.keys(idx[domain][path]);\r\n      keys.forEach(function(key) {\r\n        if (key !== null) {\r\n          cookies.push(idx[domain][path][key]);\r\n        }\r\n      });\r\n    });\r\n  });\r\n\r\n  // Sort by creationIndex so deserializing retains the creation order.\r\n  // When implementing your own store, this SHOULD retain the order too\r\n  cookies.sort(function(a,b) {\r\n    return (a.creationIndex||0) - (b.creationIndex||0);\r\n  });\r\n\r\n  cb(null, cookies);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}