{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst google_gax_1 = require(\"google-gax\");\n/**\r\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\r\n * updates(), and creates().\r\n *\r\n * @class WriteResult\r\n */\n\n\nclass WriteResult {\n  /**\r\n   * @hideconstructor\r\n   *\r\n   * @param _writeTime The time of the corresponding document write.\r\n   */\n  constructor(_writeTime) {\n    this._writeTime = _writeTime;\n  }\n  /**\r\n   * The write time as set by the Firestore servers.\r\n   *\r\n   * @type {Timestamp}\r\n   * @name WriteResult#writeTime\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\r\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\r\n   * });\r\n   */\n\n\n  get writeTime() {\n    return this._writeTime;\n  }\n  /**\r\n   * Returns true if this `WriteResult` is equal to the provided value.\r\n   *\r\n   * @param {*} other The value to compare against.\r\n   * @return true if this `WriteResult` is equal to the provided value.\r\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n  }\n\n}\n\nexports.WriteResult = WriteResult;\n/**\r\n * A BatchWriteResult wraps the write time and status returned by Firestore\r\n * when making BatchWriteRequests.\r\n *\r\n * @private\r\n */\n\nclass BatchWriteResult {\n  constructor(writeTime, status) {\n    this.writeTime = writeTime;\n    this.status = status;\n  }\n\n}\n\nexports.BatchWriteResult = BatchWriteResult;\n/**\r\n * A Firestore WriteBatch that can be used to atomically commit multiple write\r\n * operations at once.\r\n *\r\n * @class WriteBatch\r\n */\n\nclass WriteBatch {\n  /**\r\n   * @hideconstructor\r\n   */\n  constructor(firestore) {\n    /**\r\n     * An array of document paths and the corresponding write operations that are\r\n     * executed as part of the commit. The resulting `api.IWrite` will be sent to\r\n     * the backend.\r\n     *\r\n     * @private\r\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n    this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\r\n   * The number of writes in this batch.\r\n   */\n\n\n  get _opCount() {\n    return this._ops.length;\n  }\n  /**\r\n   * Checks if this write batch has any pending operations.\r\n   *\r\n   * @private\r\n   */\n\n\n  get isEmpty() {\n    return this._ops.length === 0;\n  }\n  /**\r\n   * Throws an error if this batch has already been committed.\r\n   *\r\n   * @private\r\n   */\n\n\n  verifyNotCommitted() {\n    if (this._committed) {\n      throw new Error('Cannot modify a WriteBatch that has been committed.');\n    }\n  }\n  /**\r\n   * Create a document with the provided object values. This will fail the batch\r\n   * if a document exists at its location.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * created.\r\n   * @param {T} data The object to serialize as the document.\r\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n   * method calls.\r\n   *\r\n   * @example\r\n   * let writeBatch = firestore.batch();\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * writeBatch.create(documentRef, {foo: 'bar'});\r\n   *\r\n   * writeBatch.commit().then(() => {\r\n   *   console.log('Successfully executed batch.');\r\n   * });\r\n   */\n\n\n  create(documentRef, data) {\n    const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n\n    const firestoreData = ref._converter.toFirestore(data);\n\n    validateDocumentData('data', firestoreData,\n    /* allowDeletes= */\n    false, this._allowUndefined);\n    this.verifyNotCommitted();\n    const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n    transform.validate();\n    const precondition = new document_1.Precondition({\n      exists: false\n    });\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n      const write = document.toWriteProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      write.currentDocument = precondition.toProto();\n      return write;\n    };\n\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n\n    return this;\n  }\n  /**\r\n   * Deletes a document from the database.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * deleted.\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the batch if the\r\n   * document doesn't exist or was last updated at a different time.\r\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n   * method calls.\r\n   *\r\n   * @example\r\n   * let writeBatch = firestore.batch();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * writeBatch.delete(documentRef);\r\n   *\r\n   * writeBatch.commit().then(() => {\r\n   *   console.log('Successfully executed batch.');\r\n   * });\r\n   */\n\n\n  delete(documentRef, precondition) {\n    const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n    validateDeletePrecondition('precondition', precondition, {\n      optional: true\n    });\n    this.verifyNotCommitted();\n    const conditions = new document_1.Precondition(precondition);\n\n    const op = () => {\n      const write = {\n        delete: ref.formattedName\n      };\n\n      if (!conditions.isEmpty) {\n        write.currentDocument = conditions.toProto();\n      }\n\n      return write;\n    };\n\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n\n    return this;\n  }\n  /**\r\n   * Write to the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document does not\r\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\r\n   * the provided data can be merged into the existing document.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * set.\r\n   * @param {T|Partial<T>} data The object to serialize as the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @param {boolean=} options.merge - If true, set() merges the values\r\n   * specified in its data argument. Fields omitted from this set() call\r\n   * remain untouched.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n   * set() only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched.\r\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n   * method calls.\r\n   *\r\n   * @example\r\n   * let writeBatch = firestore.batch();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * writeBatch.set(documentRef, {foo: 'bar'});\r\n   *\r\n   * writeBatch.commit().then(() => {\r\n   *   console.log('Successfully executed batch.');\r\n   * });\r\n   */\n\n\n  set(documentRef, data, options) {\n    validateSetOptions('options', options, {\n      optional: true\n    });\n    const mergeLeaves = options && options.merge === true;\n    const mergePaths = options && options.mergeFields;\n    const ref = reference_1.validateDocumentReference('documentRef', documentRef);\n    let firestoreData;\n\n    if (mergeLeaves || mergePaths) {\n      // Cast to any in order to satisfy the union type constraint on\n      // toFirestore().\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      firestoreData = ref._converter.toFirestore(data, options);\n    } else {\n      firestoreData = ref._converter.toFirestore(data);\n    }\n\n    validateDocumentData('data', firestoreData,\n    /* allowDeletes= */\n    !!(mergePaths || mergeLeaves), this._allowUndefined);\n    this.verifyNotCommitted();\n    let documentMask;\n\n    if (mergePaths) {\n      documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n      firestoreData = documentMask.applyTo(firestoreData);\n    }\n\n    const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n    transform.validate();\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n\n      if (mergePaths) {\n        documentMask.removeFields(transform.fields);\n      } else if (mergeLeaves) {\n        documentMask = document_1.DocumentMask.fromObject(firestoreData);\n      }\n\n      const write = document.toWriteProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      if (mergePaths || mergeLeaves) {\n        write.updateMask = documentMask.toProto();\n      }\n\n      return write;\n    };\n\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n\n    return this;\n  }\n  /**\r\n   * Update fields of the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document\r\n   * doesn't yet exist, the update fails and the entire batch will be rejected.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values. Nested fields can be\r\n   * updated by providing dot-separated field path strings or by providing\r\n   * FieldPath objects.\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * updated.\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object\r\n   * containing the fields and values with which to update the document\r\n   * or the path of the first field to update.\r\n   * @param {\r\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n   * An alternating list of field paths and values to update or a Precondition\r\n   * to restrict this update.\r\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n   * method calls.\r\n   *\r\n   * @example\r\n   * let writeBatch = firestore.batch();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * writeBatch.update(documentRef, {foo: 'bar'});\r\n   *\r\n   * writeBatch.commit().then(() => {\r\n   *   console.log('Successfully executed batch.');\r\n   * });\r\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    // eslint-disable-next-line prefer-rest-params\n    validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    this.verifyNotCommitted();\n    const updateMap = new Map();\n    let precondition = new document_1.Precondition({\n      exists: true\n    });\n    const argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n    const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n    if (usesVarargs) {\n      const argumentOffset = 1; // Respect 'documentRef' in the error message\n\n      const fieldOrValues = [dataOrField, ...preconditionOrValues];\n\n      try {\n        for (let i = 0; i < fieldOrValues.length; i += 2) {\n          if (i === fieldOrValues.length - 1) {\n            const maybePrecondition = fieldOrValues[i];\n            validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n            precondition = new document_1.Precondition(maybePrecondition);\n          } else {\n            const maybeFieldPath = fieldOrValues[i];\n            path_1.validateFieldPath(i + argumentOffset, maybeFieldPath); // Unlike the `validateMinNumberOfArguments` invocation above, this\n            // validation can be triggered both from `WriteBatch.update()` and\n            // `DocumentReference.update()`. Hence, we don't use the fully\n            // qualified API name in the error message.\n\n            validate_1.validateMinNumberOfArguments('update', fieldOrValues, i + 1);\n            const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n            validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n            updateMap.set(fieldPath, fieldOrValues[i + 1]);\n          }\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n        // error message.\n\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    } else {\n      try {\n        validateUpdateMap('dataOrField', dataOrField, this._allowUndefined); // eslint-disable-next-line prefer-rest-params\n\n        validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n        const data = dataOrField;\n        Object.entries(data).forEach(([key, value]) => {\n          // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`\n          // is set)\n          if (value !== undefined) {\n            path_1.validateFieldPath(key, key);\n            updateMap.set(path_1.FieldPath.fromArgument(key), value);\n          }\n        });\n\n        if (preconditionOrValues.length > 0) {\n          validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n          precondition = new document_1.Precondition(preconditionOrValues[0]);\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n        // message to describe the usage of update() better.\n\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    }\n\n    validateNoConflictingFields('dataOrField', updateMap);\n    const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n    transform.validate();\n    const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n      const write = document.toWriteProto();\n      write.updateMask = documentMask.toProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      write.currentDocument = precondition.toProto();\n      return write;\n    };\n\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n\n    return this;\n  }\n  /**\r\n   * Atomically commits all pending operations to the database and verifies all\r\n   * preconditions. Fails the entire write if any precondition is not met.\r\n   *\r\n   * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\r\n   * when this batch completes.\r\n   *\r\n   * @example\r\n   * let writeBatch = firestore.batch();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * writeBatch.set(documentRef, {foo: 'bar'});\r\n   *\r\n   * writeBatch.commit().then(() => {\r\n   *   console.log('Successfully executed batch.');\r\n   * });\r\n   */\n\n\n  commit() {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack; // Commits should also be retried when they fail with status code ABORTED.\n\n    const retryCodes = [google_gax_1.Status.ABORTED, ...util_1.getRetryCodes('commit')];\n    return this._commit({\n      retryCodes\n    }).then(response => {\n      return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n    }).catch(err => {\n      throw util_1.wrapError(err, stack);\n    });\n  }\n  /**\r\n   * Commit method that takes an optional transaction ID.\r\n   *\r\n   * @private\r\n   * @param commitOptions Options to use for this commit.\r\n   * @param commitOptions.transactionId The transaction ID of this commit.\r\n   * @param commitOptions.requestTag A unique client-assigned identifier for\r\n   * this request.\r\n   * @returns  A Promise that resolves when this batch completes.\r\n   */\n\n\n  async _commit(commitOptions) {\n    var _a; // Note: We don't call `verifyNotCommitted()` to allow for retries.\n\n\n    this._committed = true;\n    const tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag();\n    await this._firestore.initializeIfNeeded(tag); // Note that the request may not always be of type ICommitRequest. This is\n    // just here to ensure type safety.\n\n    const request = {\n      database: this._firestore.formattedName,\n      writes: this._ops.map(op => op.op())\n    };\n\n    if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n      request.transaction = commitOptions.transactionId;\n    }\n\n    logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n    return this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes);\n  }\n  /**\r\n   * Resets the WriteBatch and dequeues all pending operations.\r\n   * @private\r\n   */\n\n\n  _reset() {\n    this._ops.splice(0);\n\n    this._committed = false;\n  }\n\n}\n\nexports.WriteBatch = WriteBatch;\n/**\r\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\r\n * and 'lastUpdateTime' use valid types.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate\r\n * @param allowExists Whether to allow the 'exists' preconditions.\r\n */\n\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n\n  const precondition = value;\n  let conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExists) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n    }\n\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\n  }\n}\n/**\r\n * Validates the use of 'value' as an update Precondition.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n */\n\n\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    false);\n  }\n}\n/**\r\n * Validates the use of 'value' as a delete Precondition.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n */\n\n\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    true);\n  }\n}\n/**\r\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\r\n * boolean.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n * @throws if the input is not a valid SetOptions object.\r\n */\n\n\nfunction validateSetOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\n    }\n\n    const setOptions = value;\n\n    if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\n    }\n\n    if ('mergeFields' in setOptions) {\n      if (!Array.isArray(setOptions.mergeFields)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\n      }\n\n      for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n        }\n      }\n    }\n\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n    }\n  }\n}\n\nexports.validateSetOptions = validateSetOptions;\n/**\r\n * Validates a JavaScript object for usage as a Firestore document.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param obj JavaScript object to validate.\r\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @throws when the object is invalid.\r\n */\n\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n    allowDeletes: allowDeletes ? 'all' : 'none',\n    allowTransforms: true,\n    allowUndefined\n  });\n}\n\nexports.validateDocumentData = validateDocumentData;\n/**\r\n * Validates that a value can be used as field value during an update.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param val The value to verify.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @param path The path to show in the error message.\r\n */\n\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n  serializer_1.validateUserInput(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true,\n    allowUndefined\n  }, path);\n}\n\nexports.validateFieldValue = validateFieldValue;\n/**\r\n * Validates that the update data does not contain any ambiguous field\r\n * definitions (such as 'a.b' and 'a').\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param data An update map with field/value pairs.\r\n */\n\nfunction validateNoConflictingFields(arg, data) {\n  const fields = [];\n  data.forEach((value, key) => {\n    fields.push(key);\n  });\n  fields.sort((left, right) => left.compareTo(right));\n\n  for (let i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n    }\n  }\n}\n/**\r\n * Validates that a JavaScript object is a map of field paths to field values.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param obj JavaScript object to validate.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @throws when the object is invalid.\r\n */\n\n\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  if (Object.keys(obj).length === 0) {\n    throw new Error('At least one field must be updated.');\n  }\n\n  validateFieldValue(arg, obj, allowUndefined);\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/write-batch.js"],"names":["Object","defineProperty","exports","value","document_1","require","logger_1","path_1","reference_1","serializer_1","timestamp_1","util_1","validate_1","google_gax_1","WriteResult","constructor","_writeTime","writeTime","isEqual","other","BatchWriteResult","status","WriteBatch","firestore","_ops","_committed","_firestore","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","_opCount","length","isEmpty","verifyNotCommitted","Error","create","documentRef","data","ref","validateDocumentReference","firestoreData","_converter","toFirestore","validateDocumentData","transform","DocumentTransform","fromObject","validate","precondition","Precondition","exists","op","document","DocumentSnapshot","write","toWriteProto","updateTransforms","toProto","currentDocument","push","docPath","path","delete","validateDeletePrecondition","optional","conditions","formattedName","set","options","validateSetOptions","mergeLeaves","merge","mergePaths","mergeFields","documentMask","DocumentMask","fromFieldMask","applyTo","removeFields","fields","updateMask","update","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","updateMap","Map","argumentError","usesVarargs","FieldPath","argumentOffset","fieldOrValues","i","maybePrecondition","validateUpdatePrecondition","maybeFieldPath","validateFieldPath","fieldPath","fromArgument","validateFieldValue","err","logger","message","validateUpdateMap","validateMaxNumberOfArguments","entries","forEach","key","undefined","validateNoConflictingFields","fromUpdateMap","commit","stack","retryCodes","Status","ABORTED","getRetryCodes","_commit","then","response","writeResults","map","writeResult","Timestamp","fromProto","updateTime","commitTime","catch","wrapError","commitOptions","_a","tag","requestTag","initializeIfNeeded","request","database","writes","transactionId","transaction","methodName","_reset","splice","validatePrecondition","arg","allowExists","invalidArgumentMessage","lastUpdateTime","validateOptional","isObject","setOptions","Array","isArray","obj","allowDeletes","allowUndefined","isPlainObject","customObjectMessage","validateUserInput","allowTransforms","val","sort","left","right","compareTo","isPrefixOf","keys"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst document_1 = require(\"./document\");\r\nconst logger_1 = require(\"./logger\");\r\nconst path_1 = require(\"./path\");\r\nconst reference_1 = require(\"./reference\");\r\nconst serializer_1 = require(\"./serializer\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\nconst util_1 = require(\"./util\");\r\nconst validate_1 = require(\"./validate\");\r\nconst google_gax_1 = require(\"google-gax\");\r\n/**\r\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\r\n * updates(), and creates().\r\n *\r\n * @class WriteResult\r\n */\r\nclass WriteResult {\r\n    /**\r\n     * @hideconstructor\r\n     *\r\n     * @param _writeTime The time of the corresponding document write.\r\n     */\r\n    constructor(_writeTime) {\r\n        this._writeTime = _writeTime;\r\n    }\r\n    /**\r\n     * The write time as set by the Firestore servers.\r\n     *\r\n     * @type {Timestamp}\r\n     * @name WriteResult#writeTime\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({foo: 'bar'}).then(writeResult => {\r\n     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\r\n     * });\r\n     */\r\n    get writeTime() {\r\n        return this._writeTime;\r\n    }\r\n    /**\r\n     * Returns true if this `WriteResult` is equal to the provided value.\r\n     *\r\n     * @param {*} other The value to compare against.\r\n     * @return true if this `WriteResult` is equal to the provided value.\r\n     */\r\n    isEqual(other) {\r\n        return (this === other ||\r\n            (other instanceof WriteResult &&\r\n                this._writeTime.isEqual(other._writeTime)));\r\n    }\r\n}\r\nexports.WriteResult = WriteResult;\r\n/**\r\n * A BatchWriteResult wraps the write time and status returned by Firestore\r\n * when making BatchWriteRequests.\r\n *\r\n * @private\r\n */\r\nclass BatchWriteResult {\r\n    constructor(writeTime, status) {\r\n        this.writeTime = writeTime;\r\n        this.status = status;\r\n    }\r\n}\r\nexports.BatchWriteResult = BatchWriteResult;\r\n/**\r\n * A Firestore WriteBatch that can be used to atomically commit multiple write\r\n * operations at once.\r\n *\r\n * @class WriteBatch\r\n */\r\nclass WriteBatch {\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(firestore) {\r\n        /**\r\n         * An array of document paths and the corresponding write operations that are\r\n         * executed as part of the commit. The resulting `api.IWrite` will be sent to\r\n         * the backend.\r\n         *\r\n         * @private\r\n         */\r\n        this._ops = [];\r\n        this._committed = false;\r\n        this._firestore = firestore;\r\n        this._serializer = new serializer_1.Serializer(firestore);\r\n        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\r\n    }\r\n    /**\r\n     * The number of writes in this batch.\r\n     */\r\n    get _opCount() {\r\n        return this._ops.length;\r\n    }\r\n    /**\r\n     * Checks if this write batch has any pending operations.\r\n     *\r\n     * @private\r\n     */\r\n    get isEmpty() {\r\n        return this._ops.length === 0;\r\n    }\r\n    /**\r\n     * Throws an error if this batch has already been committed.\r\n     *\r\n     * @private\r\n     */\r\n    verifyNotCommitted() {\r\n        if (this._committed) {\r\n            throw new Error('Cannot modify a WriteBatch that has been committed.');\r\n        }\r\n    }\r\n    /**\r\n     * Create a document with the provided object values. This will fail the batch\r\n     * if a document exists at its location.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * created.\r\n     * @param {T} data The object to serialize as the document.\r\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n     * method calls.\r\n     *\r\n     * @example\r\n     * let writeBatch = firestore.batch();\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * writeBatch.create(documentRef, {foo: 'bar'});\r\n     *\r\n     * writeBatch.commit().then(() => {\r\n     *   console.log('Successfully executed batch.');\r\n     * });\r\n     */\r\n    create(documentRef, data) {\r\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\r\n        const firestoreData = ref._converter.toFirestore(data);\r\n        validateDocumentData('data', firestoreData, \r\n        /* allowDeletes= */ false, this._allowUndefined);\r\n        this.verifyNotCommitted();\r\n        const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\r\n        transform.validate();\r\n        const precondition = new document_1.Precondition({ exists: false });\r\n        const op = () => {\r\n            const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\r\n            const write = document.toWriteProto();\r\n            if (!transform.isEmpty) {\r\n                write.updateTransforms = transform.toProto(this._serializer);\r\n            }\r\n            write.currentDocument = precondition.toProto();\r\n            return write;\r\n        };\r\n        this._ops.push({ docPath: documentRef.path, op });\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes a document from the database.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * deleted.\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the batch if the\r\n     * document doesn't exist or was last updated at a different time.\r\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n     * method calls.\r\n     *\r\n     * @example\r\n     * let writeBatch = firestore.batch();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * writeBatch.delete(documentRef);\r\n     *\r\n     * writeBatch.commit().then(() => {\r\n     *   console.log('Successfully executed batch.');\r\n     * });\r\n     */\r\n    delete(documentRef, precondition) {\r\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\r\n        validateDeletePrecondition('precondition', precondition, { optional: true });\r\n        this.verifyNotCommitted();\r\n        const conditions = new document_1.Precondition(precondition);\r\n        const op = () => {\r\n            const write = { delete: ref.formattedName };\r\n            if (!conditions.isEmpty) {\r\n                write.currentDocument = conditions.toProto();\r\n            }\r\n            return write;\r\n        };\r\n        this._ops.push({ docPath: documentRef.path, op });\r\n        return this;\r\n    }\r\n    /**\r\n     * Write to the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document does not\r\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\r\n     * the provided data can be merged into the existing document.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * set.\r\n     * @param {T|Partial<T>} data The object to serialize as the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @param {boolean=} options.merge - If true, set() merges the values\r\n     * specified in its data argument. Fields omitted from this set() call\r\n     * remain untouched.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n     * set() only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched.\r\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n     * method calls.\r\n     *\r\n     * @example\r\n     * let writeBatch = firestore.batch();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * writeBatch.set(documentRef, {foo: 'bar'});\r\n     *\r\n     * writeBatch.commit().then(() => {\r\n     *   console.log('Successfully executed batch.');\r\n     * });\r\n     */\r\n    set(documentRef, data, options) {\r\n        validateSetOptions('options', options, { optional: true });\r\n        const mergeLeaves = options && options.merge === true;\r\n        const mergePaths = options && options.mergeFields;\r\n        const ref = reference_1.validateDocumentReference('documentRef', documentRef);\r\n        let firestoreData;\r\n        if (mergeLeaves || mergePaths) {\r\n            // Cast to any in order to satisfy the union type constraint on\r\n            // toFirestore().\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            firestoreData = ref._converter.toFirestore(data, options);\r\n        }\r\n        else {\r\n            firestoreData = ref._converter.toFirestore(data);\r\n        }\r\n        validateDocumentData('data', firestoreData, \r\n        /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);\r\n        this.verifyNotCommitted();\r\n        let documentMask;\r\n        if (mergePaths) {\r\n            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\r\n            firestoreData = documentMask.applyTo(firestoreData);\r\n        }\r\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\r\n        transform.validate();\r\n        const op = () => {\r\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\r\n            if (mergePaths) {\r\n                documentMask.removeFields(transform.fields);\r\n            }\r\n            else if (mergeLeaves) {\r\n                documentMask = document_1.DocumentMask.fromObject(firestoreData);\r\n            }\r\n            const write = document.toWriteProto();\r\n            if (!transform.isEmpty) {\r\n                write.updateTransforms = transform.toProto(this._serializer);\r\n            }\r\n            if (mergePaths || mergeLeaves) {\r\n                write.updateMask = documentMask.toProto();\r\n            }\r\n            return write;\r\n        };\r\n        this._ops.push({ docPath: documentRef.path, op });\r\n        return this;\r\n    }\r\n    /**\r\n     * Update fields of the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document\r\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values. Nested fields can be\r\n     * updated by providing dot-separated field path strings or by providing\r\n     * FieldPath objects.\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * updated.\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object\r\n     * containing the fields and values with which to update the document\r\n     * or the path of the first field to update.\r\n     * @param {\r\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n     * An alternating list of field paths and values to update or a Precondition\r\n     * to restrict this update.\r\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\r\n     * method calls.\r\n     *\r\n     * @example\r\n     * let writeBatch = firestore.batch();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * writeBatch.update(documentRef, {foo: 'bar'});\r\n     *\r\n     * writeBatch.commit().then(() => {\r\n     *   console.log('Successfully executed batch.');\r\n     * });\r\n     */\r\n    update(documentRef, dataOrField, ...preconditionOrValues) {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\r\n        reference_1.validateDocumentReference('documentRef', documentRef);\r\n        this.verifyNotCommitted();\r\n        const updateMap = new Map();\r\n        let precondition = new document_1.Precondition({ exists: true });\r\n        const argumentError = 'Update() requires either a single JavaScript ' +\r\n            'object or an alternating list of field/value pairs that can be ' +\r\n            'followed by an optional precondition.';\r\n        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\r\n        if (usesVarargs) {\r\n            const argumentOffset = 1; // Respect 'documentRef' in the error message\r\n            const fieldOrValues = [dataOrField, ...preconditionOrValues];\r\n            try {\r\n                for (let i = 0; i < fieldOrValues.length; i += 2) {\r\n                    if (i === fieldOrValues.length - 1) {\r\n                        const maybePrecondition = fieldOrValues[i];\r\n                        validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\r\n                        precondition = new document_1.Precondition(maybePrecondition);\r\n                    }\r\n                    else {\r\n                        const maybeFieldPath = fieldOrValues[i];\r\n                        path_1.validateFieldPath(i + argumentOffset, maybeFieldPath);\r\n                        // Unlike the `validateMinNumberOfArguments` invocation above, this\r\n                        // validation can be triggered both from `WriteBatch.update()` and\r\n                        // `DocumentReference.update()`. Hence, we don't use the fully\r\n                        // qualified API name in the error message.\r\n                        validate_1.validateMinNumberOfArguments('update', fieldOrValues, i + 1);\r\n                        const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\r\n                        validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\r\n                        updateMap.set(fieldPath, fieldOrValues[i + 1]);\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err);\r\n                // We catch the validation error here and re-throw to provide a better\r\n                // error message.\r\n                throw new Error(`${argumentError} ${err.message}`);\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\r\n                // eslint-disable-next-line prefer-rest-params\r\n                validate_1.validateMaxNumberOfArguments('update', arguments, 3);\r\n                const data = dataOrField;\r\n                Object.entries(data).forEach(([key, value]) => {\r\n                    // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`\r\n                    // is set)\r\n                    if (value !== undefined) {\r\n                        path_1.validateFieldPath(key, key);\r\n                        updateMap.set(path_1.FieldPath.fromArgument(key), value);\r\n                    }\r\n                });\r\n                if (preconditionOrValues.length > 0) {\r\n                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\r\n                    precondition = new document_1.Precondition(preconditionOrValues[0]);\r\n                }\r\n            }\r\n            catch (err) {\r\n                logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err);\r\n                // We catch the validation error here and prefix the error with a custom\r\n                // message to describe the usage of update() better.\r\n                throw new Error(`${argumentError} ${err.message}`);\r\n            }\r\n        }\r\n        validateNoConflictingFields('dataOrField', updateMap);\r\n        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\r\n        transform.validate();\r\n        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\r\n        const op = () => {\r\n            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\r\n            const write = document.toWriteProto();\r\n            write.updateMask = documentMask.toProto();\r\n            if (!transform.isEmpty) {\r\n                write.updateTransforms = transform.toProto(this._serializer);\r\n            }\r\n            write.currentDocument = precondition.toProto();\r\n            return write;\r\n        };\r\n        this._ops.push({ docPath: documentRef.path, op });\r\n        return this;\r\n    }\r\n    /**\r\n     * Atomically commits all pending operations to the database and verifies all\r\n     * preconditions. Fails the entire write if any precondition is not met.\r\n     *\r\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\r\n     * when this batch completes.\r\n     *\r\n     * @example\r\n     * let writeBatch = firestore.batch();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * writeBatch.set(documentRef, {foo: 'bar'});\r\n     *\r\n     * writeBatch.commit().then(() => {\r\n     *   console.log('Successfully executed batch.');\r\n     * });\r\n     */\r\n    commit() {\r\n        // Capture the error stack to preserve stack tracing across async calls.\r\n        const stack = Error().stack;\r\n        // Commits should also be retried when they fail with status code ABORTED.\r\n        const retryCodes = [google_gax_1.Status.ABORTED, ...util_1.getRetryCodes('commit')];\r\n        return this._commit({ retryCodes })\r\n            .then(response => {\r\n            return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\r\n        })\r\n            .catch(err => {\r\n            throw util_1.wrapError(err, stack);\r\n        });\r\n    }\r\n    /**\r\n     * Commit method that takes an optional transaction ID.\r\n     *\r\n     * @private\r\n     * @param commitOptions Options to use for this commit.\r\n     * @param commitOptions.transactionId The transaction ID of this commit.\r\n     * @param commitOptions.requestTag A unique client-assigned identifier for\r\n     * this request.\r\n     * @returns  A Promise that resolves when this batch completes.\r\n     */\r\n    async _commit(commitOptions) {\r\n        var _a;\r\n        // Note: We don't call `verifyNotCommitted()` to allow for retries.\r\n        this._committed = true;\r\n        const tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag();\r\n        await this._firestore.initializeIfNeeded(tag);\r\n        // Note that the request may not always be of type ICommitRequest. This is\r\n        // just here to ensure type safety.\r\n        const request = {\r\n            database: this._firestore.formattedName,\r\n            writes: this._ops.map(op => op.op()),\r\n        };\r\n        if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\r\n            request.transaction = commitOptions.transactionId;\r\n        }\r\n        logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\r\n        return this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes);\r\n    }\r\n    /**\r\n     * Resets the WriteBatch and dequeues all pending operations.\r\n     * @private\r\n     */\r\n    _reset() {\r\n        this._ops.splice(0);\r\n        this._committed = false;\r\n    }\r\n}\r\nexports.WriteBatch = WriteBatch;\r\n/**\r\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\r\n * and 'lastUpdateTime' use valid types.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate\r\n * @param allowExists Whether to allow the 'exists' preconditions.\r\n */\r\nfunction validatePrecondition(arg, value, allowExists) {\r\n    if (typeof value !== 'object' || value === null) {\r\n        throw new Error('Input is not an object.');\r\n    }\r\n    const precondition = value;\r\n    let conditions = 0;\r\n    if (precondition.exists !== undefined) {\r\n        ++conditions;\r\n        if (!allowExists) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\r\n        }\r\n        if (typeof precondition.exists !== 'boolean') {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\r\n        }\r\n    }\r\n    if (precondition.lastUpdateTime !== undefined) {\r\n        ++conditions;\r\n        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\r\n        }\r\n    }\r\n    if (conditions > 1) {\r\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\r\n    }\r\n}\r\n/**\r\n * Validates the use of 'value' as an update Precondition.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n */\r\nfunction validateUpdatePrecondition(arg, value, options) {\r\n    if (!validate_1.validateOptional(value, options)) {\r\n        validatePrecondition(arg, value, /* allowExists= */ false);\r\n    }\r\n}\r\n/**\r\n * Validates the use of 'value' as a delete Precondition.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n */\r\nfunction validateDeletePrecondition(arg, value, options) {\r\n    if (!validate_1.validateOptional(value, options)) {\r\n        validatePrecondition(arg, value, /* allowExists= */ true);\r\n    }\r\n}\r\n/**\r\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\r\n * boolean.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The object to validate.\r\n * @param options Optional validation options specifying whether the value can\r\n * be omitted.\r\n * @throws if the input is not a valid SetOptions object.\r\n */\r\nfunction validateSetOptions(arg, value, options) {\r\n    if (!validate_1.validateOptional(value, options)) {\r\n        if (!util_1.isObject(value)) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\r\n        }\r\n        const setOptions = value;\r\n        if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\r\n        }\r\n        if ('mergeFields' in setOptions) {\r\n            if (!Array.isArray(setOptions.mergeFields)) {\r\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\r\n            }\r\n            for (let i = 0; i < setOptions.mergeFields.length; ++i) {\r\n                try {\r\n                    path_1.validateFieldPath(i, setOptions.mergeFields[i]);\r\n                }\r\n                catch (err) {\r\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\r\n                }\r\n            }\r\n        }\r\n        if ('merge' in setOptions && 'mergeFields' in setOptions) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\r\n        }\r\n    }\r\n}\r\nexports.validateSetOptions = validateSetOptions;\r\n/**\r\n * Validates a JavaScript object for usage as a Firestore document.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param obj JavaScript object to validate.\r\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @throws when the object is invalid.\r\n */\r\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\r\n    if (!util_1.isPlainObject(obj)) {\r\n        throw new Error(validate_1.customObjectMessage(arg, obj));\r\n    }\r\n    serializer_1.validateUserInput(arg, obj, 'Firestore document', {\r\n        allowDeletes: allowDeletes ? 'all' : 'none',\r\n        allowTransforms: true,\r\n        allowUndefined,\r\n    });\r\n}\r\nexports.validateDocumentData = validateDocumentData;\r\n/**\r\n * Validates that a value can be used as field value during an update.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param val The value to verify.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @param path The path to show in the error message.\r\n */\r\nfunction validateFieldValue(arg, val, allowUndefined, path) {\r\n    serializer_1.validateUserInput(arg, val, 'Firestore value', { allowDeletes: 'root', allowTransforms: true, allowUndefined }, path);\r\n}\r\nexports.validateFieldValue = validateFieldValue;\r\n/**\r\n * Validates that the update data does not contain any ambiguous field\r\n * definitions (such as 'a.b' and 'a').\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param data An update map with field/value pairs.\r\n */\r\nfunction validateNoConflictingFields(arg, data) {\r\n    const fields = [];\r\n    data.forEach((value, key) => {\r\n        fields.push(key);\r\n    });\r\n    fields.sort((left, right) => left.compareTo(right));\r\n    for (let i = 1; i < fields.length; ++i) {\r\n        if (fields[i - 1].isPrefixOf(fields[i])) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Validates that a JavaScript object is a map of field paths to field values.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param obj JavaScript object to validate.\r\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\r\n * @throws when the object is invalid.\r\n */\r\nfunction validateUpdateMap(arg, obj, allowUndefined) {\r\n    if (!util_1.isPlainObject(obj)) {\r\n        throw new Error(validate_1.customObjectMessage(arg, obj));\r\n    }\r\n    if (Object.keys(obj).length === 0) {\r\n        throw new Error('At least one field must be updated.');\r\n    }\r\n    validateFieldValue(arg, obj, allowUndefined);\r\n}\r\n//# sourceMappingURL=write-batch.js.map"]},"metadata":{},"sourceType":"script"}