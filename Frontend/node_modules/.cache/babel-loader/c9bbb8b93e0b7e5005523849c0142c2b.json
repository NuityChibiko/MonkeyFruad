{"ast":null,"code":"/**\r\n * Module dependencies.\r\n */\nvar http = require('http'),\n    IncomingMessageExt = require('../http/request'),\n    AuthenticationError = require('../errors/authenticationerror');\n/**\r\n * Authenticates requests.\r\n *\r\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\r\n * order to authenticate the request.  If authentication is successful, the user\r\n * will be logged in and populated at `req.user` and a session will be\r\n * established by default.  If authentication fails, an unauthorized response\r\n * will be sent.\r\n *\r\n * Options:\r\n *   - `session`          Save login state in session, defaults to _true_\r\n *   - `successRedirect`  After successful login, redirect to given URL\r\n *   - `successMessage`   True to store success message in\r\n *                        req.session.messages, or a string to use as override\r\n *                        message for success.\r\n *   - `successFlash`     True to flash success messages or a string to use as a flash\r\n *                        message for success (overrides any from the strategy itself).\r\n *   - `failureRedirect`  After failed login, redirect to given URL\r\n *   - `failureMessage`   True to store failure message in\r\n *                        req.session.messages, or a string to use as override\r\n *                        message for failure.\r\n *   - `failureFlash`     True to flash failure messages or a string to use as a flash\r\n *                        message for failures (overrides any from the strategy itself).\r\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\r\n *\r\n * An optional `callback` can be supplied to allow the application to override\r\n * the default manner in which authentication attempts are handled.  The\r\n * callback has the following signature, where `user` will be set to the\r\n * authenticated user on a successful authentication attempt, or `false`\r\n * otherwise.  An optional `info` argument will be passed, containing additional\r\n * details provided by the strategy's verify callback - this could be information about\r\n * a successful authentication or a challenge message for a failed authentication.\r\n * An optional `status` argument will be passed when authentication fails - this could\r\n * be a HTTP response code for a remote authentication failure or similar.\r\n *\r\n *     app.get('/protected', function(req, res, next) {\r\n *       passport.authenticate('local', function(err, user, info, status) {\r\n *         if (err) { return next(err) }\r\n *         if (!user) { return res.redirect('/signin') }\r\n *         res.redirect('/account');\r\n *       })(req, res, next);\r\n *     });\r\n *\r\n * Note that if a callback is supplied, it becomes the application's\r\n * responsibility to log-in the user, establish a session, and otherwise perform\r\n * the desired operations.\r\n *\r\n * Examples:\r\n *\r\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\r\n *\r\n *     passport.authenticate('basic', { session: false });\r\n *\r\n *     passport.authenticate('twitter');\r\n *\r\n * @param {Strategy|String|Array} name\r\n * @param {Object} options\r\n * @param {Function} callback\r\n * @return {Function}\r\n * @api public\r\n */\n\n\nmodule.exports = function authenticate(passport, name, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var multi = true; // Cast `name` to an array, allowing authentication to pass through a chain of\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n  // the chain.  Authentication failures will proceed through each strategy in\n  // series, ultimately failing if all strategies fail.\n  //\n  // This is typically used on API endpoints to allow clients to authenticate\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n  // It is not feasible to construct a chain of multiple strategies that involve\n  // redirection (for example both Facebook and Twitter), since the first one to\n  // redirect will halt the chain.\n\n  if (!Array.isArray(name)) {\n    name = [name];\n    multi = false;\n  }\n\n  return function authenticate(req, res, next) {\n    if (http.IncomingMessage.prototype.logIn && http.IncomingMessage.prototype.logIn !== IncomingMessageExt.logIn) {\n      require('../framework/connect').__monkeypatchNode();\n    } // accumulator for failures from each strategy in the chain\n\n\n    var failures = [];\n\n    function allFailed() {\n      if (callback) {\n        if (!multi) {\n          return callback(null, false, failures[0].challenge, failures[0].status);\n        } else {\n          var challenges = failures.map(function (f) {\n            return f.challenge;\n          });\n          var statuses = failures.map(function (f) {\n            return f.status;\n          });\n          return callback(null, false, challenges, statuses);\n        }\n      } // Strategies are ordered by priority.  For the purpose of flashing a\n      // message, the first failure will be displayed.\n\n\n      var failure = failures[0] || {},\n          challenge = failure.challenge || {},\n          msg;\n\n      if (options.failureFlash) {\n        var flash = options.failureFlash;\n\n        if (typeof flash == 'string') {\n          flash = {\n            type: 'error',\n            message: flash\n          };\n        }\n\n        flash.type = flash.type || 'error';\n        var type = flash.type || challenge.type || 'error';\n        msg = flash.message || challenge.message || challenge;\n\n        if (typeof msg == 'string') {\n          req.flash(type, msg);\n        }\n      }\n\n      if (options.failureMessage) {\n        msg = options.failureMessage;\n\n        if (typeof msg == 'boolean') {\n          msg = challenge.message || challenge;\n        }\n\n        if (typeof msg == 'string') {\n          req.session.messages = req.session.messages || [];\n          req.session.messages.push(msg);\n        }\n      }\n\n      if (options.failureRedirect) {\n        return res.redirect(options.failureRedirect);\n      } // When failure handling is not delegated to the application, the default\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n      // header will be set according to the strategies in use (see\n      // actions#fail).  If multiple strategies failed, each of their challenges\n      // will be included in the response.\n\n\n      var rchallenge = [],\n          rstatus,\n          status;\n\n      for (var j = 0, len = failures.length; j < len; j++) {\n        failure = failures[j];\n        challenge = failure.challenge;\n        status = failure.status;\n        rstatus = rstatus || status;\n\n        if (typeof challenge == 'string') {\n          rchallenge.push(challenge);\n        }\n      }\n\n      res.statusCode = rstatus || 401;\n\n      if (res.statusCode == 401 && rchallenge.length) {\n        res.setHeader('WWW-Authenticate', rchallenge);\n      }\n\n      if (options.failWithError) {\n        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));\n      }\n\n      res.end(http.STATUS_CODES[res.statusCode]);\n    }\n\n    (function attempt(i) {\n      var layer = name[i]; // If no more strategies exist in the chain, authentication has failed.\n\n      if (!layer) {\n        return allFailed();\n      } // Get the strategy, which will be used as prototype from which to create\n      // a new instance.  Action functions will then be bound to the strategy\n      // within the context of the HTTP request/response pair.\n\n\n      var strategy, prototype;\n\n      if (typeof layer.authenticate == 'function') {\n        strategy = layer;\n      } else {\n        prototype = passport._strategy(layer);\n\n        if (!prototype) {\n          return next(new Error('Unknown authentication strategy \"' + layer + '\"'));\n        }\n\n        strategy = Object.create(prototype);\n      } // ----- BEGIN STRATEGY AUGMENTATION -----\n      // Augment the new strategy instance with action functions.  These action\n      // functions are bound via closure the the request/response pair.  The end\n      // goal of the strategy is to invoke *one* of these action methods, in\n      // order to indicate successful or failed authentication, redirect to a\n      // third-party identity provider, etc.\n\n      /**\r\n       * Authenticate `user`, with optional `info`.\r\n       *\r\n       * Strategies should call this function to successfully authenticate a\r\n       * user.  `user` should be an object supplied by the application after it\r\n       * has been given an opportunity to verify credentials.  `info` is an\r\n       * optional argument containing additional user information.  This is\r\n       * useful for third-party authentication strategies to pass profile\r\n       * details.\r\n       *\r\n       * @param {Object} user\r\n       * @param {Object} info\r\n       * @api public\r\n       */\n\n\n      strategy.success = function (user, info) {\n        if (callback) {\n          return callback(null, user, info);\n        }\n\n        info = info || {};\n        var msg;\n\n        if (options.successFlash) {\n          var flash = options.successFlash;\n\n          if (typeof flash == 'string') {\n            flash = {\n              type: 'success',\n              message: flash\n            };\n          }\n\n          flash.type = flash.type || 'success';\n          var type = flash.type || info.type || 'success';\n          msg = flash.message || info.message || info;\n\n          if (typeof msg == 'string') {\n            req.flash(type, msg);\n          }\n        }\n\n        if (options.successMessage) {\n          msg = options.successMessage;\n\n          if (typeof msg == 'boolean') {\n            msg = info.message || info;\n          }\n\n          if (typeof msg == 'string') {\n            req.session.messages = req.session.messages || [];\n            req.session.messages.push(msg);\n          }\n        }\n\n        if (options.assignProperty) {\n          req[options.assignProperty] = user;\n          return next();\n        }\n\n        req.logIn(user, options, function (err) {\n          if (err) {\n            return next(err);\n          }\n\n          function complete() {\n            if (options.successReturnToOrRedirect) {\n              var url = options.successReturnToOrRedirect;\n\n              if (req.session && req.session.returnTo) {\n                url = req.session.returnTo;\n                delete req.session.returnTo;\n              }\n\n              return res.redirect(url);\n            }\n\n            if (options.successRedirect) {\n              return res.redirect(options.successRedirect);\n            }\n\n            next();\n          }\n\n          if (options.authInfo !== false) {\n            passport.transformAuthInfo(info, req, function (err, tinfo) {\n              if (err) {\n                return next(err);\n              }\n\n              req.authInfo = tinfo;\n              complete();\n            });\n          } else {\n            complete();\n          }\n        });\n      };\n      /**\r\n       * Fail authentication, with optional `challenge` and `status`, defaulting\r\n       * to 401.\r\n       *\r\n       * Strategies should call this function to fail an authentication attempt.\r\n       *\r\n       * @param {String} challenge\r\n       * @param {Number} status\r\n       * @api public\r\n       */\n\n\n      strategy.fail = function (challenge, status) {\n        if (typeof challenge == 'number') {\n          status = challenge;\n          challenge = undefined;\n        } // push this failure into the accumulator and attempt authentication\n        // using the next strategy\n\n\n        failures.push({\n          challenge: challenge,\n          status: status\n        });\n        attempt(i + 1);\n      };\n      /**\r\n       * Redirect to `url` with optional `status`, defaulting to 302.\r\n       *\r\n       * Strategies should call this function to redirect the user (via their\r\n       * user agent) to a third-party website for authentication.\r\n       *\r\n       * @param {String} url\r\n       * @param {Number} status\r\n       * @api public\r\n       */\n\n\n      strategy.redirect = function (url, status) {\n        // NOTE: Do not use `res.redirect` from Express, because it can't decide\n        //       what it wants.\n        //\n        //       Express 2.x: res.redirect(url, status)\n        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)\n        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)\n        //           is used\n        //       Express 4.x: res.redirect(status, url)\n        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)\n        //           but issue deprecated versions\n        res.statusCode = status || 302;\n        res.setHeader('Location', url);\n        res.setHeader('Content-Length', '0');\n        res.end();\n      };\n      /**\r\n       * Pass without making a success or fail decision.\r\n       *\r\n       * Under most circumstances, Strategies should not need to call this\r\n       * function.  It exists primarily to allow previous authentication state\r\n       * to be restored, for example from an HTTP session.\r\n       *\r\n       * @api public\r\n       */\n\n\n      strategy.pass = function () {\n        next();\n      };\n      /**\r\n       * Internal error while performing authentication.\r\n       *\r\n       * Strategies should call this function when an internal error occurs\r\n       * during the process of performing authentication; for example, if the\r\n       * user directory is not available.\r\n       *\r\n       * @param {Error} err\r\n       * @api public\r\n       */\n\n\n      strategy.error = function (err) {\n        if (callback) {\n          return callback(err);\n        }\n\n        next(err);\n      }; // ----- END STRATEGY AUGMENTATION -----\n\n\n      strategy.authenticate(req, options);\n    })(0); // attempt\n\n  };\n};","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/passport/lib/middleware/authenticate.js"],"names":["http","require","IncomingMessageExt","AuthenticationError","module","exports","authenticate","passport","name","options","callback","multi","Array","isArray","req","res","next","IncomingMessage","prototype","logIn","__monkeypatchNode","failures","allFailed","challenge","status","challenges","map","f","statuses","failure","msg","failureFlash","flash","type","message","failureMessage","session","messages","push","failureRedirect","redirect","rchallenge","rstatus","j","len","length","statusCode","setHeader","failWithError","STATUS_CODES","end","attempt","i","layer","strategy","_strategy","Error","Object","create","success","user","info","successFlash","successMessage","assignProperty","err","complete","successReturnToOrRedirect","url","returnTo","successRedirect","authInfo","transformAuthInfo","tinfo","fail","undefined","pass","error"],"mappings":"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","sourcesContent":["/**\r\n * Module dependencies.\r\n */\r\nvar http = require('http')\r\n  , IncomingMessageExt = require('../http/request')\r\n  , AuthenticationError = require('../errors/authenticationerror');\r\n\r\n\r\n/**\r\n * Authenticates requests.\r\n *\r\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\r\n * order to authenticate the request.  If authentication is successful, the user\r\n * will be logged in and populated at `req.user` and a session will be\r\n * established by default.  If authentication fails, an unauthorized response\r\n * will be sent.\r\n *\r\n * Options:\r\n *   - `session`          Save login state in session, defaults to _true_\r\n *   - `successRedirect`  After successful login, redirect to given URL\r\n *   - `successMessage`   True to store success message in\r\n *                        req.session.messages, or a string to use as override\r\n *                        message for success.\r\n *   - `successFlash`     True to flash success messages or a string to use as a flash\r\n *                        message for success (overrides any from the strategy itself).\r\n *   - `failureRedirect`  After failed login, redirect to given URL\r\n *   - `failureMessage`   True to store failure message in\r\n *                        req.session.messages, or a string to use as override\r\n *                        message for failure.\r\n *   - `failureFlash`     True to flash failure messages or a string to use as a flash\r\n *                        message for failures (overrides any from the strategy itself).\r\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\r\n *\r\n * An optional `callback` can be supplied to allow the application to override\r\n * the default manner in which authentication attempts are handled.  The\r\n * callback has the following signature, where `user` will be set to the\r\n * authenticated user on a successful authentication attempt, or `false`\r\n * otherwise.  An optional `info` argument will be passed, containing additional\r\n * details provided by the strategy's verify callback - this could be information about\r\n * a successful authentication or a challenge message for a failed authentication.\r\n * An optional `status` argument will be passed when authentication fails - this could\r\n * be a HTTP response code for a remote authentication failure or similar.\r\n *\r\n *     app.get('/protected', function(req, res, next) {\r\n *       passport.authenticate('local', function(err, user, info, status) {\r\n *         if (err) { return next(err) }\r\n *         if (!user) { return res.redirect('/signin') }\r\n *         res.redirect('/account');\r\n *       })(req, res, next);\r\n *     });\r\n *\r\n * Note that if a callback is supplied, it becomes the application's\r\n * responsibility to log-in the user, establish a session, and otherwise perform\r\n * the desired operations.\r\n *\r\n * Examples:\r\n *\r\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\r\n *\r\n *     passport.authenticate('basic', { session: false });\r\n *\r\n *     passport.authenticate('twitter');\r\n *\r\n * @param {Strategy|String|Array} name\r\n * @param {Object} options\r\n * @param {Function} callback\r\n * @return {Function}\r\n * @api public\r\n */\r\nmodule.exports = function authenticate(passport, name, options, callback) {\r\n  if (typeof options == 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n  options = options || {};\r\n  \r\n  var multi = true;\r\n  \r\n  // Cast `name` to an array, allowing authentication to pass through a chain of\r\n  // strategies.  The first strategy to succeed, redirect, or error will halt\r\n  // the chain.  Authentication failures will proceed through each strategy in\r\n  // series, ultimately failing if all strategies fail.\r\n  //\r\n  // This is typically used on API endpoints to allow clients to authenticate\r\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\r\n  // It is not feasible to construct a chain of multiple strategies that involve\r\n  // redirection (for example both Facebook and Twitter), since the first one to\r\n  // redirect will halt the chain.\r\n  if (!Array.isArray(name)) {\r\n    name = [ name ];\r\n    multi = false;\r\n  }\r\n  \r\n  return function authenticate(req, res, next) {\r\n    if (http.IncomingMessage.prototype.logIn\r\n        && http.IncomingMessage.prototype.logIn !== IncomingMessageExt.logIn) {\r\n      require('../framework/connect').__monkeypatchNode();\r\n    }\r\n    \r\n    \r\n    // accumulator for failures from each strategy in the chain\r\n    var failures = [];\r\n    \r\n    function allFailed() {\r\n      if (callback) {\r\n        if (!multi) {\r\n          return callback(null, false, failures[0].challenge, failures[0].status);\r\n        } else {\r\n          var challenges = failures.map(function(f) { return f.challenge; });\r\n          var statuses = failures.map(function(f) { return f.status; });\r\n          return callback(null, false, challenges, statuses);\r\n        }\r\n      }\r\n      \r\n      // Strategies are ordered by priority.  For the purpose of flashing a\r\n      // message, the first failure will be displayed.\r\n      var failure = failures[0] || {}\r\n        , challenge = failure.challenge || {}\r\n        , msg;\r\n    \r\n      if (options.failureFlash) {\r\n        var flash = options.failureFlash;\r\n        if (typeof flash == 'string') {\r\n          flash = { type: 'error', message: flash };\r\n        }\r\n        flash.type = flash.type || 'error';\r\n      \r\n        var type = flash.type || challenge.type || 'error';\r\n        msg = flash.message || challenge.message || challenge;\r\n        if (typeof msg == 'string') {\r\n          req.flash(type, msg);\r\n        }\r\n      }\r\n      if (options.failureMessage) {\r\n        msg = options.failureMessage;\r\n        if (typeof msg == 'boolean') {\r\n          msg = challenge.message || challenge;\r\n        }\r\n        if (typeof msg == 'string') {\r\n          req.session.messages = req.session.messages || [];\r\n          req.session.messages.push(msg);\r\n        }\r\n      }\r\n      if (options.failureRedirect) {\r\n        return res.redirect(options.failureRedirect);\r\n      }\r\n    \r\n      // When failure handling is not delegated to the application, the default\r\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\r\n      // header will be set according to the strategies in use (see\r\n      // actions#fail).  If multiple strategies failed, each of their challenges\r\n      // will be included in the response.\r\n      var rchallenge = []\r\n        , rstatus, status;\r\n      \r\n      for (var j = 0, len = failures.length; j < len; j++) {\r\n        failure = failures[j];\r\n        challenge = failure.challenge;\r\n        status = failure.status;\r\n          \r\n        rstatus = rstatus || status;\r\n        if (typeof challenge == 'string') {\r\n          rchallenge.push(challenge);\r\n        }\r\n      }\r\n    \r\n      res.statusCode = rstatus || 401;\r\n      if (res.statusCode == 401 && rchallenge.length) {\r\n        res.setHeader('WWW-Authenticate', rchallenge);\r\n      }\r\n      if (options.failWithError) {\r\n        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));\r\n      }\r\n      res.end(http.STATUS_CODES[res.statusCode]);\r\n    }\r\n    \r\n    (function attempt(i) {\r\n      var layer = name[i];\r\n      // If no more strategies exist in the chain, authentication has failed.\r\n      if (!layer) { return allFailed(); }\r\n    \r\n      // Get the strategy, which will be used as prototype from which to create\r\n      // a new instance.  Action functions will then be bound to the strategy\r\n      // within the context of the HTTP request/response pair.\r\n      var strategy, prototype;\r\n      if (typeof layer.authenticate == 'function') {\r\n        strategy = layer;\r\n      } else {\r\n        prototype = passport._strategy(layer);\r\n        if (!prototype) { return next(new Error('Unknown authentication strategy \"' + layer + '\"')); }\r\n        \r\n        strategy = Object.create(prototype);\r\n      }\r\n      \r\n      \r\n      // ----- BEGIN STRATEGY AUGMENTATION -----\r\n      // Augment the new strategy instance with action functions.  These action\r\n      // functions are bound via closure the the request/response pair.  The end\r\n      // goal of the strategy is to invoke *one* of these action methods, in\r\n      // order to indicate successful or failed authentication, redirect to a\r\n      // third-party identity provider, etc.\r\n      \r\n      /**\r\n       * Authenticate `user`, with optional `info`.\r\n       *\r\n       * Strategies should call this function to successfully authenticate a\r\n       * user.  `user` should be an object supplied by the application after it\r\n       * has been given an opportunity to verify credentials.  `info` is an\r\n       * optional argument containing additional user information.  This is\r\n       * useful for third-party authentication strategies to pass profile\r\n       * details.\r\n       *\r\n       * @param {Object} user\r\n       * @param {Object} info\r\n       * @api public\r\n       */\r\n      strategy.success = function(user, info) {\r\n        if (callback) {\r\n          return callback(null, user, info);\r\n        }\r\n      \r\n        info = info || {};\r\n        var msg;\r\n      \r\n        if (options.successFlash) {\r\n          var flash = options.successFlash;\r\n          if (typeof flash == 'string') {\r\n            flash = { type: 'success', message: flash };\r\n          }\r\n          flash.type = flash.type || 'success';\r\n        \r\n          var type = flash.type || info.type || 'success';\r\n          msg = flash.message || info.message || info;\r\n          if (typeof msg == 'string') {\r\n            req.flash(type, msg);\r\n          }\r\n        }\r\n        if (options.successMessage) {\r\n          msg = options.successMessage;\r\n          if (typeof msg == 'boolean') {\r\n            msg = info.message || info;\r\n          }\r\n          if (typeof msg == 'string') {\r\n            req.session.messages = req.session.messages || [];\r\n            req.session.messages.push(msg);\r\n          }\r\n        }\r\n        if (options.assignProperty) {\r\n          req[options.assignProperty] = user;\r\n          return next();\r\n        }\r\n      \r\n        req.logIn(user, options, function(err) {\r\n          if (err) { return next(err); }\r\n          \r\n          function complete() {\r\n            if (options.successReturnToOrRedirect) {\r\n              var url = options.successReturnToOrRedirect;\r\n              if (req.session && req.session.returnTo) {\r\n                url = req.session.returnTo;\r\n                delete req.session.returnTo;\r\n              }\r\n              return res.redirect(url);\r\n            }\r\n            if (options.successRedirect) {\r\n              return res.redirect(options.successRedirect);\r\n            }\r\n            next();\r\n          }\r\n          \r\n          if (options.authInfo !== false) {\r\n            passport.transformAuthInfo(info, req, function(err, tinfo) {\r\n              if (err) { return next(err); }\r\n              req.authInfo = tinfo;\r\n              complete();\r\n            });\r\n          } else {\r\n            complete();\r\n          }\r\n        });\r\n      };\r\n      \r\n      /**\r\n       * Fail authentication, with optional `challenge` and `status`, defaulting\r\n       * to 401.\r\n       *\r\n       * Strategies should call this function to fail an authentication attempt.\r\n       *\r\n       * @param {String} challenge\r\n       * @param {Number} status\r\n       * @api public\r\n       */\r\n      strategy.fail = function(challenge, status) {\r\n        if (typeof challenge == 'number') {\r\n          status = challenge;\r\n          challenge = undefined;\r\n        }\r\n        \r\n        // push this failure into the accumulator and attempt authentication\r\n        // using the next strategy\r\n        failures.push({ challenge: challenge, status: status });\r\n        attempt(i + 1);\r\n      };\r\n      \r\n      /**\r\n       * Redirect to `url` with optional `status`, defaulting to 302.\r\n       *\r\n       * Strategies should call this function to redirect the user (via their\r\n       * user agent) to a third-party website for authentication.\r\n       *\r\n       * @param {String} url\r\n       * @param {Number} status\r\n       * @api public\r\n       */\r\n      strategy.redirect = function(url, status) {\r\n        // NOTE: Do not use `res.redirect` from Express, because it can't decide\r\n        //       what it wants.\r\n        //\r\n        //       Express 2.x: res.redirect(url, status)\r\n        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)\r\n        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)\r\n        //           is used\r\n        //       Express 4.x: res.redirect(status, url)\r\n        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)\r\n        //           but issue deprecated versions\r\n        \r\n        res.statusCode = status || 302;\r\n        res.setHeader('Location', url);\r\n        res.setHeader('Content-Length', '0');\r\n        res.end();\r\n      };\r\n      \r\n      /**\r\n       * Pass without making a success or fail decision.\r\n       *\r\n       * Under most circumstances, Strategies should not need to call this\r\n       * function.  It exists primarily to allow previous authentication state\r\n       * to be restored, for example from an HTTP session.\r\n       *\r\n       * @api public\r\n       */\r\n      strategy.pass = function() {\r\n        next();\r\n      };\r\n      \r\n      /**\r\n       * Internal error while performing authentication.\r\n       *\r\n       * Strategies should call this function when an internal error occurs\r\n       * during the process of performing authentication; for example, if the\r\n       * user directory is not available.\r\n       *\r\n       * @param {Error} err\r\n       * @api public\r\n       */\r\n      strategy.error = function(err) {\r\n        if (callback) {\r\n          return callback(err);\r\n        }\r\n        \r\n        next(err);\r\n      };\r\n      \r\n      // ----- END STRATEGY AUGMENTATION -----\r\n    \r\n      strategy.authenticate(req, options);\r\n    })(0); // attempt\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}