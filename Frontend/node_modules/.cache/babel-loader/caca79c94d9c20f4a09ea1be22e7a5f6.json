{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Task = exports.deepCopyForResponse = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n/**\r\n * Creates a deep copy of the object with the consideration of subresponse\r\n * fields for bundling.\r\n *\r\n * @param {Object} obj - The source object.\r\n * @param {Object?} subresponseInfo - The information to copy the subset of\r\n *   the field for the response. Do nothing if it's null.\r\n * @param {String} subresponseInfo.field - The field name.\r\n * @param {number} subresponseInfo.start - The offset where the copying\r\n *   element should starts with.\r\n * @param {number} subresponseInfo.end - The ending index where the copying\r\n *   region of the elements ends.\r\n * @return {Object} The copied object.\r\n * @private\r\n */\n\n\nfunction deepCopyForResponse( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nobj, subresponseInfo) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let result;\n\n  if (obj === null) {\n    return null;\n  }\n\n  if (obj === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(obj)) {\n    result = [];\n    obj.forEach(element => {\n      result.push(deepCopyForResponse(element, null));\n    });\n    return result;\n  } // Some objects (such as ByteBuffer) have copy method.\n\n\n  if (obj.copy !== undefined) {\n    return obj.copy();\n  } // ArrayBuffer should be copied through slice().\n\n\n  if (obj instanceof ArrayBuffer) {\n    return obj.slice(0);\n  }\n\n  if (typeof obj === 'object') {\n    result = {};\n    Object.keys(obj).forEach(key => {\n      if (subresponseInfo && key === subresponseInfo.field && Array.isArray(obj[key])) {\n        // Note that subresponses are not deep-copied. This is safe because\n        // those subresponses are not shared among callbacks.\n        result[key] = obj[key].slice(subresponseInfo.start, subresponseInfo.end);\n      } else {\n        result[key] = deepCopyForResponse(obj[key], null);\n      }\n    });\n    return result;\n  }\n\n  return obj;\n}\n\nexports.deepCopyForResponse = deepCopyForResponse;\n\nclass Task {\n  /**\r\n   * A task coordinates the execution of a single bundle.\r\n   *\r\n   * @param {function} apiCall - The function to conduct calling API.\r\n   * @param {Object} bundlingRequest - The base request object to be used\r\n   *   for the actual API call.\r\n   * @param {string} bundledField - The name of the field in bundlingRequest\r\n   *   to be bundled.\r\n   * @param {string=} subresponseField - The name of the field in the response\r\n   *   to be passed to the callback.\r\n   * @constructor\r\n   * @private\r\n   */\n  constructor(apiCall, bundlingRequest, bundledField, subresponseField) {\n    this._apiCall = apiCall;\n    this._request = bundlingRequest;\n    this._bundledField = bundledField;\n    this._subresponseField = subresponseField;\n    this._data = [];\n  }\n  /**\r\n   * Returns the number of elements in a task.\r\n   * @return {number} The number of elements.\r\n   */\n\n\n  getElementCount() {\n    let count = 0;\n\n    for (let i = 0; i < this._data.length; ++i) {\n      count += this._data[i].elements.length;\n    }\n\n    return count;\n  }\n  /**\r\n   * Returns the total byte size of the elements in a task.\r\n   * @return {number} The byte size.\r\n   */\n\n\n  getRequestByteSize() {\n    let size = 0;\n\n    for (let i = 0; i < this._data.length; ++i) {\n      size += this._data[i].bytes;\n    }\n\n    return size;\n  }\n  /**\r\n   * Invokes the actual API call with current elements.\r\n   * @return {string[]} - the list of ids for invocations to be run.\r\n   */\n\n\n  run() {\n    if (this._data.length === 0) {\n      return [];\n    }\n\n    const request = this._request;\n    const elements = [];\n    const ids = [];\n\n    for (let i = 0; i < this._data.length; ++i) {\n      elements.push(...this._data[i].elements);\n      ids.push(this._data[i].callback.id);\n    }\n\n    request[this._bundledField] = elements; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const self = this;\n    this.callCanceller = this._apiCall(request, (err, response) => {\n      const responses = [];\n\n      if (err) {\n        self._data.forEach(() => {\n          responses.push(undefined);\n        });\n      } else {\n        let subresponseInfo = null;\n\n        if (self._subresponseField) {\n          subresponseInfo = {\n            field: self._subresponseField,\n            start: 0\n          };\n        }\n\n        self._data.forEach(data => {\n          if (subresponseInfo) {\n            subresponseInfo.end = subresponseInfo.start + data.elements.length;\n          }\n\n          responses.push(deepCopyForResponse(response, subresponseInfo));\n\n          if (subresponseInfo) {\n            subresponseInfo.start = subresponseInfo.end;\n          }\n        });\n      }\n\n      for (let i = 0; i < self._data.length; ++i) {\n        if (self._data[i].cancelled) {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n\n          self._data[i].callback(error);\n        } else {\n          self._data[i].callback(err, responses[i]);\n        }\n      }\n    });\n    return ids;\n  }\n  /**\r\n   * Appends the list of elements into the task.\r\n   * @param {Object[]} elements - the new list of elements.\r\n   * @param {number} bytes - the byte size required to encode elements in the API.\r\n   * @param {APICallback} callback - the callback of the method call.\r\n   */\n\n\n  extend(elements, bytes, callback) {\n    this._data.push({\n      elements,\n      bytes,\n      callback\n    });\n  }\n  /**\r\n   * Cancels a part of elements.\r\n   * @param {string} id - The identifier of the part of elements.\r\n   * @return {boolean} Whether the entire task will be canceled or not.\r\n   */\n\n\n  cancel(id) {\n    if (this.callCanceller) {\n      let allCancelled = true;\n\n      this._data.forEach(d => {\n        if (d.callback.id === id) {\n          d.cancelled = true;\n        }\n\n        if (!d.cancelled) {\n          allCancelled = false;\n        }\n      });\n\n      if (allCancelled) {\n        this.callCanceller.cancel();\n      }\n\n      return allCancelled;\n    }\n\n    for (let i = 0; i < this._data.length; ++i) {\n      if (this._data[i].callback.id === id) {\n        const error = new googleError_1.GoogleError('cancelled');\n        error.code = status_1.Status.CANCELLED;\n\n        this._data[i].callback(error);\n\n        this._data.splice(i, 1);\n\n        break;\n      }\n    }\n\n    return this._data.length === 0;\n  }\n\n}\n\nexports.Task = Task;","map":{"version":3,"sources":["../../../src/bundlingCalls/task.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Task = exports.deepCopyForResponse = void 0;\r\nconst status_1 = require(\"../status\");\r\nconst googleError_1 = require(\"../googleError\");\r\n/**\r\n * Creates a deep copy of the object with the consideration of subresponse\r\n * fields for bundling.\r\n *\r\n * @param {Object} obj - The source object.\r\n * @param {Object?} subresponseInfo - The information to copy the subset of\r\n *   the field for the response. Do nothing if it's null.\r\n * @param {String} subresponseInfo.field - The field name.\r\n * @param {number} subresponseInfo.start - The offset where the copying\r\n *   element should starts with.\r\n * @param {number} subresponseInfo.end - The ending index where the copying\r\n *   region of the elements ends.\r\n * @return {Object} The copied object.\r\n * @private\r\n */\r\nfunction deepCopyForResponse(\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nobj, subresponseInfo) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let result;\r\n    if (obj === null) {\r\n        return null;\r\n    }\r\n    if (obj === undefined) {\r\n        return undefined;\r\n    }\r\n    if (Array.isArray(obj)) {\r\n        result = [];\r\n        obj.forEach(element => {\r\n            result.push(deepCopyForResponse(element, null));\r\n        });\r\n        return result;\r\n    }\r\n    // Some objects (such as ByteBuffer) have copy method.\r\n    if (obj.copy !== undefined) {\r\n        return obj.copy();\r\n    }\r\n    // ArrayBuffer should be copied through slice().\r\n    if (obj instanceof ArrayBuffer) {\r\n        return obj.slice(0);\r\n    }\r\n    if (typeof obj === 'object') {\r\n        result = {};\r\n        Object.keys(obj).forEach(key => {\r\n            if (subresponseInfo &&\r\n                key === subresponseInfo.field &&\r\n                Array.isArray(obj[key])) {\r\n                // Note that subresponses are not deep-copied. This is safe because\r\n                // those subresponses are not shared among callbacks.\r\n                result[key] = obj[key].slice(subresponseInfo.start, subresponseInfo.end);\r\n            }\r\n            else {\r\n                result[key] = deepCopyForResponse(obj[key], null);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    return obj;\r\n}\r\nexports.deepCopyForResponse = deepCopyForResponse;\r\nclass Task {\r\n    /**\r\n     * A task coordinates the execution of a single bundle.\r\n     *\r\n     * @param {function} apiCall - The function to conduct calling API.\r\n     * @param {Object} bundlingRequest - The base request object to be used\r\n     *   for the actual API call.\r\n     * @param {string} bundledField - The name of the field in bundlingRequest\r\n     *   to be bundled.\r\n     * @param {string=} subresponseField - The name of the field in the response\r\n     *   to be passed to the callback.\r\n     * @constructor\r\n     * @private\r\n     */\r\n    constructor(apiCall, bundlingRequest, bundledField, subresponseField) {\r\n        this._apiCall = apiCall;\r\n        this._request = bundlingRequest;\r\n        this._bundledField = bundledField;\r\n        this._subresponseField = subresponseField;\r\n        this._data = [];\r\n    }\r\n    /**\r\n     * Returns the number of elements in a task.\r\n     * @return {number} The number of elements.\r\n     */\r\n    getElementCount() {\r\n        let count = 0;\r\n        for (let i = 0; i < this._data.length; ++i) {\r\n            count += this._data[i].elements.length;\r\n        }\r\n        return count;\r\n    }\r\n    /**\r\n     * Returns the total byte size of the elements in a task.\r\n     * @return {number} The byte size.\r\n     */\r\n    getRequestByteSize() {\r\n        let size = 0;\r\n        for (let i = 0; i < this._data.length; ++i) {\r\n            size += this._data[i].bytes;\r\n        }\r\n        return size;\r\n    }\r\n    /**\r\n     * Invokes the actual API call with current elements.\r\n     * @return {string[]} - the list of ids for invocations to be run.\r\n     */\r\n    run() {\r\n        if (this._data.length === 0) {\r\n            return [];\r\n        }\r\n        const request = this._request;\r\n        const elements = [];\r\n        const ids = [];\r\n        for (let i = 0; i < this._data.length; ++i) {\r\n            elements.push(...this._data[i].elements);\r\n            ids.push(this._data[i].callback.id);\r\n        }\r\n        request[this._bundledField] = elements;\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        this.callCanceller = this._apiCall(request, (err, response) => {\r\n            const responses = [];\r\n            if (err) {\r\n                self._data.forEach(() => {\r\n                    responses.push(undefined);\r\n                });\r\n            }\r\n            else {\r\n                let subresponseInfo = null;\r\n                if (self._subresponseField) {\r\n                    subresponseInfo = {\r\n                        field: self._subresponseField,\r\n                        start: 0,\r\n                    };\r\n                }\r\n                self._data.forEach(data => {\r\n                    if (subresponseInfo) {\r\n                        subresponseInfo.end =\r\n                            subresponseInfo.start + data.elements.length;\r\n                    }\r\n                    responses.push(deepCopyForResponse(response, subresponseInfo));\r\n                    if (subresponseInfo) {\r\n                        subresponseInfo.start = subresponseInfo.end;\r\n                    }\r\n                });\r\n            }\r\n            for (let i = 0; i < self._data.length; ++i) {\r\n                if (self._data[i].cancelled) {\r\n                    const error = new googleError_1.GoogleError('cancelled');\r\n                    error.code = status_1.Status.CANCELLED;\r\n                    self._data[i].callback(error);\r\n                }\r\n                else {\r\n                    self._data[i].callback(err, responses[i]);\r\n                }\r\n            }\r\n        });\r\n        return ids;\r\n    }\r\n    /**\r\n     * Appends the list of elements into the task.\r\n     * @param {Object[]} elements - the new list of elements.\r\n     * @param {number} bytes - the byte size required to encode elements in the API.\r\n     * @param {APICallback} callback - the callback of the method call.\r\n     */\r\n    extend(elements, bytes, callback) {\r\n        this._data.push({\r\n            elements,\r\n            bytes,\r\n            callback,\r\n        });\r\n    }\r\n    /**\r\n     * Cancels a part of elements.\r\n     * @param {string} id - The identifier of the part of elements.\r\n     * @return {boolean} Whether the entire task will be canceled or not.\r\n     */\r\n    cancel(id) {\r\n        if (this.callCanceller) {\r\n            let allCancelled = true;\r\n            this._data.forEach(d => {\r\n                if (d.callback.id === id) {\r\n                    d.cancelled = true;\r\n                }\r\n                if (!d.cancelled) {\r\n                    allCancelled = false;\r\n                }\r\n            });\r\n            if (allCancelled) {\r\n                this.callCanceller.cancel();\r\n            }\r\n            return allCancelled;\r\n        }\r\n        for (let i = 0; i < this._data.length; ++i) {\r\n            if (this._data[i].callback.id === id) {\r\n                const error = new googleError_1.GoogleError('cancelled');\r\n                error.code = status_1.Status.CANCELLED;\r\n                this._data[i].callback(error);\r\n                this._data.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        return this._data.length === 0;\r\n    }\r\n}\r\nexports.Task = Task;\r\n//# sourceMappingURL=task.js.map"]},"metadata":{},"sourceType":"script"}