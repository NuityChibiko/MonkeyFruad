{"ast":null,"code":"\"use strict\";\n\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n  \"0\": \"\\0\",\n  \"r\": \"\\r\",\n  \"n\": \"\\n\",\n  \"t\": \"\\t\"\n};\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\n\nfunction unescape(str) {\n  return str.replace(unescapeRe, function ($0, $1) {\n    switch ($1) {\n      case \"\\\\\":\n      case \"\":\n        return $1;\n\n      default:\n        return unescapeMap[$1] || \"\";\n    }\n  });\n}\n\ntokenize.unescape = unescape;\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\n\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\n\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\n\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\n\nfunction tokenize(source, alternateCommentMode) {\n  /* eslint-disable callback-return */\n  source = source.toString();\n  var offset = 0,\n      length = source.length,\n      line = 1,\n      commentType = null,\n      commentText = null,\n      commentLine = 0,\n      commentLineEmpty = false,\n      commentIsLeading = false;\n  var stack = [];\n  var stringDelim = null;\n  /* istanbul ignore next */\n\n  /**\r\n   * Creates an error for illegal syntax.\r\n   * @param {string} subject Subject\r\n   * @returns {Error} Error created\r\n   * @inner\r\n   */\n\n  function illegal(subject) {\n    return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n  }\n  /**\r\n   * Reads a string till its end.\r\n   * @returns {string} String read\r\n   * @inner\r\n   */\n\n\n  function readString() {\n    var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n    re.lastIndex = offset - 1;\n    var match = re.exec(source);\n    if (!match) throw illegal(\"string\");\n    offset = re.lastIndex;\n    push(stringDelim);\n    stringDelim = null;\n    return unescape(match[1]);\n  }\n  /**\r\n   * Gets the character at `pos` within the source.\r\n   * @param {number} pos Position\r\n   * @returns {string} Character\r\n   * @inner\r\n   */\n\n\n  function charAt(pos) {\n    return source.charAt(pos);\n  }\n  /**\r\n   * Sets the current comment text.\r\n   * @param {number} start Start offset\r\n   * @param {number} end End offset\r\n   * @param {boolean} isLeading set if a leading comment\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n\n\n  function setComment(start, end, isLeading) {\n    commentType = source.charAt(start++);\n    commentLine = line;\n    commentLineEmpty = false;\n    commentIsLeading = isLeading;\n    var lookback;\n\n    if (alternateCommentMode) {\n      lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n    } else {\n      lookback = 3; // \"///\" or \"/**\"\n    }\n\n    var commentOffset = start - lookback,\n        c;\n\n    do {\n      if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n        commentLineEmpty = true;\n        break;\n      }\n    } while (c === \" \" || c === \"\\t\");\n\n    var lines = source.substring(start, end).split(setCommentSplitRe);\n\n    for (var i = 0; i < lines.length; ++i) lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n\n    commentText = lines.join(\"\\n\").trim();\n  }\n\n  function isDoubleSlashCommentLine(startOffset) {\n    var endOffset = findEndOfLine(startOffset); // see if remaining line matches comment pattern\n\n    var lineText = source.substring(startOffset, endOffset); // look for 1 or 2 slashes since startOffset would already point past\n    // the first slash that started the comment.\n\n    var isComment = /^\\s*\\/{1,2}/.test(lineText);\n    return isComment;\n  }\n\n  function findEndOfLine(cursor) {\n    // find end of cursor's line\n    var endOffset = cursor;\n\n    while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n      endOffset++;\n    }\n\n    return endOffset;\n  }\n  /**\r\n   * Obtains the next token.\r\n   * @returns {string|null} Next token or `null` on eof\r\n   * @inner\r\n   */\n\n\n  function next() {\n    if (stack.length > 0) return stack.shift();\n    if (stringDelim) return readString();\n    var repeat,\n        prev,\n        curr,\n        start,\n        isDoc,\n        isLeadingComment = offset === 0;\n\n    do {\n      if (offset === length) return null;\n      repeat = false;\n\n      while (whitespaceRe.test(curr = charAt(offset))) {\n        if (curr === \"\\n\") {\n          isLeadingComment = true;\n          ++line;\n        }\n\n        if (++offset === length) return null;\n      }\n\n      if (charAt(offset) === \"/\") {\n        if (++offset === length) {\n          throw illegal(\"comment\");\n        }\n\n        if (charAt(offset) === \"/\") {\n          // Line\n          if (!alternateCommentMode) {\n            // check for triple-slash comment\n            isDoc = charAt(start = offset + 1) === \"/\";\n\n            while (charAt(++offset) !== \"\\n\") {\n              if (offset === length) {\n                return null;\n              }\n            }\n\n            ++offset;\n\n            if (isDoc) {\n              setComment(start, offset - 1, isLeadingComment);\n            }\n\n            ++line;\n            repeat = true;\n          } else {\n            // check for double-slash comments, consolidating consecutive lines\n            start = offset;\n            isDoc = false;\n\n            if (isDoubleSlashCommentLine(offset)) {\n              isDoc = true;\n\n              do {\n                offset = findEndOfLine(offset);\n\n                if (offset === length) {\n                  break;\n                }\n\n                offset++;\n              } while (isDoubleSlashCommentLine(offset));\n            } else {\n              offset = Math.min(length, findEndOfLine(offset) + 1);\n            }\n\n            if (isDoc) {\n              setComment(start, offset, isLeadingComment);\n            }\n\n            line++;\n            repeat = true;\n          }\n        } else if ((curr = charAt(offset)) === \"*\") {\n          /* Block */\n          // check for /** (regular comment mode) or /* (alternate comment mode)\n          start = offset + 1;\n          isDoc = alternateCommentMode || charAt(start) === \"*\";\n\n          do {\n            if (curr === \"\\n\") {\n              ++line;\n            }\n\n            if (++offset === length) {\n              throw illegal(\"comment\");\n            }\n\n            prev = curr;\n            curr = charAt(offset);\n          } while (prev !== \"*\" || curr !== \"/\");\n\n          ++offset;\n\n          if (isDoc) {\n            setComment(start, offset - 2, isLeadingComment);\n          }\n\n          repeat = true;\n        } else {\n          return \"/\";\n        }\n      }\n    } while (repeat); // offset !== length if we got here\n\n\n    var end = offset;\n    delimRe.lastIndex = 0;\n    var delim = delimRe.test(charAt(end++));\n    if (!delim) while (end < length && !delimRe.test(charAt(end))) ++end;\n    var token = source.substring(offset, offset = end);\n    if (token === \"\\\"\" || token === \"'\") stringDelim = token;\n    return token;\n  }\n  /**\r\n   * Pushes a token back to the stack.\r\n   * @param {string} token Token\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n\n\n  function push(token) {\n    stack.push(token);\n  }\n  /**\r\n   * Peeks for the next token.\r\n   * @returns {string|null} Token or `null` on eof\r\n   * @inner\r\n   */\n\n\n  function peek() {\n    if (!stack.length) {\n      var token = next();\n      if (token === null) return null;\n      push(token);\n    }\n\n    return stack[0];\n  }\n  /**\r\n   * Skips a token.\r\n   * @param {string} expected Expected token\r\n   * @param {boolean} [optional=false] Whether the token is optional\r\n   * @returns {boolean} `true` when skipped, `false` if not\r\n   * @throws {Error} When a required token is not present\r\n   * @inner\r\n   */\n\n\n  function skip(expected, optional) {\n    var actual = peek(),\n        equals = actual === expected;\n\n    if (equals) {\n      next();\n      return true;\n    }\n\n    if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n    return false;\n  }\n  /**\r\n   * Gets a comment.\r\n   * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n   * @returns {string|null} Comment text\r\n   * @inner\r\n   */\n\n\n  function cmnt(trailingLine) {\n    var ret = null;\n\n    if (trailingLine === undefined) {\n      if (commentLine === line - 1 && (alternateCommentMode || commentType === \"*\" || commentLineEmpty)) {\n        ret = commentIsLeading ? commentText : null;\n      }\n    } else {\n      /* istanbul ignore else */\n      if (commentLine < trailingLine) {\n        peek();\n      }\n\n      if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === \"/\")) {\n        ret = commentIsLeading ? null : commentText;\n      }\n    }\n\n    return ret;\n  }\n\n  return Object.defineProperty({\n    next: next,\n    peek: peek,\n    push: push,\n    skip: skip,\n    cmnt: cmnt\n  }, \"line\", {\n    get: function () {\n      return line;\n    }\n  });\n  /* eslint-enable callback-return */\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/protobufjs/src/tokenize.js"],"names":["module","exports","tokenize","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","unescape","str","replace","$0","$1","source","alternateCommentMode","toString","offset","length","line","commentType","commentText","commentLine","commentLineEmpty","commentIsLeading","stack","stringDelim","illegal","subject","Error","readString","re","lastIndex","match","exec","push","charAt","pos","setComment","start","end","isLeading","lookback","commentOffset","c","lines","substring","split","i","trim","join","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","isComment","test","cursor","next","shift","repeat","prev","curr","isDoc","isLeadingComment","Math","min","delim","token","peek","skip","expected","optional","actual","equals","cmnt","trailingLine","ret","undefined","Object","defineProperty","get"],"mappings":"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","sourcesContent":["\"use strict\";\r\nmodule.exports = tokenize;\r\n\r\nvar delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\r\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\r\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\r\n\r\nvar setCommentRe = /^ *[*/]+ */,\r\n    setCommentAltRe = /^\\s*\\*?\\/*/,\r\n    setCommentSplitRe = /\\n/g,\r\n    whitespaceRe = /\\s/,\r\n    unescapeRe = /\\\\(.?)/g;\r\n\r\nvar unescapeMap = {\r\n    \"0\": \"\\0\",\r\n    \"r\": \"\\r\",\r\n    \"n\": \"\\n\",\r\n    \"t\": \"\\t\"\r\n};\r\n\r\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\r\nfunction unescape(str) {\r\n    return str.replace(unescapeRe, function($0, $1) {\r\n        switch ($1) {\r\n            case \"\\\\\":\r\n            case \"\":\r\n                return $1;\r\n            default:\r\n                return unescapeMap[$1] || \"\";\r\n        }\r\n    });\r\n}\r\n\r\ntokenize.unescape = unescape;\r\n\r\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\r\n\r\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\r\n\r\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\r\n\r\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\r\n\r\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\r\nfunction tokenize(source, alternateCommentMode) {\r\n    /* eslint-disable callback-return */\r\n    source = source.toString();\r\n\r\n    var offset = 0,\r\n        length = source.length,\r\n        line = 1,\r\n        commentType = null,\r\n        commentText = null,\r\n        commentLine = 0,\r\n        commentLineEmpty = false,\r\n        commentIsLeading = false;\r\n\r\n    var stack = [];\r\n\r\n    var stringDelim = null;\r\n\r\n    /* istanbul ignore next */\r\n    /**\r\n     * Creates an error for illegal syntax.\r\n     * @param {string} subject Subject\r\n     * @returns {Error} Error created\r\n     * @inner\r\n     */\r\n    function illegal(subject) {\r\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\r\n    }\r\n\r\n    /**\r\n     * Reads a string till its end.\r\n     * @returns {string} String read\r\n     * @inner\r\n     */\r\n    function readString() {\r\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\r\n        re.lastIndex = offset - 1;\r\n        var match = re.exec(source);\r\n        if (!match)\r\n            throw illegal(\"string\");\r\n        offset = re.lastIndex;\r\n        push(stringDelim);\r\n        stringDelim = null;\r\n        return unescape(match[1]);\r\n    }\r\n\r\n    /**\r\n     * Gets the character at `pos` within the source.\r\n     * @param {number} pos Position\r\n     * @returns {string} Character\r\n     * @inner\r\n     */\r\n    function charAt(pos) {\r\n        return source.charAt(pos);\r\n    }\r\n\r\n    /**\r\n     * Sets the current comment text.\r\n     * @param {number} start Start offset\r\n     * @param {number} end End offset\r\n     * @param {boolean} isLeading set if a leading comment\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function setComment(start, end, isLeading) {\r\n        commentType = source.charAt(start++);\r\n        commentLine = line;\r\n        commentLineEmpty = false;\r\n        commentIsLeading = isLeading;\r\n        var lookback;\r\n        if (alternateCommentMode) {\r\n            lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\r\n        } else {\r\n            lookback = 3;  // \"///\" or \"/**\"\r\n        }\r\n        var commentOffset = start - lookback,\r\n            c;\r\n        do {\r\n            if (--commentOffset < 0 ||\r\n                    (c = source.charAt(commentOffset)) === \"\\n\") {\r\n                commentLineEmpty = true;\r\n                break;\r\n            }\r\n        } while (c === \" \" || c === \"\\t\");\r\n        var lines = source\r\n            .substring(start, end)\r\n            .split(setCommentSplitRe);\r\n        for (var i = 0; i < lines.length; ++i)\r\n            lines[i] = lines[i]\r\n                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\r\n                .trim();\r\n        commentText = lines\r\n            .join(\"\\n\")\r\n            .trim();\r\n    }\r\n\r\n    function isDoubleSlashCommentLine(startOffset) {\r\n        var endOffset = findEndOfLine(startOffset);\r\n\r\n        // see if remaining line matches comment pattern\r\n        var lineText = source.substring(startOffset, endOffset);\r\n        // look for 1 or 2 slashes since startOffset would already point past\r\n        // the first slash that started the comment.\r\n        var isComment = /^\\s*\\/{1,2}/.test(lineText);\r\n        return isComment;\r\n    }\r\n\r\n    function findEndOfLine(cursor) {\r\n        // find end of cursor's line\r\n        var endOffset = cursor;\r\n        while (endOffset < length && charAt(endOffset) !== \"\\n\") {\r\n            endOffset++;\r\n        }\r\n        return endOffset;\r\n    }\r\n\r\n    /**\r\n     * Obtains the next token.\r\n     * @returns {string|null} Next token or `null` on eof\r\n     * @inner\r\n     */\r\n    function next() {\r\n        if (stack.length > 0)\r\n            return stack.shift();\r\n        if (stringDelim)\r\n            return readString();\r\n        var repeat,\r\n            prev,\r\n            curr,\r\n            start,\r\n            isDoc,\r\n            isLeadingComment = offset === 0;\r\n        do {\r\n            if (offset === length)\r\n                return null;\r\n            repeat = false;\r\n            while (whitespaceRe.test(curr = charAt(offset))) {\r\n                if (curr === \"\\n\") {\r\n                    isLeadingComment = true;\r\n                    ++line;\r\n                }\r\n                if (++offset === length)\r\n                    return null;\r\n            }\r\n\r\n            if (charAt(offset) === \"/\") {\r\n                if (++offset === length) {\r\n                    throw illegal(\"comment\");\r\n                }\r\n                if (charAt(offset) === \"/\") { // Line\r\n                    if (!alternateCommentMode) {\r\n                        // check for triple-slash comment\r\n                        isDoc = charAt(start = offset + 1) === \"/\";\r\n\r\n                        while (charAt(++offset) !== \"\\n\") {\r\n                            if (offset === length) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                        ++offset;\r\n                        if (isDoc) {\r\n                            setComment(start, offset - 1, isLeadingComment);\r\n                        }\r\n                        ++line;\r\n                        repeat = true;\r\n                    } else {\r\n                        // check for double-slash comments, consolidating consecutive lines\r\n                        start = offset;\r\n                        isDoc = false;\r\n                        if (isDoubleSlashCommentLine(offset)) {\r\n                            isDoc = true;\r\n                            do {\r\n                                offset = findEndOfLine(offset);\r\n                                if (offset === length) {\r\n                                    break;\r\n                                }\r\n                                offset++;\r\n                            } while (isDoubleSlashCommentLine(offset));\r\n                        } else {\r\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\r\n                        }\r\n                        if (isDoc) {\r\n                            setComment(start, offset, isLeadingComment);\r\n                        }\r\n                        line++;\r\n                        repeat = true;\r\n                    }\r\n                } else if ((curr = charAt(offset)) === \"*\") { /* Block */\r\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\r\n                    start = offset + 1;\r\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\r\n                    do {\r\n                        if (curr === \"\\n\") {\r\n                            ++line;\r\n                        }\r\n                        if (++offset === length) {\r\n                            throw illegal(\"comment\");\r\n                        }\r\n                        prev = curr;\r\n                        curr = charAt(offset);\r\n                    } while (prev !== \"*\" || curr !== \"/\");\r\n                    ++offset;\r\n                    if (isDoc) {\r\n                        setComment(start, offset - 2, isLeadingComment);\r\n                    }\r\n                    repeat = true;\r\n                } else {\r\n                    return \"/\";\r\n                }\r\n            }\r\n        } while (repeat);\r\n\r\n        // offset !== length if we got here\r\n\r\n        var end = offset;\r\n        delimRe.lastIndex = 0;\r\n        var delim = delimRe.test(charAt(end++));\r\n        if (!delim)\r\n            while (end < length && !delimRe.test(charAt(end)))\r\n                ++end;\r\n        var token = source.substring(offset, offset = end);\r\n        if (token === \"\\\"\" || token === \"'\")\r\n            stringDelim = token;\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Pushes a token back to the stack.\r\n     * @param {string} token Token\r\n     * @returns {undefined}\r\n     * @inner\r\n     */\r\n    function push(token) {\r\n        stack.push(token);\r\n    }\r\n\r\n    /**\r\n     * Peeks for the next token.\r\n     * @returns {string|null} Token or `null` on eof\r\n     * @inner\r\n     */\r\n    function peek() {\r\n        if (!stack.length) {\r\n            var token = next();\r\n            if (token === null)\r\n                return null;\r\n            push(token);\r\n        }\r\n        return stack[0];\r\n    }\r\n\r\n    /**\r\n     * Skips a token.\r\n     * @param {string} expected Expected token\r\n     * @param {boolean} [optional=false] Whether the token is optional\r\n     * @returns {boolean} `true` when skipped, `false` if not\r\n     * @throws {Error} When a required token is not present\r\n     * @inner\r\n     */\r\n    function skip(expected, optional) {\r\n        var actual = peek(),\r\n            equals = actual === expected;\r\n        if (equals) {\r\n            next();\r\n            return true;\r\n        }\r\n        if (!optional)\r\n            throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a comment.\r\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n     * @returns {string|null} Comment text\r\n     * @inner\r\n     */\r\n    function cmnt(trailingLine) {\r\n        var ret = null;\r\n        if (trailingLine === undefined) {\r\n            if (commentLine === line - 1 && (alternateCommentMode || commentType === \"*\" || commentLineEmpty)) {\r\n                ret = commentIsLeading ? commentText : null;\r\n            }\r\n        } else {\r\n            /* istanbul ignore else */\r\n            if (commentLine < trailingLine) {\r\n                peek();\r\n            }\r\n            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === \"/\")) {\r\n                ret = commentIsLeading ? null : commentText;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    return Object.defineProperty({\r\n        next: next,\r\n        peek: peek,\r\n        push: push,\r\n        skip: skip,\r\n        cmnt: cmnt\r\n    }, \"line\", {\r\n        get: function() { return line; }\r\n    });\r\n    /* eslint-enable callback-return */\r\n}\r\n"]},"metadata":{},"sourceType":"script"}