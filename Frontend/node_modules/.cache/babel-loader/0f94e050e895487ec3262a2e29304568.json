{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert');\n\nvar signals = require('./signals.js');\n\nvar isWin = /^win/i.test(process.platform);\n\nvar EE = require('events');\n/* istanbul ignore if */\n\n\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter;\n}\n\nvar emitter;\n\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__;\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE();\n  emitter.count = 0;\n  emitter.emitted = {};\n} // Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\n\n\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity);\n  emitter.infinite = true;\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n\n  if (loaded === false) {\n    load();\n  }\n\n  var ev = 'exit';\n\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit';\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb);\n\n    if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n      unload();\n    }\n  };\n\n  emitter.on(ev, cb);\n  return remove;\n};\n\nmodule.exports.unload = unload;\n\nfunction unload() {\n  if (!loaded) {\n    return;\n  }\n\n  loaded = false;\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig]);\n    } catch (er) {}\n  });\n  process.emit = originalProcessEmit;\n  process.reallyExit = originalProcessReallyExit;\n  emitter.count -= 1;\n}\n\nfunction emit(event, code, signal) {\n  if (emitter.emitted[event]) {\n    return;\n  }\n\n  emitter.emitted[event] = true;\n  emitter.emit(event, code, signal);\n} // { <signal>: <listener fn>, ... }\n\n\nvar sigListeners = {};\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener() {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig);\n\n    if (listeners.length === emitter.count) {\n      unload();\n      emit('exit', null, sig);\n      /* istanbul ignore next */\n\n      emit('afterexit', null, sig);\n      /* istanbul ignore next */\n\n      if (isWin && sig === 'SIGHUP') {\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n        // so use a supported signal instead\n        sig = 'SIGINT';\n      }\n\n      process.kill(process.pid, sig);\n    }\n  };\n});\n\nmodule.exports.signals = function () {\n  return signals;\n};\n\nmodule.exports.load = load;\nvar loaded = false;\n\nfunction load() {\n  if (loaded) {\n    return;\n  }\n\n  loaded = true; // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n\n  emitter.count += 1;\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig]);\n      return true;\n    } catch (er) {\n      return false;\n    }\n  });\n  process.emit = processEmit;\n  process.reallyExit = processReallyExit;\n}\n\nvar originalProcessReallyExit = process.reallyExit;\n\nfunction processReallyExit(code) {\n  process.exitCode = code || 0;\n  emit('exit', process.exitCode, null);\n  /* istanbul ignore next */\n\n  emit('afterexit', process.exitCode, null);\n  /* istanbul ignore next */\n\n  originalProcessReallyExit.call(process, process.exitCode);\n}\n\nvar originalProcessEmit = process.emit;\n\nfunction processEmit(ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg;\n    }\n\n    var ret = originalProcessEmit.apply(this, arguments);\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n\n    emit('afterexit', process.exitCode, null);\n    return ret;\n  } else {\n    return originalProcessEmit.apply(this, arguments);\n  }\n}","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/signal-exit/index.js"],"names":["assert","require","signals","isWin","test","process","platform","EE","EventEmitter","emitter","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","module","exports","cb","opts","equal","loaded","load","ev","alwaysLast","remove","removeListener","listeners","length","unload","on","forEach","sig","sigListeners","er","emit","originalProcessEmit","reallyExit","originalProcessReallyExit","event","code","signal","listener","kill","pid","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments"],"mappings":"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","sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\r\n// that are in the direct sync flow of nyc's outputCoverage are\r\n// ignored, since we can never get coverage for them.\r\nvar assert = require('assert')\r\nvar signals = require('./signals.js')\r\nvar isWin = /^win/i.test(process.platform)\r\n\r\nvar EE = require('events')\r\n/* istanbul ignore if */\r\nif (typeof EE !== 'function') {\r\n  EE = EE.EventEmitter\r\n}\r\n\r\nvar emitter\r\nif (process.__signal_exit_emitter__) {\r\n  emitter = process.__signal_exit_emitter__\r\n} else {\r\n  emitter = process.__signal_exit_emitter__ = new EE()\r\n  emitter.count = 0\r\n  emitter.emitted = {}\r\n}\r\n\r\n// Because this emitter is a global, we have to check to see if a\r\n// previous version of this library failed to enable infinite listeners.\r\n// I know what you're about to say.  But literally everything about\r\n// signal-exit is a compromise with evil.  Get used to it.\r\nif (!emitter.infinite) {\r\n  emitter.setMaxListeners(Infinity)\r\n  emitter.infinite = true\r\n}\r\n\r\nmodule.exports = function (cb, opts) {\r\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\r\n\r\n  if (loaded === false) {\r\n    load()\r\n  }\r\n\r\n  var ev = 'exit'\r\n  if (opts && opts.alwaysLast) {\r\n    ev = 'afterexit'\r\n  }\r\n\r\n  var remove = function () {\r\n    emitter.removeListener(ev, cb)\r\n    if (emitter.listeners('exit').length === 0 &&\r\n        emitter.listeners('afterexit').length === 0) {\r\n      unload()\r\n    }\r\n  }\r\n  emitter.on(ev, cb)\r\n\r\n  return remove\r\n}\r\n\r\nmodule.exports.unload = unload\r\nfunction unload () {\r\n  if (!loaded) {\r\n    return\r\n  }\r\n  loaded = false\r\n\r\n  signals.forEach(function (sig) {\r\n    try {\r\n      process.removeListener(sig, sigListeners[sig])\r\n    } catch (er) {}\r\n  })\r\n  process.emit = originalProcessEmit\r\n  process.reallyExit = originalProcessReallyExit\r\n  emitter.count -= 1\r\n}\r\n\r\nfunction emit (event, code, signal) {\r\n  if (emitter.emitted[event]) {\r\n    return\r\n  }\r\n  emitter.emitted[event] = true\r\n  emitter.emit(event, code, signal)\r\n}\r\n\r\n// { <signal>: <listener fn>, ... }\r\nvar sigListeners = {}\r\nsignals.forEach(function (sig) {\r\n  sigListeners[sig] = function listener () {\r\n    // If there are no other listeners, an exit is coming!\r\n    // Simplest way: remove us and then re-send the signal.\r\n    // We know that this will kill the process, so we can\r\n    // safely emit now.\r\n    var listeners = process.listeners(sig)\r\n    if (listeners.length === emitter.count) {\r\n      unload()\r\n      emit('exit', null, sig)\r\n      /* istanbul ignore next */\r\n      emit('afterexit', null, sig)\r\n      /* istanbul ignore next */\r\n      if (isWin && sig === 'SIGHUP') {\r\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\r\n        // so use a supported signal instead\r\n        sig = 'SIGINT'\r\n      }\r\n      process.kill(process.pid, sig)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports.signals = function () {\r\n  return signals\r\n}\r\n\r\nmodule.exports.load = load\r\n\r\nvar loaded = false\r\n\r\nfunction load () {\r\n  if (loaded) {\r\n    return\r\n  }\r\n  loaded = true\r\n\r\n  // This is the number of onSignalExit's that are in play.\r\n  // It's important so that we can count the correct number of\r\n  // listeners on signals, and don't wait for the other one to\r\n  // handle it instead of us.\r\n  emitter.count += 1\r\n\r\n  signals = signals.filter(function (sig) {\r\n    try {\r\n      process.on(sig, sigListeners[sig])\r\n      return true\r\n    } catch (er) {\r\n      return false\r\n    }\r\n  })\r\n\r\n  process.emit = processEmit\r\n  process.reallyExit = processReallyExit\r\n}\r\n\r\nvar originalProcessReallyExit = process.reallyExit\r\nfunction processReallyExit (code) {\r\n  process.exitCode = code || 0\r\n  emit('exit', process.exitCode, null)\r\n  /* istanbul ignore next */\r\n  emit('afterexit', process.exitCode, null)\r\n  /* istanbul ignore next */\r\n  originalProcessReallyExit.call(process, process.exitCode)\r\n}\r\n\r\nvar originalProcessEmit = process.emit\r\nfunction processEmit (ev, arg) {\r\n  if (ev === 'exit') {\r\n    if (arg !== undefined) {\r\n      process.exitCode = arg\r\n    }\r\n    var ret = originalProcessEmit.apply(this, arguments)\r\n    emit('exit', process.exitCode, null)\r\n    /* istanbul ignore next */\r\n    emit('afterexit', process.exitCode, null)\r\n    return ret\r\n  } else {\r\n    return originalProcessEmit.apply(this, arguments)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}