{"ast":null,"code":"'use strict';\n/**\r\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\r\n * @param ...\r\n */\n\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (var i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n/**\r\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\r\n * to an array of extensions associated with the type.  The first extension is\r\n * used as the default extension for the type.\r\n *\r\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\r\n *\r\n * If a type declares an extension that has already been defined, an error will\r\n * be thrown.  To suppress this error and force the extension to be associated\r\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\r\n * extension with \"*\" to map the type to extension, without mapping the\r\n * extension to the type.\r\n *\r\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\r\n *\r\n *\r\n * @param map (Object) type definitions\r\n * @param force (Boolean) if true, force overriding of existing definitions\r\n */\n\n\nMime.prototype.define = function (typeMap, force) {\n  for (var type in typeMap) {\n    var extensions = typeMap[type].map(function (t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (var i = 0; i < extensions.length; i++) {\n      var ext = extensions[i]; // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n\n      if (ext[0] == '*') {\n        continue;\n      }\n\n      if (!force && ext in this._types) {\n        throw new Error('Attempt to change mapping for \"' + ext + '\" extension from \"' + this._types[ext] + '\" to \"' + type + '\". Pass `force=true` to allow this, otherwise remove \"' + ext + '\" from the list of extensions for \"' + type + '\".');\n      }\n\n      this._types[ext] = type;\n    } // Use first extension as default\n\n\n    if (force || !this._extensions[type]) {\n      var ext = extensions[0];\n      this._extensions[type] = ext[0] != '*' ? ext : ext.substr(1);\n    }\n  }\n};\n/**\r\n * Lookup a mime type based on extension\r\n */\n\n\nMime.prototype.getType = function (path) {\n  path = String(path);\n  var last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  var ext = last.replace(/^.*\\./, '').toLowerCase();\n  var hasPath = last.length < path.length;\n  var hasDot = ext.length < last.length - 1;\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n/**\r\n * Return file extension associated with a mime type\r\n */\n\n\nMime.prototype.getExtension = function (type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/gtoken/node_modules/mime/Mime.js"],"names":["Mime","_types","Object","create","_extensions","i","arguments","length","define","bind","getType","getExtension","prototype","typeMap","force","type","extensions","map","t","toLowerCase","ext","Error","substr","path","String","last","replace","hasPath","hasDot","test","RegExp","$1","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\r\n * @param ...\r\n */\r\nfunction Mime() {\r\n  this._types = Object.create(null);\r\n  this._extensions = Object.create(null);\r\n\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    this.define(arguments[i]);\r\n  }\r\n\r\n  this.define = this.define.bind(this);\r\n  this.getType = this.getType.bind(this);\r\n  this.getExtension = this.getExtension.bind(this);\r\n}\r\n\r\n/**\r\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\r\n * to an array of extensions associated with the type.  The first extension is\r\n * used as the default extension for the type.\r\n *\r\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\r\n *\r\n * If a type declares an extension that has already been defined, an error will\r\n * be thrown.  To suppress this error and force the extension to be associated\r\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\r\n * extension with \"*\" to map the type to extension, without mapping the\r\n * extension to the type.\r\n *\r\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\r\n *\r\n *\r\n * @param map (Object) type definitions\r\n * @param force (Boolean) if true, force overriding of existing definitions\r\n */\r\nMime.prototype.define = function(typeMap, force) {\r\n  for (var type in typeMap) {\r\n    var extensions = typeMap[type].map(function(t) {return t.toLowerCase()});\r\n    type = type.toLowerCase();\r\n\r\n    for (var i = 0; i < extensions.length; i++) {\r\n      var ext = extensions[i];\r\n\r\n      // '*' prefix = not the preferred type for this extension.  So fixup the\r\n      // extension, and skip it.\r\n      if (ext[0] == '*') {\r\n        continue;\r\n      }\r\n\r\n      if (!force && (ext in this._types)) {\r\n        throw new Error(\r\n          'Attempt to change mapping for \"' + ext +\r\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\r\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\r\n          '\" from the list of extensions for \"' + type + '\".'\r\n        );\r\n      }\r\n\r\n      this._types[ext] = type;\r\n    }\r\n\r\n    // Use first extension as default\r\n    if (force || !this._extensions[type]) {\r\n      var ext = extensions[0];\r\n      this._extensions[type] = (ext[0] != '*') ? ext : ext.substr(1)\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Lookup a mime type based on extension\r\n */\r\nMime.prototype.getType = function(path) {\r\n  path = String(path);\r\n  var last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\r\n  var ext = last.replace(/^.*\\./, '').toLowerCase();\r\n\r\n  var hasPath = last.length < path.length;\r\n  var hasDot = ext.length < last.length - 1;\r\n\r\n  return (hasDot || !hasPath) && this._types[ext] || null;\r\n};\r\n\r\n/**\r\n * Return file extension associated with a mime type\r\n */\r\nMime.prototype.getExtension = function(type) {\r\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\r\n  return type && this._extensions[type.toLowerCase()] || null;\r\n};\r\n\r\nmodule.exports = Mime;\r\n"]},"metadata":{},"sourceType":"script"}