{"ast":null,"code":"// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\nvar ReadableStream = require('stream').Readable || require('readable-stream'),\n    inherits = require('util').inherits;\n\nvar Dicer = require('dicer');\n\nvar parseParams = require('../utils').parseParams,\n    decodeText = require('../utils').decodeText,\n    basename = require('../utils').basename;\n\nvar RE_BOUNDARY = /^boundary$/i,\n    RE_FIELD = /^form-data$/i,\n    RE_CHARSET = /^charset$/i,\n    RE_FILENAME = /^filename$/i,\n    RE_NAME = /^name$/i;\nMultipart.detect = /^multipart\\/form-data/i;\n\nfunction Multipart(boy, cfg) {\n  if (!(this instanceof Multipart)) return new Multipart(boy, cfg);\n  var i,\n      len,\n      self = this,\n      boundary,\n      limits = cfg.limits,\n      parsedConType = cfg.parsedConType || [],\n      defCharset = cfg.defCharset || 'utf8',\n      preservePath = cfg.preservePath,\n      fileopts = typeof cfg.fileHwm === 'number' ? {\n    highWaterMark: cfg.fileHwm\n  } : {};\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1];\n      break;\n    }\n  }\n\n  function checkFinished() {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false;\n      process.nextTick(function () {\n        boy._done = true;\n        boy.emit('finish');\n      });\n    }\n  }\n\n  if (typeof boundary !== 'string') throw new Error('Multipart: Boundary not found');\n  var fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024,\n      fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity,\n      filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity,\n      fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity,\n      partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;\n  var nfiles = 0,\n      nfields = 0,\n      nends = 0,\n      curFile,\n      curField,\n      finished = false;\n  this._needDrain = false;\n  this._pause = false;\n  this._cb = undefined;\n  this._nparts = 0;\n  this._boy = boy;\n  var parserCfg = {\n    boundary: boundary,\n    maxHeaderPairs: limits && limits.headerPairs\n  };\n  if (fileopts.highWaterMark) parserCfg.partHwm = fileopts.highWaterMark;\n  if (cfg.highWaterMark) parserCfg.highWaterMark = cfg.highWaterMark;\n  this.parser = new Dicer(parserCfg);\n  this.parser.on('drain', function () {\n    self._needDrain = false;\n\n    if (self._cb && !self._pause) {\n      var cb = self._cb;\n      self._cb = undefined;\n      cb();\n    }\n  }).on('part', function onPart(part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart);\n      self.parser.on('part', skipPart);\n      boy.hitPartsLimit = true;\n      boy.emit('partsLimit');\n      return skipPart(part);\n    } // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n\n\n    if (curField) {\n      var field = curField;\n      field.emit('end');\n      field.removeAllListeners('end');\n    }\n\n    part.on('header', function (header) {\n      var contype,\n          fieldname,\n          parsed,\n          charset,\n          encoding,\n          filename,\n          nsize = 0;\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0]);\n\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase();\n\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase();\n              break;\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) contype = 'text/plain';\n      if (charset === undefined) charset = defCharset;\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0]);\n        if (!RE_FIELD.test(parsed[0])) return skipPart(part);\n\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = decodeText(parsed[i][1], 'binary', 'utf8');\n            if (!preservePath) filename = basename(filename);\n          }\n        }\n      } else return skipPart(part);\n\n      if (header['content-transfer-encoding']) encoding = header['content-transfer-encoding'][0].toLowerCase();else encoding = '7bit';\n      var onData, onEnd;\n\n      if (contype === 'application/octet-stream' || filename !== undefined) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true;\n            boy.emit('filesLimit');\n          }\n\n          return skipPart(part);\n        }\n\n        ++nfiles;\n\n        if (!boy._events.file) {\n          self.parser._ignore();\n\n          return;\n        }\n\n        ++nends;\n        var file = new FileStream(fileopts);\n        curFile = file;\n        file.on('end', function () {\n          --nends;\n          checkFinished();\n\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        });\n\n        file._read = function (n) {\n          if (!self._pause) return;\n          self._pause = false;\n\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        };\n\n        boy.emit('file', fieldname, file, filename, encoding, contype);\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            var extralen = fileSizeLimit - (nsize - data.length);\n            if (extralen > 0) file.push(data.slice(0, extralen));\n            file.emit('limit');\n            file.truncated = true;\n            part.removeAllListeners('data');\n          } else if (!file.push(data)) self._pause = true;\n        };\n\n        onEnd = function () {\n          curFile = undefined;\n          file.push(null);\n        };\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true;\n            boy.emit('fieldsLimit');\n          }\n\n          return skipPart(part);\n        }\n\n        ++nfields;\n        ++nends;\n        var buffer = '',\n            truncated = false;\n        curField = part;\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            var extralen = fieldSizeLimit - (nsize - data.length);\n            buffer += data.toString('binary', 0, extralen);\n            truncated = true;\n            part.removeAllListeners('data');\n          } else buffer += data.toString('binary');\n        };\n\n        onEnd = function () {\n          curField = undefined;\n          if (buffer.length) buffer = decodeText(buffer, 'binary', charset);\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n          --nends;\n          checkFinished();\n        };\n      }\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\r\n         broken. Streams2/streams3 is a huge black box of confusion, but\r\n         somehow overriding the sync state seems to fix things again (and still\r\n         seems to work for previous node versions).\r\n      */\n\n\n      part._readableState.sync = false;\n      part.on('data', onData);\n      part.on('end', onEnd);\n    }).on('error', function (err) {\n      if (curFile) curFile.emit('error', err);\n    });\n  }).on('error', function (err) {\n    boy.emit('error', err);\n  }).on('finish', function () {\n    finished = true;\n    checkFinished();\n  });\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  var r;\n  if ((r = this.parser.write(chunk)) && !this._pause) cb();else {\n    this._needDrain = !r;\n    this._cb = cb;\n  }\n};\n\nMultipart.prototype.end = function () {\n  var self = this;\n\n  if (this._nparts === 0 && !self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true;\n\n      self._boy.emit('finish');\n    });\n  } else if (this.parser.writable) this.parser.end();\n};\n\nfunction skipPart(part) {\n  part.resume();\n}\n\nfunction FileStream(opts) {\n  if (!(this instanceof FileStream)) return new FileStream(opts);\n  ReadableStream.call(this, opts);\n  this.truncated = false;\n}\n\ninherits(FileStream, ReadableStream);\n\nFileStream.prototype._read = function (n) {};\n\nmodule.exports = Multipart;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/busboy/lib/types/multipart.js"],"names":["ReadableStream","require","Readable","inherits","Dicer","parseParams","decodeText","basename","RE_BOUNDARY","RE_FIELD","RE_CHARSET","RE_FILENAME","RE_NAME","Multipart","detect","boy","cfg","i","len","self","boundary","limits","parsedConType","defCharset","preservePath","fileopts","fileHwm","highWaterMark","length","Array","isArray","test","checkFinished","nends","finished","_done","process","nextTick","emit","Error","fieldSizeLimit","fieldSize","fileSizeLimit","fileSize","Infinity","filesLimit","files","fieldsLimit","fields","partsLimit","parts","nfiles","nfields","curFile","curField","_needDrain","_pause","_cb","undefined","_nparts","_boy","parserCfg","maxHeaderPairs","headerPairs","partHwm","parser","on","cb","onPart","part","removeListener","skipPart","hitPartsLimit","field","removeAllListeners","header","contype","fieldname","parsed","charset","encoding","filename","nsize","toLowerCase","onData","onEnd","hitFilesLimit","_events","file","_ignore","FileStream","_read","n","data","extralen","push","slice","truncated","hitFieldsLimit","buffer","toString","_readableState","sync","err","prototype","write","chunk","r","end","writable","resume","opts","call","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,cAAc,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBC,QAAlB,IAA8BD,OAAO,CAAC,iBAAD,CAA1D;AAAA,IACIE,QAAQ,GAAGF,OAAO,CAAC,MAAD,CAAP,CAAgBE,QAD/B;;AAGA,IAAIC,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AAEA,IAAII,WAAW,GAAGJ,OAAO,CAAC,UAAD,CAAP,CAAoBI,WAAtC;AAAA,IACIC,UAAU,GAAGL,OAAO,CAAC,UAAD,CAAP,CAAoBK,UADrC;AAAA,IAEIC,QAAQ,GAAGN,OAAO,CAAC,UAAD,CAAP,CAAoBM,QAFnC;;AAIA,IAAIC,WAAW,GAAG,aAAlB;AAAA,IACIC,QAAQ,GAAG,cADf;AAAA,IAEIC,UAAU,GAAG,YAFjB;AAAA,IAGIC,WAAW,GAAG,aAHlB;AAAA,IAIIC,OAAO,GAAG,SAJd;AAMAC,SAAS,CAACC,MAAV,GAAmB,wBAAnB;;AACA,SAASD,SAAT,CAAmBE,GAAnB,EAAwBC,GAAxB,EAA6B;AAC3B,MAAI,EAAE,gBAAgBH,SAAlB,CAAJ,EACE,OAAO,IAAIA,SAAJ,CAAcE,GAAd,EAAmBC,GAAnB,CAAP;AACF,MAAIC,CAAJ;AAAA,MACIC,GADJ;AAAA,MAEIC,IAAI,GAAG,IAFX;AAAA,MAGIC,QAHJ;AAAA,MAIIC,MAAM,GAAGL,GAAG,CAACK,MAJjB;AAAA,MAKIC,aAAa,GAAGN,GAAG,CAACM,aAAJ,IAAqB,EALzC;AAAA,MAMIC,UAAU,GAAGP,GAAG,CAACO,UAAJ,IAAkB,MANnC;AAAA,MAOIC,YAAY,GAAGR,GAAG,CAACQ,YAPvB;AAAA,MAQIC,QAAQ,GAAI,OAAOT,GAAG,CAACU,OAAX,KAAuB,QAAvB,GACE;AAAEC,IAAAA,aAAa,EAAEX,GAAG,CAACU;AAArB,GADF,GAEE,EAVlB;;AAYA,OAAKT,CAAC,GAAG,CAAJ,EAAOC,GAAG,GAAGI,aAAa,CAACM,MAAhC,EAAwCX,CAAC,GAAGC,GAA5C,EAAiD,EAAED,CAAnD,EAAsD;AACpD,QAAIY,KAAK,CAACC,OAAN,CAAcR,aAAa,CAACL,CAAD,CAA3B,KACGT,WAAW,CAACuB,IAAZ,CAAiBT,aAAa,CAACL,CAAD,CAAb,CAAiB,CAAjB,CAAjB,CADP,EAC8C;AAC5CG,MAAAA,QAAQ,GAAGE,aAAa,CAACL,CAAD,CAAb,CAAiB,CAAjB,CAAX;AACA;AACD;AACF;;AAED,WAASe,aAAT,GAAyB;AACvB,QAAIC,KAAK,KAAK,CAAV,IAAeC,QAAf,IAA2B,CAACnB,GAAG,CAACoB,KAApC,EAA2C;AACzCD,MAAAA,QAAQ,GAAG,KAAX;AACAE,MAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BtB,QAAAA,GAAG,CAACoB,KAAJ,GAAY,IAAZ;AACApB,QAAAA,GAAG,CAACuB,IAAJ,CAAS,QAAT;AACD,OAHD;AAID;AACF;;AAED,MAAI,OAAOlB,QAAP,KAAoB,QAAxB,EACE,MAAM,IAAImB,KAAJ,CAAU,+BAAV,CAAN;AAEF,MAAIC,cAAc,GAAInB,MAAM,IAAI,OAAOA,MAAM,CAACoB,SAAd,KAA4B,QAAtC,GACEpB,MAAM,CAACoB,SADT,GAEE,IAAI,IAAJ,GAAW,IAFnC;AAAA,MAGIC,aAAa,GAAIrB,MAAM,IAAI,OAAOA,MAAM,CAACsB,QAAd,KAA2B,QAArC,GACEtB,MAAM,CAACsB,QADT,GAEEC,QALvB;AAAA,MAMIC,UAAU,GAAIxB,MAAM,IAAI,OAAOA,MAAM,CAACyB,KAAd,KAAwB,QAAlC,GACEzB,MAAM,CAACyB,KADT,GAEEF,QARpB;AAAA,MASIG,WAAW,GAAI1B,MAAM,IAAI,OAAOA,MAAM,CAAC2B,MAAd,KAAyB,QAAnC,GACE3B,MAAM,CAAC2B,MADT,GAEEJ,QAXrB;AAAA,MAYIK,UAAU,GAAI5B,MAAM,IAAI,OAAOA,MAAM,CAAC6B,KAAd,KAAwB,QAAlC,GACE7B,MAAM,CAAC6B,KADT,GAEEN,QAdpB;AAgBA,MAAIO,MAAM,GAAG,CAAb;AAAA,MACIC,OAAO,GAAG,CADd;AAAA,MAEInB,KAAK,GAAG,CAFZ;AAAA,MAGIoB,OAHJ;AAAA,MAIIC,QAJJ;AAAA,MAKIpB,QAAQ,GAAG,KALf;AAOA,OAAKqB,UAAL,GAAkB,KAAlB;AACA,OAAKC,MAAL,GAAc,KAAd;AACA,OAAKC,GAAL,GAAWC,SAAX;AACA,OAAKC,OAAL,GAAe,CAAf;AACA,OAAKC,IAAL,GAAY7C,GAAZ;AAEA,MAAI8C,SAAS,GAAG;AACdzC,IAAAA,QAAQ,EAAEA,QADI;AAEd0C,IAAAA,cAAc,EAAGzC,MAAM,IAAIA,MAAM,CAAC0C;AAFpB,GAAhB;AAIA,MAAItC,QAAQ,CAACE,aAAb,EACEkC,SAAS,CAACG,OAAV,GAAoBvC,QAAQ,CAACE,aAA7B;AACF,MAAIX,GAAG,CAACW,aAAR,EACEkC,SAAS,CAAClC,aAAV,GAA0BX,GAAG,CAACW,aAA9B;AAEF,OAAKsC,MAAL,GAAc,IAAI7D,KAAJ,CAAUyD,SAAV,CAAd;AACA,OAAKI,MAAL,CAAYC,EAAZ,CAAe,OAAf,EAAwB,YAAW;AACjC/C,IAAAA,IAAI,CAACoC,UAAL,GAAkB,KAAlB;;AACA,QAAIpC,IAAI,CAACsC,GAAL,IAAY,CAACtC,IAAI,CAACqC,MAAtB,EAA8B;AAC5B,UAAIW,EAAE,GAAGhD,IAAI,CAACsC,GAAd;AACAtC,MAAAA,IAAI,CAACsC,GAAL,GAAWC,SAAX;AACAS,MAAAA,EAAE;AACH;AACF,GAPD,EAOGD,EAPH,CAOM,MAPN,EAOc,SAASE,MAAT,CAAgBC,IAAhB,EAAsB;AAClC,QAAI,EAAElD,IAAI,CAACwC,OAAP,GAAiBV,UAArB,EAAiC;AAC/B9B,MAAAA,IAAI,CAAC8C,MAAL,CAAYK,cAAZ,CAA2B,MAA3B,EAAmCF,MAAnC;AACAjD,MAAAA,IAAI,CAAC8C,MAAL,CAAYC,EAAZ,CAAe,MAAf,EAAuBK,QAAvB;AACAxD,MAAAA,GAAG,CAACyD,aAAJ,GAAoB,IAApB;AACAzD,MAAAA,GAAG,CAACuB,IAAJ,CAAS,YAAT;AACA,aAAOiC,QAAQ,CAACF,IAAD,CAAf;AACD,KAPiC,CASlC;AACA;AACA;;;AACA,QAAIf,QAAJ,EAAc;AACZ,UAAImB,KAAK,GAAGnB,QAAZ;AACAmB,MAAAA,KAAK,CAACnC,IAAN,CAAW,KAAX;AACAmC,MAAAA,KAAK,CAACC,kBAAN,CAAyB,KAAzB;AACD;;AAEDL,IAAAA,IAAI,CAACH,EAAL,CAAQ,QAAR,EAAkB,UAASS,MAAT,EAAiB;AACjC,UAAIC,OAAJ;AAAA,UACIC,SADJ;AAAA,UAEIC,MAFJ;AAAA,UAGIC,OAHJ;AAAA,UAIIC,QAJJ;AAAA,UAKIC,QALJ;AAAA,UAMIC,KAAK,GAAG,CANZ;;AAQA,UAAIP,MAAM,CAAC,cAAD,CAAV,EAA4B;AAC1BG,QAAAA,MAAM,GAAGzE,WAAW,CAACsE,MAAM,CAAC,cAAD,CAAN,CAAuB,CAAvB,CAAD,CAApB;;AACA,YAAIG,MAAM,CAAC,CAAD,CAAV,EAAe;AACbF,UAAAA,OAAO,GAAGE,MAAM,CAAC,CAAD,CAAN,CAAUK,WAAV,EAAV;;AACA,eAAKlE,CAAC,GAAG,CAAJ,EAAOC,GAAG,GAAG4D,MAAM,CAAClD,MAAzB,EAAiCX,CAAC,GAAGC,GAArC,EAA0C,EAAED,CAA5C,EAA+C;AAC7C,gBAAIP,UAAU,CAACqB,IAAX,CAAgB+C,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,CAAhB,CAAJ,EAAmC;AACjC8D,cAAAA,OAAO,GAAGD,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,EAAakE,WAAb,EAAV;AACA;AACD;AACF;AACF;AACF;;AAED,UAAIP,OAAO,KAAKlB,SAAhB,EACEkB,OAAO,GAAG,YAAV;AACF,UAAIG,OAAO,KAAKrB,SAAhB,EACEqB,OAAO,GAAGxD,UAAV;;AAEF,UAAIoD,MAAM,CAAC,qBAAD,CAAV,EAAmC;AACjCG,QAAAA,MAAM,GAAGzE,WAAW,CAACsE,MAAM,CAAC,qBAAD,CAAN,CAA8B,CAA9B,CAAD,CAApB;AACA,YAAI,CAAClE,QAAQ,CAACsB,IAAT,CAAc+C,MAAM,CAAC,CAAD,CAApB,CAAL,EACE,OAAOP,QAAQ,CAACF,IAAD,CAAf;;AACF,aAAKpD,CAAC,GAAG,CAAJ,EAAOC,GAAG,GAAG4D,MAAM,CAAClD,MAAzB,EAAiCX,CAAC,GAAGC,GAArC,EAA0C,EAAED,CAA5C,EAA+C;AAC7C,cAAIL,OAAO,CAACmB,IAAR,CAAa+C,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,CAAb,CAAJ,EAAgC;AAC9B4D,YAAAA,SAAS,GAAGvE,UAAU,CAACwE,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,CAAD,EAAe,QAAf,EAAyB,MAAzB,CAAtB;AACD,WAFD,MAEO,IAAIN,WAAW,CAACoB,IAAZ,CAAiB+C,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,CAAjB,CAAJ,EAAoC;AACzCgE,YAAAA,QAAQ,GAAG3E,UAAU,CAACwE,MAAM,CAAC7D,CAAD,CAAN,CAAU,CAAV,CAAD,EAAe,QAAf,EAAyB,MAAzB,CAArB;AACA,gBAAI,CAACO,YAAL,EACEyD,QAAQ,GAAG1E,QAAQ,CAAC0E,QAAD,CAAnB;AACH;AACF;AACF,OAbD,MAcE,OAAOV,QAAQ,CAACF,IAAD,CAAf;;AAEF,UAAIM,MAAM,CAAC,2BAAD,CAAV,EACEK,QAAQ,GAAGL,MAAM,CAAC,2BAAD,CAAN,CAAoC,CAApC,EAAuCQ,WAAvC,EAAX,CADF,KAGEH,QAAQ,GAAG,MAAX;AAEF,UAAII,MAAJ,EACIC,KADJ;;AAEA,UAAIT,OAAO,KAAK,0BAAZ,IAA0CK,QAAQ,KAAKvB,SAA3D,EAAsE;AACpE;AACA,YAAIP,MAAM,KAAKN,UAAf,EAA2B;AACzB,cAAI,CAAC9B,GAAG,CAACuE,aAAT,EAAwB;AACtBvE,YAAAA,GAAG,CAACuE,aAAJ,GAAoB,IAApB;AACAvE,YAAAA,GAAG,CAACuB,IAAJ,CAAS,YAAT;AACD;;AACD,iBAAOiC,QAAQ,CAACF,IAAD,CAAf;AACD;;AAED,UAAElB,MAAF;;AAEA,YAAI,CAACpC,GAAG,CAACwE,OAAJ,CAAYC,IAAjB,EAAuB;AACrBrE,UAAAA,IAAI,CAAC8C,MAAL,CAAYwB,OAAZ;;AACA;AACD;;AAED,UAAExD,KAAF;AACA,YAAIuD,IAAI,GAAG,IAAIE,UAAJ,CAAejE,QAAf,CAAX;AACA4B,QAAAA,OAAO,GAAGmC,IAAV;AACAA,QAAAA,IAAI,CAACtB,EAAL,CAAQ,KAAR,EAAe,YAAW;AACxB,YAAEjC,KAAF;AACAD,UAAAA,aAAa;;AACb,cAAIb,IAAI,CAACsC,GAAL,IAAY,CAACtC,IAAI,CAACoC,UAAtB,EAAkC;AAChC,gBAAIY,EAAE,GAAGhD,IAAI,CAACsC,GAAd;AACAtC,YAAAA,IAAI,CAACsC,GAAL,GAAWC,SAAX;AACAS,YAAAA,EAAE;AACH;AACF,SARD;;AASAqB,QAAAA,IAAI,CAACG,KAAL,GAAa,UAASC,CAAT,EAAY;AACvB,cAAI,CAACzE,IAAI,CAACqC,MAAV,EACE;AACFrC,UAAAA,IAAI,CAACqC,MAAL,GAAc,KAAd;;AACA,cAAIrC,IAAI,CAACsC,GAAL,IAAY,CAACtC,IAAI,CAACoC,UAAtB,EAAkC;AAChC,gBAAIY,EAAE,GAAGhD,IAAI,CAACsC,GAAd;AACAtC,YAAAA,IAAI,CAACsC,GAAL,GAAWC,SAAX;AACAS,YAAAA,EAAE;AACH;AACF,SATD;;AAUApD,QAAAA,GAAG,CAACuB,IAAJ,CAAS,MAAT,EAAiBuC,SAAjB,EAA4BW,IAA5B,EAAkCP,QAAlC,EAA4CD,QAA5C,EAAsDJ,OAAtD;;AAEAQ,QAAAA,MAAM,GAAG,UAASS,IAAT,EAAe;AACtB,cAAI,CAACX,KAAK,IAAIW,IAAI,CAACjE,MAAf,IAAyBc,aAA7B,EAA4C;AAC1C,gBAAIoD,QAAQ,GAAIpD,aAAa,IAAIwC,KAAK,GAAGW,IAAI,CAACjE,MAAjB,CAA7B;AACA,gBAAIkE,QAAQ,GAAG,CAAf,EACEN,IAAI,CAACO,IAAL,CAAUF,IAAI,CAACG,KAAL,CAAW,CAAX,EAAcF,QAAd,CAAV;AACFN,YAAAA,IAAI,CAAClD,IAAL,CAAU,OAAV;AACAkD,YAAAA,IAAI,CAACS,SAAL,GAAiB,IAAjB;AACA5B,YAAAA,IAAI,CAACK,kBAAL,CAAwB,MAAxB;AACD,WAPD,MAOO,IAAI,CAACc,IAAI,CAACO,IAAL,CAAUF,IAAV,CAAL,EACL1E,IAAI,CAACqC,MAAL,GAAc,IAAd;AACH,SAVD;;AAYA6B,QAAAA,KAAK,GAAG,YAAW;AACjBhC,UAAAA,OAAO,GAAGK,SAAV;AACA8B,UAAAA,IAAI,CAACO,IAAL,CAAU,IAAV;AACD,SAHD;AAID,OAzDD,MAyDO;AACL;AACA,YAAI3C,OAAO,KAAKL,WAAhB,EAA6B;AAC3B,cAAI,CAAChC,GAAG,CAACmF,cAAT,EAAyB;AACvBnF,YAAAA,GAAG,CAACmF,cAAJ,GAAqB,IAArB;AACAnF,YAAAA,GAAG,CAACuB,IAAJ,CAAS,aAAT;AACD;;AACD,iBAAOiC,QAAQ,CAACF,IAAD,CAAf;AACD;;AAED,UAAEjB,OAAF;AACA,UAAEnB,KAAF;AACA,YAAIkE,MAAM,GAAG,EAAb;AAAA,YACIF,SAAS,GAAG,KADhB;AAEA3C,QAAAA,QAAQ,GAAGe,IAAX;;AAEAe,QAAAA,MAAM,GAAG,UAASS,IAAT,EAAe;AACtB,cAAI,CAACX,KAAK,IAAIW,IAAI,CAACjE,MAAf,IAAyBY,cAA7B,EAA6C;AAC3C,gBAAIsD,QAAQ,GAAItD,cAAc,IAAI0C,KAAK,GAAGW,IAAI,CAACjE,MAAjB,CAA9B;AACAuE,YAAAA,MAAM,IAAIN,IAAI,CAACO,QAAL,CAAc,QAAd,EAAwB,CAAxB,EAA2BN,QAA3B,CAAV;AACAG,YAAAA,SAAS,GAAG,IAAZ;AACA5B,YAAAA,IAAI,CAACK,kBAAL,CAAwB,MAAxB;AACD,WALD,MAMEyB,MAAM,IAAIN,IAAI,CAACO,QAAL,CAAc,QAAd,CAAV;AACH,SARD;;AAUAf,QAAAA,KAAK,GAAG,YAAW;AACjB/B,UAAAA,QAAQ,GAAGI,SAAX;AACA,cAAIyC,MAAM,CAACvE,MAAX,EACEuE,MAAM,GAAG7F,UAAU,CAAC6F,MAAD,EAAS,QAAT,EAAmBpB,OAAnB,CAAnB;AACFhE,UAAAA,GAAG,CAACuB,IAAJ,CAAS,OAAT,EAAkBuC,SAAlB,EAA6BsB,MAA7B,EAAqC,KAArC,EAA4CF,SAA5C,EAAuDjB,QAAvD,EAAiEJ,OAAjE;AACA,YAAE3C,KAAF;AACAD,UAAAA,aAAa;AACd,SAPD;AAQD;AAED;AACN;AACA;AACA;AACA;;;AACMqC,MAAAA,IAAI,CAACgC,cAAL,CAAoBC,IAApB,GAA2B,KAA3B;AAEAjC,MAAAA,IAAI,CAACH,EAAL,CAAQ,MAAR,EAAgBkB,MAAhB;AACAf,MAAAA,IAAI,CAACH,EAAL,CAAQ,KAAR,EAAemB,KAAf;AACD,KAxJD,EAwJGnB,EAxJH,CAwJM,OAxJN,EAwJe,UAASqC,GAAT,EAAc;AAC3B,UAAIlD,OAAJ,EACEA,OAAO,CAACf,IAAR,CAAa,OAAb,EAAsBiE,GAAtB;AACH,KA3JD;AA4JD,GArLD,EAqLGrC,EArLH,CAqLM,OArLN,EAqLe,UAASqC,GAAT,EAAc;AAC3BxF,IAAAA,GAAG,CAACuB,IAAJ,CAAS,OAAT,EAAkBiE,GAAlB;AACD,GAvLD,EAuLGrC,EAvLH,CAuLM,QAvLN,EAuLgB,YAAW;AACzBhC,IAAAA,QAAQ,GAAG,IAAX;AACAF,IAAAA,aAAa;AACd,GA1LD;AA2LD;;AAEDnB,SAAS,CAAC2F,SAAV,CAAoBC,KAApB,GAA4B,UAASC,KAAT,EAAgBvC,EAAhB,EAAoB;AAC9C,MAAIwC,CAAJ;AACA,MAAI,CAACA,CAAC,GAAG,KAAK1C,MAAL,CAAYwC,KAAZ,CAAkBC,KAAlB,CAAL,KAAkC,CAAC,KAAKlD,MAA5C,EACEW,EAAE,GADJ,KAEK;AACH,SAAKZ,UAAL,GAAkB,CAACoD,CAAnB;AACA,SAAKlD,GAAL,GAAWU,EAAX;AACD;AACF,CARD;;AAUAtD,SAAS,CAAC2F,SAAV,CAAoBI,GAApB,GAA0B,YAAW;AACnC,MAAIzF,IAAI,GAAG,IAAX;;AACA,MAAI,KAAKwC,OAAL,KAAiB,CAAjB,IAAsB,CAACxC,IAAI,CAACyC,IAAL,CAAUzB,KAArC,EAA4C;AAC1CC,IAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BlB,MAAAA,IAAI,CAACyC,IAAL,CAAUzB,KAAV,GAAkB,IAAlB;;AACAhB,MAAAA,IAAI,CAACyC,IAAL,CAAUtB,IAAV,CAAe,QAAf;AACD,KAHD;AAID,GALD,MAKO,IAAI,KAAK2B,MAAL,CAAY4C,QAAhB,EACL,KAAK5C,MAAL,CAAY2C,GAAZ;AACH,CATD;;AAWA,SAASrC,QAAT,CAAkBF,IAAlB,EAAwB;AACtBA,EAAAA,IAAI,CAACyC,MAAL;AACD;;AAED,SAASpB,UAAT,CAAoBqB,IAApB,EAA0B;AACxB,MAAI,EAAE,gBAAgBrB,UAAlB,CAAJ,EACE,OAAO,IAAIA,UAAJ,CAAeqB,IAAf,CAAP;AACF/G,EAAAA,cAAc,CAACgH,IAAf,CAAoB,IAApB,EAA0BD,IAA1B;AAEA,OAAKd,SAAL,GAAiB,KAAjB;AACD;;AACD9F,QAAQ,CAACuF,UAAD,EAAa1F,cAAb,CAAR;;AAEA0F,UAAU,CAACc,SAAX,CAAqBb,KAArB,GAA6B,UAASC,CAAT,EAAY,CAAE,CAA3C;;AAEAqB,MAAM,CAACC,OAAP,GAAiBrG,SAAjB","sourcesContent":["// TODO:\r\n//  * support 1 nested multipart level\r\n//    (see second multipart example here:\r\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\r\n//  * support limits.fieldNameSize\r\n//     -- this will require modifications to utils.parseParams\r\n\r\nvar ReadableStream = require('stream').Readable || require('readable-stream'),\r\n    inherits = require('util').inherits;\r\n\r\nvar Dicer = require('dicer');\r\n\r\nvar parseParams = require('../utils').parseParams,\r\n    decodeText = require('../utils').decodeText,\r\n    basename = require('../utils').basename;\r\n\r\nvar RE_BOUNDARY = /^boundary$/i,\r\n    RE_FIELD = /^form-data$/i,\r\n    RE_CHARSET = /^charset$/i,\r\n    RE_FILENAME = /^filename$/i,\r\n    RE_NAME = /^name$/i;\r\n\r\nMultipart.detect = /^multipart\\/form-data/i;\r\nfunction Multipart(boy, cfg) {\r\n  if (!(this instanceof Multipart))\r\n    return new Multipart(boy, cfg);\r\n  var i,\r\n      len,\r\n      self = this,\r\n      boundary,\r\n      limits = cfg.limits,\r\n      parsedConType = cfg.parsedConType || [],\r\n      defCharset = cfg.defCharset || 'utf8',\r\n      preservePath = cfg.preservePath,\r\n      fileopts = (typeof cfg.fileHwm === 'number'\r\n                  ? { highWaterMark: cfg.fileHwm }\r\n                  : {});\r\n\r\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\r\n    if (Array.isArray(parsedConType[i])\r\n        && RE_BOUNDARY.test(parsedConType[i][0])) {\r\n      boundary = parsedConType[i][1];\r\n      break;\r\n    }\r\n  }\r\n\r\n  function checkFinished() {\r\n    if (nends === 0 && finished && !boy._done) {\r\n      finished = false;\r\n      process.nextTick(function() {\r\n        boy._done = true;\r\n        boy.emit('finish');\r\n      });\r\n    }\r\n  }\r\n\r\n  if (typeof boundary !== 'string')\r\n    throw new Error('Multipart: Boundary not found');\r\n\r\n  var fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\r\n                        ? limits.fieldSize\r\n                        : 1 * 1024 * 1024),\r\n      fileSizeLimit = (limits && typeof limits.fileSize === 'number'\r\n                       ? limits.fileSize\r\n                       : Infinity),\r\n      filesLimit = (limits && typeof limits.files === 'number'\r\n                    ? limits.files\r\n                    : Infinity),\r\n      fieldsLimit = (limits && typeof limits.fields === 'number'\r\n                     ? limits.fields\r\n                     : Infinity),\r\n      partsLimit = (limits && typeof limits.parts === 'number'\r\n                    ? limits.parts\r\n                    : Infinity);\r\n\r\n  var nfiles = 0,\r\n      nfields = 0,\r\n      nends = 0,\r\n      curFile,\r\n      curField,\r\n      finished = false;\r\n\r\n  this._needDrain = false;\r\n  this._pause = false;\r\n  this._cb = undefined;\r\n  this._nparts = 0;\r\n  this._boy = boy;\r\n\r\n  var parserCfg = {\r\n    boundary: boundary,\r\n    maxHeaderPairs: (limits && limits.headerPairs)\r\n  };\r\n  if (fileopts.highWaterMark)\r\n    parserCfg.partHwm = fileopts.highWaterMark;\r\n  if (cfg.highWaterMark)\r\n    parserCfg.highWaterMark = cfg.highWaterMark;\r\n\r\n  this.parser = new Dicer(parserCfg);\r\n  this.parser.on('drain', function() {\r\n    self._needDrain = false;\r\n    if (self._cb && !self._pause) {\r\n      var cb = self._cb;\r\n      self._cb = undefined;\r\n      cb();\r\n    }\r\n  }).on('part', function onPart(part) {\r\n    if (++self._nparts > partsLimit) {\r\n      self.parser.removeListener('part', onPart);\r\n      self.parser.on('part', skipPart);\r\n      boy.hitPartsLimit = true;\r\n      boy.emit('partsLimit');\r\n      return skipPart(part);\r\n    }\r\n\r\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\r\n    // us emit 'end' early since we know the part has ended if we are already\r\n    // seeing the next part\r\n    if (curField) {\r\n      var field = curField;\r\n      field.emit('end');\r\n      field.removeAllListeners('end');\r\n    }\r\n\r\n    part.on('header', function(header) {\r\n      var contype,\r\n          fieldname,\r\n          parsed,\r\n          charset,\r\n          encoding,\r\n          filename,\r\n          nsize = 0;\r\n\r\n      if (header['content-type']) {\r\n        parsed = parseParams(header['content-type'][0]);\r\n        if (parsed[0]) {\r\n          contype = parsed[0].toLowerCase();\r\n          for (i = 0, len = parsed.length; i < len; ++i) {\r\n            if (RE_CHARSET.test(parsed[i][0])) {\r\n              charset = parsed[i][1].toLowerCase();\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (contype === undefined)\r\n        contype = 'text/plain';\r\n      if (charset === undefined)\r\n        charset = defCharset;\r\n\r\n      if (header['content-disposition']) {\r\n        parsed = parseParams(header['content-disposition'][0]);\r\n        if (!RE_FIELD.test(parsed[0]))\r\n          return skipPart(part);\r\n        for (i = 0, len = parsed.length; i < len; ++i) {\r\n          if (RE_NAME.test(parsed[i][0])) {\r\n            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');\r\n          } else if (RE_FILENAME.test(parsed[i][0])) {\r\n            filename = decodeText(parsed[i][1], 'binary', 'utf8');\r\n            if (!preservePath)\r\n              filename = basename(filename);\r\n          }\r\n        }\r\n      } else\r\n        return skipPart(part);\r\n\r\n      if (header['content-transfer-encoding'])\r\n        encoding = header['content-transfer-encoding'][0].toLowerCase();\r\n      else\r\n        encoding = '7bit';\r\n\r\n      var onData,\r\n          onEnd;\r\n      if (contype === 'application/octet-stream' || filename !== undefined) {\r\n        // file/binary field\r\n        if (nfiles === filesLimit) {\r\n          if (!boy.hitFilesLimit) {\r\n            boy.hitFilesLimit = true;\r\n            boy.emit('filesLimit');\r\n          }\r\n          return skipPart(part);\r\n        }\r\n\r\n        ++nfiles;\r\n\r\n        if (!boy._events.file) {\r\n          self.parser._ignore();\r\n          return;\r\n        }\r\n\r\n        ++nends;\r\n        var file = new FileStream(fileopts);\r\n        curFile = file;\r\n        file.on('end', function() {\r\n          --nends;\r\n          checkFinished();\r\n          if (self._cb && !self._needDrain) {\r\n            var cb = self._cb;\r\n            self._cb = undefined;\r\n            cb();\r\n          }\r\n        });\r\n        file._read = function(n) {\r\n          if (!self._pause)\r\n            return;\r\n          self._pause = false;\r\n          if (self._cb && !self._needDrain) {\r\n            var cb = self._cb;\r\n            self._cb = undefined;\r\n            cb();\r\n          }\r\n        };\r\n        boy.emit('file', fieldname, file, filename, encoding, contype);\r\n\r\n        onData = function(data) {\r\n          if ((nsize += data.length) > fileSizeLimit) {\r\n            var extralen = (fileSizeLimit - (nsize - data.length));\r\n            if (extralen > 0)\r\n              file.push(data.slice(0, extralen));\r\n            file.emit('limit');\r\n            file.truncated = true;\r\n            part.removeAllListeners('data');\r\n          } else if (!file.push(data))\r\n            self._pause = true;\r\n        };\r\n\r\n        onEnd = function() {\r\n          curFile = undefined;\r\n          file.push(null);\r\n        };\r\n      } else {\r\n        // non-file field\r\n        if (nfields === fieldsLimit) {\r\n          if (!boy.hitFieldsLimit) {\r\n            boy.hitFieldsLimit = true;\r\n            boy.emit('fieldsLimit');\r\n          }\r\n          return skipPart(part);\r\n        }\r\n\r\n        ++nfields;\r\n        ++nends;\r\n        var buffer = '',\r\n            truncated = false;\r\n        curField = part;\r\n\r\n        onData = function(data) {\r\n          if ((nsize += data.length) > fieldSizeLimit) {\r\n            var extralen = (fieldSizeLimit - (nsize - data.length));\r\n            buffer += data.toString('binary', 0, extralen);\r\n            truncated = true;\r\n            part.removeAllListeners('data');\r\n          } else\r\n            buffer += data.toString('binary');\r\n        };\r\n\r\n        onEnd = function() {\r\n          curField = undefined;\r\n          if (buffer.length)\r\n            buffer = decodeText(buffer, 'binary', charset);\r\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\r\n          --nends;\r\n          checkFinished();\r\n        };\r\n      }\r\n\r\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\r\n         broken. Streams2/streams3 is a huge black box of confusion, but\r\n         somehow overriding the sync state seems to fix things again (and still\r\n         seems to work for previous node versions).\r\n      */\r\n      part._readableState.sync = false;\r\n\r\n      part.on('data', onData);\r\n      part.on('end', onEnd);\r\n    }).on('error', function(err) {\r\n      if (curFile)\r\n        curFile.emit('error', err);\r\n    });\r\n  }).on('error', function(err) {\r\n    boy.emit('error', err);\r\n  }).on('finish', function() {\r\n    finished = true;\r\n    checkFinished();\r\n  });\r\n}\r\n\r\nMultipart.prototype.write = function(chunk, cb) {\r\n  var r;\r\n  if ((r = this.parser.write(chunk)) && !this._pause)\r\n    cb();\r\n  else {\r\n    this._needDrain = !r;\r\n    this._cb = cb;\r\n  }\r\n};\r\n\r\nMultipart.prototype.end = function() {\r\n  var self = this;\r\n  if (this._nparts === 0 && !self._boy._done) {\r\n    process.nextTick(function() {\r\n      self._boy._done = true;\r\n      self._boy.emit('finish');\r\n    });\r\n  } else if (this.parser.writable)\r\n    this.parser.end();\r\n};\r\n\r\nfunction skipPart(part) {\r\n  part.resume();\r\n}\r\n\r\nfunction FileStream(opts) {\r\n  if (!(this instanceof FileStream))\r\n    return new FileStream(opts);\r\n  ReadableStream.call(this, opts);\r\n\r\n  this.truncated = false;\r\n}\r\ninherits(FileStream, ReadableStream);\r\n\r\nFileStream.prototype._read = function(n) {};\r\n\r\nmodule.exports = Multipart;\r\n"]},"metadata":{},"sourceType":"script"}