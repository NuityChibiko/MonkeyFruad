{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\n\nconst call_1 = require(\"../call\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst resourceCollector_1 = require(\"./resourceCollector\");\n\nclass PagedApiCaller {\n  /**\r\n   * Creates an API caller that returns a stream to performs page-streaming.\r\n   *\r\n   * @private\r\n   * @constructor\r\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\r\n   *   of page streaming to be performed.\r\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\r\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\r\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\r\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\r\n   *\r\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\r\n   * pagination-specific fields in the response, and call the users' callback after having those fields\r\n   * parsed.\r\n   *\r\n   * @param request Request object. It needs to be passed to all subsequent next page requests\r\n   * (the main content of the request object stays unchanged, only the next page token changes)\r\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\r\n   */\n\n\n  generateParseResponseCallback(request, callback) {\n    const resourceFieldName = this.pageDescriptor.resourceField;\n    const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n    const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n    return (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!request) {\n        callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n        return;\n      }\n\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n\n      const resources = response[resourceFieldName];\n      const pageToken = response[responsePageTokenFieldName];\n      let nextPageRequest = null;\n\n      if (pageToken) {\n        nextPageRequest = Object.assign({}, request);\n        nextPageRequest[requestPageTokenFieldName] = pageToken;\n      }\n\n      callback(err, resources, nextPageRequest, response);\n    };\n  }\n  /**\r\n   * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\r\n   * The original gRPC call just calls callback(err, result).\r\n   * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\r\n   *\r\n   * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\r\n   * request, metadata, call options, and callback.\r\n   */\n\n\n  wrap(func) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n    };\n  }\n  /**\r\n   * Makes it possible to use both callback-based and promise-based calls.\r\n   * Returns an OngoingCall or OngoingCallPromise object.\r\n   * Regardless of which one is returned, it always has a `.callback` to call.\r\n   *\r\n   * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\r\n   * @param [callback] Callback to be called, if any.\r\n   */\n\n\n  init(callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n\n    return new call_1.OngoingCallPromise();\n  }\n  /**\r\n   * Implements auto-pagination logic.\r\n   *\r\n   * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\r\n   * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\r\n   * accept just two parameters: (request, callback).\r\n   * @param request A request object that came from the user.\r\n   * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\r\n   * (they are all optional).\r\n   * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\r\n   * and is used to return results to the user.\r\n   */\n\n\n  call(apiCall, request, settings, ongoingCall) {\n    request = Object.assign({}, request); // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n\n    if (settings.pageToken) {\n      request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n    }\n\n    if (settings.pageSize) {\n      request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n    }\n\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      ongoingCall.call(apiCall, request);\n      return;\n    }\n\n    const maxResults = settings.maxResults || -1;\n    const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n    resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n  }\n\n  fail(ongoingCall, err) {\n    ongoingCall.callback(err);\n  }\n\n  result(ongoingCall) {\n    return ongoingCall.promise;\n  }\n\n}\n\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"sources":["../../../src/paginationCalls/pagedApiCaller.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAWH,MAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,MAAa,cAAb,CAA2B;AAEzB;;;;;;;AAOG;AACH,EAAA,WAAA,CAAY,cAAZ,EAA0C;AACxC,SAAK,cAAL,GAAsB,cAAtB;AACD;AAED;;;;;;;;;;;;AAYG;;;AACK,EAAA,6BAA6B,CACnC,OADmC,EAEnC,QAFmC,EAEd;AAErB,UAAM,iBAAiB,GAAG,KAAK,cAAL,CAAoB,aAA9C;AACA,UAAM,0BAA0B,GAAG,KAAK,cAAL,CAChC,sBADH;AAEA,UAAM,yBAAyB,GAAG,KAAK,cAAL,CAAoB,qBAAtD;AACA,WAAO,CAAC,GAAD,EAAoB,QAApB,KAAiE;AACtE,UAAI,GAAJ,EAAS;AACP,QAAA,QAAQ,CAAC,GAAD,CAAR;AACA;AACD;;AACD,UAAI,CAAC,OAAL,EAAc;AACZ,QAAA,QAAQ,CACN,IAAI,aAAA,CAAA,WAAJ,CAAgB,kDAAhB,CADM,CAAR;AAGA;AACD;;AACD,UAAI,CAAC,QAAL,EAAe;AACb,QAAA,QAAQ,CACN,IAAI,aAAA,CAAA,WAAJ,CAAgB,mDAAhB,CADM,CAAR;AAGA;AACD;;AACD,YAAM,SAAS,GAAG,QAAQ,CAAC,iBAAD,CAA1B;AACA,YAAM,SAAS,GAAG,QAAQ,CAAC,0BAAD,CAA1B;AACA,UAAI,eAAe,GAAG,IAAtB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAlB;AACA,QAAA,eAAe,CAAC,yBAAD,CAAf,GAA6C,SAA7C;AACD;;AACD,MAAA,QAAQ,CAAC,GAAD,EAAM,SAAN,EAAiB,eAAjB,EAAkC,QAAlC,CAAR;AACD,KAzBD;AA0BD;AAED;;;;;;;AAOG;;;AACH,EAAA,IAAI,CAAC,IAAD,EAAe;AACjB;AACA,UAAM,IAAI,GAAG,IAAb;AACA,WAAO,SAAS,WAAT,CAAqB,QAArB,EAA+B,QAA/B,EAAyC,OAAzC,EAAkD,QAAlD,EAA0D;AAC/D,aAAQ,IAAkB,CACxB,QADwB,EAExB,QAFwB,EAGxB,OAHwB,EAIxB,IAAI,CAAC,6BAAL,CAAmC,QAAnC,EAA6C,QAA7C,CAJwB,CAA1B;AAMD,KAPD;AAQD;AAED;;;;;;;AAOG;;;AACH,EAAA,IAAI,CAAC,QAAD,EAAuB;AACzB,QAAI,QAAJ,EAAc;AACZ,aAAO,IAAI,MAAA,CAAA,WAAJ,CAAgB,QAAhB,CAAP;AACD;;AACD,WAAO,IAAI,MAAA,CAAA,kBAAJ,EAAP;AACD;AAED;;;;;;;;;;;AAWG;;;AACH,EAAA,IAAI,CACF,OADE,EAEF,OAFE,EAGF,QAHE,EAIF,WAJE,EAIsB;AAExB,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAV,CAFwB,CAIxB;;AACA,QAAI,QAAQ,CAAC,SAAb,EAAwB;AACtB,MAAA,OAAO,CAAC,KAAK,cAAL,CAAoB,qBAArB,CAAP,GAAqD,QAAQ,CAAC,SAA9D;AACD;;AACD,QAAI,QAAQ,CAAC,QAAb,EAAuB;AACrB,MAAA,OAAO,CAAC,KAAK,cAAL,CAAoB,oBAArB,CAAP,GAAqD,QAAQ,CAAC,QAA9D;AACD;;AAED,QAAI,CAAC,QAAQ,CAAC,YAAd,EAA4B;AAC1B;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,OAAjB,EAA0B,OAA1B;AACA;AACD;;AAED,UAAM,UAAU,GAAG,QAAQ,CAAC,UAAT,IAAuB,CAAC,CAA3C;AAEA,UAAM,iBAAiB,GAAG,IAAI,mBAAA,CAAA,iBAAJ,CAAsB,OAAtB,EAA+B,UAA/B,CAA1B;AACA,IAAA,iBAAiB,CAAC,eAAlB,CAAkC,OAAlC,EAA2C,IAA3C,CACE,SAAS,IAAI,WAAW,CAAC,QAAZ,CAAqB,IAArB,EAA2B,SAA3B,CADf,EAEE,GAAG,IAAI,WAAW,CAAC,QAAZ,CAAqB,GAArB,CAFT;AAID;;AAED,EAAA,IAAI,CAAC,WAAD,EAAkC,GAAlC,EAAkD;AACpD,IAAA,WAAW,CAAC,QAAZ,CAAsB,GAAtB;AACD;;AAED,EAAA,MAAM,CAAC,WAAD,EAAgC;AACpC,WAAO,WAAW,CAAC,OAAnB;AACD;;AApJwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PagedApiCaller = void 0;\r\nconst call_1 = require(\"../call\");\r\nconst googleError_1 = require(\"../googleError\");\r\nconst resourceCollector_1 = require(\"./resourceCollector\");\r\nclass PagedApiCaller {\r\n    /**\r\n     * Creates an API caller that returns a stream to performs page-streaming.\r\n     *\r\n     * @private\r\n     * @constructor\r\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\r\n     *   of page streaming to be performed.\r\n     */\r\n    constructor(pageDescriptor) {\r\n        this.pageDescriptor = pageDescriptor;\r\n    }\r\n    /**\r\n     * This function translates between regular gRPC calls (that accepts a request and returns a response,\r\n     * and does not know anything about pages and page tokens) and the users' callback (that expects\r\n     * to see resources from one page, a request to get the next page, and the raw response from the server).\r\n     *\r\n     * It generates a function that can be passed as a callback function to a gRPC call, will understand\r\n     * pagination-specific fields in the response, and call the users' callback after having those fields\r\n     * parsed.\r\n     *\r\n     * @param request Request object. It needs to be passed to all subsequent next page requests\r\n     * (the main content of the request object stays unchanged, only the next page token changes)\r\n     * @param callback The user's callback that expects the page content, next page request, and raw response.\r\n     */\r\n    generateParseResponseCallback(request, callback) {\r\n        const resourceFieldName = this.pageDescriptor.resourceField;\r\n        const responsePageTokenFieldName = this.pageDescriptor\r\n            .responsePageTokenField;\r\n        const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\r\n        return (err, response) => {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            if (!request) {\r\n                callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\r\n                return;\r\n            }\r\n            if (!response) {\r\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\r\n                return;\r\n            }\r\n            const resources = response[resourceFieldName];\r\n            const pageToken = response[responsePageTokenFieldName];\r\n            let nextPageRequest = null;\r\n            if (pageToken) {\r\n                nextPageRequest = Object.assign({}, request);\r\n                nextPageRequest[requestPageTokenFieldName] = pageToken;\r\n            }\r\n            callback(err, resources, nextPageRequest, response);\r\n        };\r\n    }\r\n    /**\r\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\r\n     * The original gRPC call just calls callback(err, result).\r\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\r\n     *\r\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\r\n     * request, metadata, call options, and callback.\r\n     */\r\n    wrap(func) {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        return function wrappedCall(argument, metadata, options, callback) {\r\n            return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\r\n        };\r\n    }\r\n    /**\r\n     * Makes it possible to use both callback-based and promise-based calls.\r\n     * Returns an OngoingCall or OngoingCallPromise object.\r\n     * Regardless of which one is returned, it always has a `.callback` to call.\r\n     *\r\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\r\n     * @param [callback] Callback to be called, if any.\r\n     */\r\n    init(callback) {\r\n        if (callback) {\r\n            return new call_1.OngoingCall(callback);\r\n        }\r\n        return new call_1.OngoingCallPromise();\r\n    }\r\n    /**\r\n     * Implements auto-pagination logic.\r\n     *\r\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\r\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\r\n     * accept just two parameters: (request, callback).\r\n     * @param request A request object that came from the user.\r\n     * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\r\n     * (they are all optional).\r\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\r\n     * and is used to return results to the user.\r\n     */\r\n    call(apiCall, request, settings, ongoingCall) {\r\n        request = Object.assign({}, request);\r\n        // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\r\n        if (settings.pageToken) {\r\n            request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\r\n        }\r\n        if (settings.pageSize) {\r\n            request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\r\n        }\r\n        if (!settings.autoPaginate) {\r\n            // they don't want auto-pagination this time - okay, just call once\r\n            ongoingCall.call(apiCall, request);\r\n            return;\r\n        }\r\n        const maxResults = settings.maxResults || -1;\r\n        const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\r\n        resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\r\n    }\r\n    fail(ongoingCall, err) {\r\n        ongoingCall.callback(err);\r\n    }\r\n    result(ongoingCall) {\r\n        return ongoingCall.promise;\r\n    }\r\n}\r\nexports.PagedApiCaller = PagedApiCaller;\r\n//# sourceMappingURL=pagedApiCaller.js.map"]},"metadata":{},"sourceType":"script"}