{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst reference_1 = require(\"./reference\");\n\nconst path_1 = require(\"./path\");\n\nconst serializer_1 = require(\"./serializer\");\n/**\r\n * A split point that can be used in a query as a starting and/or end point for\r\n * the query results. The cursors returned by {@link #startAt} and {@link\r\n * #endBefore} can only be used in a query that matches the constraint of query\r\n * that produced this partition.\r\n *\r\n * @class QueryPartition\r\n */\n\n\nclass QueryPartition {\n  /** @hideconstructor */\n  constructor(_firestore, _collectionId, _converter, _startAt, _endBefore) {\n    this._firestore = _firestore;\n    this._collectionId = _collectionId;\n    this._converter = _converter;\n    this._startAt = _startAt;\n    this._endBefore = _endBefore;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\r\n   * The cursor that defines the first result for this partition or `undefined`\r\n   * if this is the first partition. The cursor value must be\r\n   * destructured when passed to `startAt()` (for example with\r\n   * `query.startAt(...queryPartition.startAt)`).\r\n   *\r\n   * @example\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n   *   if (partition.startAt) {\r\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n   *   }\r\n   *   if (partition.endBefore) {\r\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n   *   }\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * @type {Array<*>}\r\n   * @return {Array<*>} A cursor value that can be used with {@link\r\n   * Query#startAt} or `undefined` if this is the first partition.\r\n   */\n\n\n  get startAt() {\n    if (this._startAt && !this._memoizedStartAt) {\n      this._memoizedStartAt = this._startAt.map(v => this._serializer.decodeValue(v));\n    }\n\n    return this._memoizedStartAt;\n  }\n  /**\r\n   * The cursor that defines the first result after this partition or\r\n   * `undefined` if this is the last partition.  The cursor value must be\r\n   * destructured when passed to `endBefore()` (for example with\r\n   * `query.endBefore(...queryPartition.endBefore)`).\r\n   *\r\n   * @example\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n   *   if (partition.startAt) {\r\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n   *   }\r\n   *   if (partition.endBefore) {\r\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n   *   }\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * @type {Array<*>}\r\n   * @return {Array<*>} A cursor value that can be used with {@link\r\n   * Query#endBefore} or `undefined` if this is the last partition.\r\n   */\n\n\n  get endBefore() {\n    if (this._endBefore && !this._memoizedEndBefore) {\n      this._memoizedEndBefore = this._endBefore.map(v => this._serializer.decodeValue(v));\n    }\n\n    return this._memoizedEndBefore;\n  }\n  /**\r\n   * Returns a query that only encapsulates the documents for this partition.\r\n   *\r\n   * @example\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   const partitionedQuery = partition.toQuery();\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\r\n   * {@link Query#endBefore} cursor.\r\n   */\n\n\n  toQuery() {\n    // Since the api.Value to JavaScript type conversion can be lossy (unless\n    // `useBigInt` is used), we pass the original protobuf representaion to the\n    // created query.\n    let queryOptions = reference_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\n    queryOptions = queryOptions.with({\n      fieldOrders: [new reference_1.FieldOrder(path_1.FieldPath.documentId())]\n    });\n\n    if (this._startAt !== undefined) {\n      queryOptions = queryOptions.with({\n        startAt: {\n          before: true,\n          values: this._startAt\n        }\n      });\n    }\n\n    if (this._endBefore !== undefined) {\n      queryOptions = queryOptions.with({\n        endAt: {\n          before: true,\n          values: this._endBefore\n        }\n      });\n    }\n\n    return new reference_1.Query(this._firestore, queryOptions);\n  }\n\n}\n\nexports.QueryPartition = QueryPartition;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/query-partition.js"],"names":["Object","defineProperty","exports","value","reference_1","require","path_1","serializer_1","QueryPartition","constructor","_firestore","_collectionId","_converter","_startAt","_endBefore","_serializer","Serializer","startAt","_memoizedStartAt","map","v","decodeValue","endBefore","_memoizedEndBefore","toQuery","queryOptions","QueryOptions","forCollectionGroupQuery","with","fieldOrders","FieldOrder","FieldPath","documentId","undefined","before","values","endAt","Query"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst reference_1 = require(\"./reference\");\r\nconst path_1 = require(\"./path\");\r\nconst serializer_1 = require(\"./serializer\");\r\n/**\r\n * A split point that can be used in a query as a starting and/or end point for\r\n * the query results. The cursors returned by {@link #startAt} and {@link\r\n * #endBefore} can only be used in a query that matches the constraint of query\r\n * that produced this partition.\r\n *\r\n * @class QueryPartition\r\n */\r\nclass QueryPartition {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _collectionId, _converter, _startAt, _endBefore) {\r\n        this._firestore = _firestore;\r\n        this._collectionId = _collectionId;\r\n        this._converter = _converter;\r\n        this._startAt = _startAt;\r\n        this._endBefore = _endBefore;\r\n        this._serializer = new serializer_1.Serializer(_firestore);\r\n    }\r\n    /**\r\n     * The cursor that defines the first result for this partition or `undefined`\r\n     * if this is the first partition. The cursor value must be\r\n     * destructured when passed to `startAt()` (for example with\r\n     * `query.startAt(...queryPartition.startAt)`).\r\n     *\r\n     * @example\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n     *   if (partition.startAt) {\r\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n     *   }\r\n     *   if (partition.endBefore) {\r\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n     *   }\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * @type {Array<*>}\r\n     * @return {Array<*>} A cursor value that can be used with {@link\r\n     * Query#startAt} or `undefined` if this is the first partition.\r\n     */\r\n    get startAt() {\r\n        if (this._startAt && !this._memoizedStartAt) {\r\n            this._memoizedStartAt = this._startAt.map(v => this._serializer.decodeValue(v));\r\n        }\r\n        return this._memoizedStartAt;\r\n    }\r\n    /**\r\n     * The cursor that defines the first result after this partition or\r\n     * `undefined` if this is the last partition.  The cursor value must be\r\n     * destructured when passed to `endBefore()` (for example with\r\n     * `query.endBefore(...queryPartition.endBefore)`).\r\n     *\r\n     * @example\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\r\n     *   if (partition.startAt) {\r\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\r\n     *   }\r\n     *   if (partition.endBefore) {\r\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\r\n     *   }\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * @type {Array<*>}\r\n     * @return {Array<*>} A cursor value that can be used with {@link\r\n     * Query#endBefore} or `undefined` if this is the last partition.\r\n     */\r\n    get endBefore() {\r\n        if (this._endBefore && !this._memoizedEndBefore) {\r\n            this._memoizedEndBefore = this._endBefore.map(v => this._serializer.decodeValue(v));\r\n        }\r\n        return this._memoizedEndBefore;\r\n    }\r\n    /**\r\n     * Returns a query that only encapsulates the documents for this partition.\r\n     *\r\n     * @example\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   const partitionedQuery = partition.toQuery();\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\r\n     * {@link Query#endBefore} cursor.\r\n     */\r\n    toQuery() {\r\n        // Since the api.Value to JavaScript type conversion can be lossy (unless\r\n        // `useBigInt` is used), we pass the original protobuf representaion to the\r\n        // created query.\r\n        let queryOptions = reference_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\r\n        queryOptions = queryOptions.with({\r\n            fieldOrders: [new reference_1.FieldOrder(path_1.FieldPath.documentId())],\r\n        });\r\n        if (this._startAt !== undefined) {\r\n            queryOptions = queryOptions.with({\r\n                startAt: { before: true, values: this._startAt },\r\n            });\r\n        }\r\n        if (this._endBefore !== undefined) {\r\n            queryOptions = queryOptions.with({\r\n                endAt: { before: true, values: this._endBefore },\r\n            });\r\n        }\r\n        return new reference_1.Query(this._firestore, queryOptions);\r\n    }\r\n}\r\nexports.QueryPartition = QueryPartition;\r\n//# sourceMappingURL=query-partition.js.map"]},"metadata":{},"sourceType":"script"}