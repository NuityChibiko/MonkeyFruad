{"ast":null,"code":"/*\r\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\r\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\r\n*/\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2) if (buf1[pos1] !== buf2[pos2]) return false;\n\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string') needle = new Buffer(needle);\n  var i,\n      j,\n      needle_len = needle.length;\n  this.maxMatches = Infinity;\n  this.matches = 0;\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n  this._lookbehind = new Buffer(needle_len); // Initialize occurrence table.\n\n  for (j = 0; j < 256; ++j) this._occ[j] = needle_len; // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n\n\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i) this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\n\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function () {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function (chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk)) chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n\n  while (r !== chlen && this.matches < this.maxMatches) r = this._sbmh_feed(chunk);\n\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function (data) {\n  var len = data.length,\n      needle = this._needle,\n      needle_len = needle.length; // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n      var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size) this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);else this.emit('info', true);\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else pos += occ[ch];\n    } // No match.\n\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0) pos += this._bufpos; // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char && data[pos] === needle[0] && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0) this.emit('info', true, data, this._bufpos, pos);else this.emit('info', true);\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else pos += occ[ch];\n  } // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n\n\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0] || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  } // Everything until pos is guaranteed not to contain needle data.\n\n\n  if (pos > 0) this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\n  if (pos < 0) return this._lookbehind[this._lookbehind_size + pos];else return data[pos];\n};\n\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i]) ++i;else return false;\n  }\n\n  return true;\n};\n\nmodule.exports = SBMH;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/streamsearch/lib/sbmh.js"],"names":["EventEmitter","require","inherits","jsmemcmp","buf1","pos1","buf2","pos2","num","i","SBMH","needle","Buffer","j","needle_len","length","maxMatches","Infinity","matches","_occ","Array","_lookbehind_size","_needle","_bufpos","_lookbehind","prototype","reset","push","chunk","pos","r","chlen","isBuffer","_sbmh_feed","data","len","last_needle_char","occ","lookbehind","ch","_sbmh_lookup_char","_sbmh_memcmp","emit","bytesToCutOff","copy","module","exports"],"mappings":"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","sourcesContent":["/*\r\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\r\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\r\n*/\r\nvar EventEmitter = require('events').EventEmitter,\r\n    inherits = require('util').inherits;\r\n\r\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\r\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\r\n    if (buf1[pos1] !== buf2[pos2])\r\n      return false;\r\n  return true;\r\n}\r\n\r\nfunction SBMH(needle) {\r\n  if (typeof needle === 'string')\r\n    needle = new Buffer(needle);\r\n  var i, j, needle_len = needle.length;\r\n\r\n  this.maxMatches = Infinity;\r\n  this.matches = 0;\r\n\r\n  this._occ = new Array(256);\r\n  this._lookbehind_size = 0;\r\n  this._needle = needle;\r\n  this._bufpos = 0;\r\n\r\n  this._lookbehind = new Buffer(needle_len);\r\n\r\n  // Initialize occurrence table.\r\n  for (j = 0; j < 256; ++j)\r\n    this._occ[j] = needle_len;\r\n\r\n  // Populate occurrence table with analysis of the needle,\r\n  // ignoring last letter.\r\n  if (needle_len >= 1) {\r\n    for (i = 0; i < needle_len - 1; ++i)\r\n      this._occ[needle[i]] = needle_len - 1 - i;\r\n  }\r\n}\r\ninherits(SBMH, EventEmitter);\r\n\r\nSBMH.prototype.reset = function() {\r\n  this._lookbehind_size = 0;\r\n  this.matches = 0;\r\n  this._bufpos = 0;\r\n};\r\n\r\nSBMH.prototype.push = function(chunk, pos) {\r\n  var r, chlen;\r\n  if (!Buffer.isBuffer(chunk))\r\n    chunk = new Buffer(chunk, 'binary');\r\n  chlen = chunk.length;\r\n  this._bufpos = pos || 0;\r\n  while (r !== chlen && this.matches < this.maxMatches)\r\n    r = this._sbmh_feed(chunk);\r\n  return r;\r\n};\r\n\r\nSBMH.prototype._sbmh_feed = function(data) {\r\n  var len = data.length, needle = this._needle, needle_len = needle.length;\r\n\r\n  // Positive: points to a position in `data`\r\n  //           pos == 3 points to data[3]\r\n  // Negative: points to a position in the lookbehind buffer\r\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\r\n  var pos = -this._lookbehind_size,\r\n      last_needle_char = needle[needle_len - 1],\r\n      occ = this._occ,\r\n      lookbehind = this._lookbehind;\r\n\r\n  if (pos < 0) {\r\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\r\n    // search with character lookup code that considers both the\r\n    // lookbehind buffer and the current round's haystack data.\r\n    //\r\n    // Loop until\r\n    //   there is a match.\r\n    // or until\r\n    //   we've moved past the position that requires the\r\n    //   lookbehind buffer. In this case we switch to the\r\n    //   optimized loop.\r\n    // or until\r\n    //   the character to look at lies outside the haystack.\r\n    while (pos < 0 && pos <= len - needle_len) {\r\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\r\n\r\n      if (ch === last_needle_char\r\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\r\n        this._lookbehind_size = 0;\r\n        ++this.matches;\r\n        if (pos > -this._lookbehind_size)\r\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\r\n        else\r\n          this.emit('info', true);\r\n\r\n        this._bufpos = pos + needle_len;\r\n        return pos + needle_len;\r\n      } else\r\n        pos += occ[ch];\r\n    }\r\n\r\n    // No match.\r\n\r\n    if (pos < 0) {\r\n      // There's too few data for Boyer-Moore-Horspool to run,\r\n      // so let's use a different algorithm to skip as much as\r\n      // we can.\r\n      // Forward pos until\r\n      //   the trailing part of lookbehind + data\r\n      //   looks like the beginning of the needle\r\n      // or until\r\n      //   pos == 0\r\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\r\n        pos++;\r\n    }\r\n\r\n    if (pos >= 0) {\r\n      // Discard lookbehind buffer.\r\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\r\n      this._lookbehind_size = 0;\r\n    } else {\r\n      // Cut off part of the lookbehind buffer that has\r\n      // been processed and append the entire haystack\r\n      // into it.\r\n      var bytesToCutOff = this._lookbehind_size + pos;\r\n\r\n      if (bytesToCutOff > 0) {\r\n        // The cut off data is guaranteed not to contain the needle.\r\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\r\n      }\r\n\r\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\r\n                      this._lookbehind_size - bytesToCutOff);\r\n      this._lookbehind_size -= bytesToCutOff;\r\n\r\n      data.copy(lookbehind, this._lookbehind_size);\r\n      this._lookbehind_size += len;\r\n\r\n      this._bufpos = len;\r\n      return len;\r\n    }\r\n  }\r\n\r\n  if (pos >= 0)\r\n    pos += this._bufpos;\r\n\r\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\r\n  // search with optimized character lookup code that only considers\r\n  // the current round's haystack data.\r\n  while (pos <= len - needle_len) {\r\n    var ch = data[pos + needle_len - 1];\r\n\r\n    if (ch === last_needle_char\r\n        && data[pos] === needle[0]\r\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\r\n      ++this.matches;\r\n      if (pos > 0)\r\n        this.emit('info', true, data, this._bufpos, pos);\r\n      else\r\n        this.emit('info', true);\r\n\r\n      this._bufpos = pos + needle_len;\r\n      return pos + needle_len;\r\n    } else\r\n      pos += occ[ch];\r\n  }\r\n\r\n  // There was no match. If there's trailing haystack data that we cannot\r\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\r\n  // data is less than the needle size) then match using a modified\r\n  // algorithm that starts matching from the beginning instead of the end.\r\n  // Whatever trailing data is left after running this algorithm is added to\r\n  // the lookbehind buffer.\r\n  if (pos < len) {\r\n    while (pos < len && (data[pos] !== needle[0]\r\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\r\n      ++pos;\r\n    }\r\n    if (pos < len) {\r\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\r\n      this._lookbehind_size = len - pos;\r\n    }\r\n  }\r\n\r\n  // Everything until pos is guaranteed not to contain needle data.\r\n  if (pos > 0)\r\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\r\n\r\n  this._bufpos = len;\r\n  return len;\r\n};\r\n\r\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\r\n  if (pos < 0)\r\n    return this._lookbehind[this._lookbehind_size + pos];\r\n  else\r\n    return data[pos];\r\n}\r\n\r\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\r\n  var i = 0;\r\n\r\n  while (i < len) {\r\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\r\n      ++i;\r\n    else\r\n      return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nmodule.exports = SBMH;\r\n"]},"metadata":{},"sourceType":"script"}