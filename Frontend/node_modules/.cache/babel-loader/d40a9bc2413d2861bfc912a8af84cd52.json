{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require(\"fast-deep-equal\");\n\nconst assert = require(\"assert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n/**\r\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\r\n * Invoke `.build()' to assemble the final snapshot.\r\n *\r\n * @private\r\n */\n\n\nclass DocumentSnapshotBuilder {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\r\n   * Builds the DocumentSnapshot.\r\n   *\r\n   * @private\r\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\r\n   * provided) or a DocumentSnapshot.\r\n   */\n\n\n  build() {\n    assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n    assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n    return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n  }\n\n}\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\r\n * A DocumentSnapshot is an immutable representation for a document in a\r\n * Firestore database. The data can be extracted with\r\n * [data()]{@link DocumentSnapshot#data} or\r\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\r\n * specific field.\r\n *\r\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the\r\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\r\n * document's existence.\r\n *\r\n * @class DocumentSnapshot\r\n */\n\nclass DocumentSnapshot {\n  /**\r\n   * @hideconstructor\r\n   *\r\n   * @param ref The reference to the document.\r\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\r\n   * this document (or undefined if the document does not exist).\r\n   * @param readTime The time when this snapshot was read  (or undefined if\r\n   * the document exists only locally).\r\n   * @param createTime The time when the document was created (or undefined if\r\n   * the document does not exist).\r\n   * @param updateTime The time when the document was last updated (or undefined\r\n   * if the document does not exist).\r\n   */\n  constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\r\n   * Creates a DocumentSnapshot from an object.\r\n   *\r\n   * @private\r\n   * @param ref The reference to the document.\r\n   * @param obj The object to store in the DocumentSnapshot.\r\n   * @return The created DocumentSnapshot.\r\n   */\n\n\n  static fromObject(ref, obj) {\n    const serializer = ref.firestore._serializer;\n    return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n  }\n  /**\r\n   * Creates a DocumentSnapshot from an UpdateMap.\r\n   *\r\n   * This methods expands the top-level field paths in a JavaScript map and\r\n   * turns { foo.bar : foobar } into { foo { bar : foobar }}\r\n   *\r\n   * @private\r\n   * @param ref The reference to the document.\r\n   * @param data The field/value map to expand.\r\n   * @return The created DocumentSnapshot.\r\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const serializer = ref.firestore._serializer;\n    /**\r\n     * Merges 'value' at the field path specified by the path array into\r\n     * 'target'.\r\n     */\n\n    function merge(target, value, path, pos) {\n      const key = path[pos];\n      const isLast = pos === path.length - 1;\n\n      if (target[key] === undefined) {\n        if (isLast) {\n          if (value instanceof field_value_1.FieldTransform) {\n            // If there is already data at this path, we need to retain it.\n            // Otherwise, we don't include it in the DocumentSnapshot.\n            return !util_1.isEmpty(target) ? target : null;\n          } // The merge is done.\n\n\n          const leafNode = serializer.encodeValue(value);\n\n          if (leafNode) {\n            target[key] = leafNode;\n          }\n\n          return target;\n        } else {\n          // We need to expand the target object.\n          const childNode = {\n            mapValue: {\n              fields: {}\n            }\n          };\n          const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n          if (nestedValue) {\n            childNode.mapValue.fields = nestedValue;\n            target[key] = childNode;\n            return target;\n          } else {\n            return !util_1.isEmpty(target) ? target : null;\n          }\n        }\n      } else {\n        assert(!isLast, \"Can't merge current value into a nested object\");\n        target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n        return target;\n      }\n    }\n\n    const res = {};\n\n    for (const [key, value] of data) {\n      const path = key.toArray();\n      merge(res, value, path, 0);\n    }\n\n    return new DocumentSnapshot(ref, res);\n  }\n  /**\r\n   * True if the document exists.\r\n   *\r\n   * @type {boolean}\r\n   * @name DocumentSnapshot#exists\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then((documentSnapshot) => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\r\n   *   }\r\n   * });\r\n   */\n\n\n  get exists() {\n    return this._fieldsProto !== undefined;\n  }\n  /**\r\n   * A [DocumentReference]{@link DocumentReference} for the document\r\n   * stored in this snapshot.\r\n   *\r\n   * @type {DocumentReference}\r\n   * @name DocumentSnapshot#ref\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then((documentSnapshot) => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\r\n   *   }\r\n   * });\r\n   */\n\n\n  get ref() {\n    return this._ref;\n  }\n  /**\r\n   * The ID of the document for which this DocumentSnapshot contains data.\r\n   *\r\n   * @type {string}\r\n   * @name DocumentSnapshot#id\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then((documentSnapshot) => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     console.log(`Document found with name '${documentSnapshot.id}'`);\r\n   *   }\r\n   * });\r\n   */\n\n\n  get id() {\n    return this._ref.id;\n  }\n  /**\r\n   * The time the document was created. Undefined for documents that don't\r\n   * exist.\r\n   *\r\n   * @type {Timestamp|undefined}\r\n   * @name DocumentSnapshot#createTime\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(documentSnapshot => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     let createTime = documentSnapshot.createTime;\r\n   *     console.log(`Document created at '${createTime.toDate()}'`);\r\n   *   }\r\n   * });\r\n   */\n\n\n  get createTime() {\n    return this._createTime;\n  }\n  /**\r\n   * The time the document was last updated (at the time the snapshot was\r\n   * generated). Undefined for documents that don't exist.\r\n   *\r\n   * @type {Timestamp|undefined}\r\n   * @name DocumentSnapshot#updateTime\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(documentSnapshot => {\r\n   *   if (documentSnapshot.exists) {\r\n   *     let updateTime = documentSnapshot.updateTime;\r\n   *     console.log(`Document updated at '${updateTime.toDate()}'`);\r\n   *   }\r\n   * });\r\n   */\n\n\n  get updateTime() {\n    return this._updateTime;\n  }\n  /**\r\n   * The time this snapshot was read.\r\n   *\r\n   * @type {Timestamp}\r\n   * @name DocumentSnapshot#readTime\r\n   * @readonly\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(documentSnapshot => {\r\n   *   let readTime = documentSnapshot.readTime;\r\n   *   console.log(`Document read at '${readTime.toDate()}'`);\r\n   * });\r\n   */\n\n\n  get readTime() {\n    if (this._readTime === undefined) {\n      throw new Error(\"Called 'readTime' on a local document\");\n    }\n\n    return this._readTime;\n  }\n  /**\r\n   * Retrieves all fields in the document as an object. Returns 'undefined' if\r\n   * the document doesn't exist.\r\n   *\r\n   * @returns {T|undefined} An object containing all fields in the document or\r\n   * 'undefined' if the document doesn't exist.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.get().then(documentSnapshot => {\r\n   *   let data = documentSnapshot.data();\r\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\r\n   * });\r\n   */\n\n\n  data() {\n    const fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    } // We only want to use the converter and create a new QueryDocumentSnapshot\n    // if a converter has been provided.\n\n\n    if (this.ref._converter !== types_1.defaultConverter()) {\n      const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n      return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n    } else {\n      const obj = {};\n\n      for (const prop of Object.keys(fields)) {\n        obj[prop] = this._serializer.decodeValue(fields[prop]);\n      }\n\n      return obj;\n    }\n  }\n  /**\r\n   * Retrieves the field specified by `field`.\r\n   *\r\n   * @param {string|FieldPath} field The field path\r\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\r\n   * @returns {*} The data at the specified field location or undefined if no\r\n   * such field exists.\r\n   *\r\n   * @example\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * documentRef.set({ a: { b: 'c' }}).then(() => {\r\n   *   return documentRef.get();\r\n   * }).then(documentSnapshot => {\r\n   *   let field = documentSnapshot.get('a.b');\r\n   *   console.log(`Retrieved field value: ${field}`);\r\n   * });\r\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  get(field) {\n    path_1.validateFieldPath('field', field);\n    const protoField = this.protoField(field);\n\n    if (protoField === undefined) {\n      return undefined;\n    }\n\n    return this._serializer.decodeValue(protoField);\n  }\n  /**\r\n   * Retrieves the field specified by 'fieldPath' in its Protobuf JS\r\n   * representation.\r\n   *\r\n   * @private\r\n   * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\r\n   * @returns The Protobuf-encoded data at the specified field location or\r\n   * undefined if no such field exists.\r\n   */\n\n\n  protoField(field) {\n    let fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const components = path_1.FieldPath.fromArgument(field).toArray();\n\n    while (components.length > 1) {\n      fields = fields[components.shift()];\n\n      if (!fields || !fields.mapValue) {\n        return undefined;\n      }\n\n      fields = fields.mapValue.fields;\n    }\n\n    return fields[components[0]];\n  }\n  /**\r\n   * Convert a document snapshot to the Firestore 'Write' proto.\r\n   *\r\n   * @private\r\n   */\n\n\n  toWriteProto() {\n    return {\n      update: {\n        name: this._ref.formattedName,\n        fields: this._fieldsProto\n      }\n    };\n  }\n  /**\r\n   * Convert a document snapshot to the Firestore 'Document' proto.\r\n   *\r\n   * @private\r\n   */\n\n\n  toDocumentProto() {\n    return {\n      name: this._ref.formattedName,\n      createTime: this.createTime,\n      updateTime: this.updateTime,\n      fields: this._fieldsProto\n    };\n  }\n  /**\r\n   * Returns true if the document's data and path in this `DocumentSnapshot` is\r\n   * equal to the provided value.\r\n   *\r\n   * @param {*} other The value to compare against.\r\n   * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\r\n   * value.\r\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every document read, we explicitly\n    // ignore all document metadata in this comparison.\n    return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);\n  }\n\n}\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\r\n * A QueryDocumentSnapshot contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\r\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\r\n *\r\n * A QueryDocumentSnapshot offers the same API surface as a\r\n * {@link DocumentSnapshot}. Since query results contain only existing\r\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\r\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\r\n * return 'undefined'.\r\n *\r\n * @class QueryDocumentSnapshot\r\n * @extends DocumentSnapshot\r\n */\n\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\r\n   * The time the document was created.\r\n   *\r\n   * @type {Timestamp}\r\n   * @name QueryDocumentSnapshot#createTime\r\n   * @readonly\r\n   * @override\r\n   *\r\n   * @example\r\n   * let query = firestore.collection('col');\r\n   *\r\n   * query.get().forEach(snapshot => {\r\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\r\n   * });\r\n   */\n  get createTime() {\n    return super.createTime;\n  }\n  /**\r\n   * The time the document was last updated (at the time the snapshot was\r\n   * generated).\r\n   *\r\n   * @type {Timestamp}\r\n   * @name QueryDocumentSnapshot#updateTime\r\n   * @readonly\r\n   * @override\r\n   *\r\n   * @example\r\n   * let query = firestore.collection('col');\r\n   *\r\n   * query.get().forEach(snapshot => {\r\n   *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\r\n   * });\r\n   */\n\n\n  get updateTime() {\n    return super.updateTime;\n  }\n  /**\r\n   * Retrieves all fields in the document as an object.\r\n   *\r\n   * @override\r\n   *\r\n   * @returns {T} An object containing all fields in the document.\r\n   *\r\n   * @example\r\n   * let query = firestore.collection('col');\r\n   *\r\n   * query.get().forEach(documentSnapshot => {\r\n   *   let data = documentSnapshot.data();\r\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\r\n   * });\r\n   */\n\n\n  data() {\n    const data = super.data();\n\n    if (!data) {\n      throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n    }\n\n    return data;\n  }\n\n}\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\r\n * A Firestore Document Mask contains the field paths affected by an update.\r\n *\r\n * @class\r\n * @private\r\n */\n\nclass DocumentMask {\n  /**\r\n   * @private\r\n   * @hideconstructor\r\n   *\r\n   * @param fieldPaths The field paths in this mask.\r\n   */\n  constructor(fieldPaths) {\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort((a, b) => a.compareTo(b));\n  }\n  /**\r\n   * Creates a document mask with the field paths of a document.\r\n   *\r\n   * @private\r\n   * @param data A map with fields to modify. Only the keys are used to extract\r\n   * the document mask.\r\n   */\n\n\n  static fromUpdateMap(data) {\n    const fieldPaths = [];\n    data.forEach((value, key) => {\n      if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n        fieldPaths.push(path_1.FieldPath.fromArgument(key));\n      }\n    });\n    return new DocumentMask(fieldPaths);\n  }\n  /**\r\n   * Creates a document mask from an array of field paths.\r\n   *\r\n   * @private\r\n   * @param fieldMask A list of field paths.\r\n   */\n\n\n  static fromFieldMask(fieldMask) {\n    const fieldPaths = [];\n\n    for (const fieldPath of fieldMask) {\n      fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n    }\n\n    return new DocumentMask(fieldPaths);\n  }\n  /**\r\n   * Creates a document mask with the field names of a document.\r\n   *\r\n   * @private\r\n   * @param data An object with fields to modify. Only the keys are used to\r\n   * extract the document mask.\r\n   */\n\n\n  static fromObject(data) {\n    const fieldPaths = [];\n\n    function extractFieldPaths(currentData, currentPath) {\n      let isEmpty = true;\n\n      for (const key of Object.keys(currentData)) {\n        isEmpty = false; // We don't split on dots since fromObject is called with\n        // DocumentData.\n\n        const childSegment = new path_1.FieldPath(key);\n        const childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n        const value = currentData[key];\n\n        if (value instanceof field_value_1.FieldTransform) {\n          if (value.includeInDocumentMask) {\n            fieldPaths.push(childPath);\n          }\n        } else if (util_1.isPlainObject(value)) {\n          extractFieldPaths(value, childPath);\n        } else {\n          fieldPaths.push(childPath);\n        }\n      } // Add a field path for an explicitly updated empty map.\n\n\n      if (currentPath && isEmpty) {\n        fieldPaths.push(currentPath);\n      }\n    }\n\n    extractFieldPaths(data);\n    return new DocumentMask(fieldPaths);\n  }\n  /**\r\n   * Returns true if this document mask contains no fields.\r\n   *\r\n   * @private\r\n   * @return {boolean} Whether this document mask is empty.\r\n   */\n\n\n  get isEmpty() {\n    return this._sortedPaths.length === 0;\n  }\n  /**\r\n   * Removes the specified values from a sorted field path array.\r\n   *\r\n   * @private\r\n   * @param input A sorted array of FieldPaths.\r\n   * @param values An array of FieldPaths to remove.\r\n   */\n\n\n  static removeFromSortedArray(input, values) {\n    for (let i = 0; i < input.length;) {\n      let removed = false;\n\n      for (const fieldPath of values) {\n        if (input[i].isEqual(fieldPath)) {\n          input.splice(i, 1);\n          removed = true;\n          break;\n        }\n      }\n\n      if (!removed) {\n        ++i;\n      }\n    }\n  }\n  /**\r\n   * Removes the field path specified in 'fieldPaths' from this document mask.\r\n   *\r\n   * @private\r\n   * @param fieldPaths An array of FieldPaths.\r\n   */\n\n\n  removeFields(fieldPaths) {\n    DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n  }\n  /**\r\n   * Returns whether this document mask contains 'fieldPath'.\r\n   *\r\n   * @private\r\n   * @param fieldPath The field path to test.\r\n   * @return Whether this document mask contains 'fieldPath'.\r\n   */\n\n\n  contains(fieldPath) {\n    for (const sortedPath of this._sortedPaths) {\n      const cmp = sortedPath.compareTo(fieldPath);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp > 0) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Removes all properties from 'data' that are not contained in this document\r\n   * mask.\r\n   *\r\n   * @private\r\n   * @param data An object to filter.\r\n   * @return A shallow copy of the object filtered by this document mask.\r\n   */\n\n\n  applyTo(data) {\n    /*!\r\n     * Applies this DocumentMask to 'data' and computes the list of field paths\r\n     * that were specified in the mask but are not present in 'data'.\r\n     */\n    const applyDocumentMask = data => {\n      const remainingPaths = this._sortedPaths.slice(0);\n\n      const processObject = (currentData, currentPath) => {\n        let result = null;\n        Object.keys(currentData).forEach(key => {\n          const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n          if (this.contains(childPath)) {\n            DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n            result = result || {};\n            result[key] = currentData[key];\n          } else if (util_1.isObject(currentData[key])) {\n            const childObject = processObject(currentData[key], childPath);\n\n            if (childObject) {\n              result = result || {};\n              result[key] = childObject;\n            }\n          }\n        });\n        return result;\n      }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n      const filteredData = processObject(data) || {};\n      return {\n        filteredData,\n        remainingPaths\n      };\n    };\n\n    const result = applyDocumentMask(data);\n\n    if (result.remainingPaths.length !== 0) {\n      throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n    }\n\n    return result.filteredData;\n  }\n  /**\r\n   * Converts a document mask to the Firestore 'DocumentMask' Proto.\r\n   *\r\n   * @private\r\n   * @returns A Firestore 'DocumentMask' Proto.\r\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return {};\n    }\n\n    const encodedPaths = [];\n\n    for (const fieldPath of this._sortedPaths) {\n      encodedPaths.push(fieldPath.formattedName);\n    }\n\n    return {\n      fieldPaths: encodedPaths\n    };\n  }\n\n}\n\nexports.DocumentMask = DocumentMask;\n/**\r\n * A Firestore Document Transform.\r\n *\r\n * A DocumentTransform contains pending server-side transforms and their\r\n * corresponding field paths.\r\n *\r\n * @private\r\n * @class\r\n */\n\nclass DocumentTransform {\n  /**\r\n   * @private\r\n   * @hideconstructor\r\n   *\r\n   * @param ref The DocumentReference for this transform.\r\n   * @param transforms A Map of FieldPaths to FieldTransforms.\r\n   */\n  constructor(ref, transforms) {\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\r\n   * Generates a DocumentTransform from a JavaScript object.\r\n   *\r\n   * @private\r\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\r\n   * @param obj The object to extract the transformations from.\r\n   * @returns The Document Transform.\r\n   */\n\n\n  static fromObject(ref, obj) {\n    const updateMap = new Map();\n\n    for (const prop of Object.keys(obj)) {\n      updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n    }\n\n    return DocumentTransform.fromUpdateMap(ref, updateMap);\n  }\n  /**\r\n   * Generates a DocumentTransform from an Update Map.\r\n   *\r\n   * @private\r\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\r\n   * @param data The update data to extract the transformations from.\r\n   * @returns The Document Transform.\r\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const transforms = new Map();\n\n    function encode_(val, path, allowTransforms) {\n      if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n        if (allowTransforms) {\n          transforms.set(path, val);\n        } else {\n          throw new Error(`${val.methodName}() is not supported inside of array values.`);\n        }\n      } else if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; ++i) {\n          // We need to verify that no array value contains a document transform\n          encode_(val[i], path.append(String(i)), false);\n        }\n      } else if (util_1.isPlainObject(val)) {\n        for (const prop of Object.keys(val)) {\n          encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n        }\n      }\n    }\n\n    data.forEach((value, key) => {\n      encode_(value, path_1.FieldPath.fromArgument(key), true);\n    });\n    return new DocumentTransform(ref, transforms);\n  }\n  /**\r\n   * Whether this DocumentTransform contains any actionable transformations.\r\n   *\r\n   * @private\r\n   */\n\n\n  get isEmpty() {\n    return this.transforms.size === 0;\n  }\n  /**\r\n   * Returns the array of fields in this DocumentTransform.\r\n   *\r\n   * @private\r\n   */\n\n\n  get fields() {\n    return Array.from(this.transforms.keys());\n  }\n  /**\r\n   * Validates the user provided field values in this document transform.\r\n   * @private\r\n   */\n\n\n  validate() {\n    const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n    this.transforms.forEach(transform => transform.validate(allowUndefined));\n  }\n  /**\r\n   * Converts a document transform to the Firestore 'FieldTransform' Proto.\r\n   *\r\n   * @private\r\n   * @param serializer The Firestore serializer\r\n   * @returns A list of Firestore 'FieldTransform' Protos\r\n   */\n\n\n  toProto(serializer) {\n    return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n  }\n\n}\n\nexports.DocumentTransform = DocumentTransform;\n/**\r\n * A Firestore Precondition encapsulates options for database writes.\r\n *\r\n * @private\r\n * @class\r\n */\n\nclass Precondition {\n  /**\r\n   * @private\r\n   * @hideconstructor\r\n   *\r\n   * @param options.exists - Whether the referenced document should exist in\r\n   * Firestore,\r\n   * @param options.lastUpdateTime - The last update time of the referenced\r\n   * document in Firestore.\r\n   * @param options\r\n   */\n  constructor(options) {\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\r\n   * Generates the Protobuf `Preconditon` object for this precondition.\r\n   *\r\n   * @private\r\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\r\n   * preconditions.\r\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const proto = {};\n\n    if (this._lastUpdateTime !== undefined) {\n      proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n    } else {\n      proto.exists = this._exists;\n    }\n\n    return proto;\n  }\n  /**\r\n   * Whether this DocumentTransform contains any enforcement.\r\n   *\r\n   * @private\r\n   */\n\n\n  get isEmpty() {\n    return this._exists === undefined && !this._lastUpdateTime;\n  }\n\n}\n\nexports.Precondition = Precondition;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/document.js"],"names":["Object","defineProperty","exports","value","deepEqual","require","assert","field_value_1","path_1","reference_1","types_1","util_1","DocumentSnapshotBuilder","constructor","ref","build","fieldsProto","undefined","createTime","updateTime","QueryDocumentSnapshot","readTime","DocumentSnapshot","_fieldsProto","_ref","_serializer","firestore","_readTime","_createTime","_updateTime","fromObject","obj","serializer","encodeFields","fromUpdateMap","data","merge","target","path","pos","key","isLast","length","FieldTransform","isEmpty","leafNode","encodeValue","childNode","mapValue","fields","nestedValue","res","toArray","exists","id","Error","_converter","defaultConverter","untypedReference","DocumentReference","_path","fromFirestore","prop","keys","decodeValue","get","field","validateFieldPath","protoField","components","FieldPath","fromArgument","shift","toWriteProto","update","name","formattedName","toDocumentProto","isEqual","other","DocumentMask","fieldPaths","_sortedPaths","sort","a","b","compareTo","forEach","includeInDocumentMask","push","fromFieldMask","fieldMask","fieldPath","extractFieldPaths","currentData","currentPath","childSegment","childPath","append","isPlainObject","removeFromSortedArray","input","values","i","removed","splice","removeFields","contains","sortedPath","cmp","applyTo","applyDocumentMask","remainingPaths","slice","processObject","result","isObject","childObject","filteredData","toProto","encodedPaths","DocumentTransform","transforms","updateMap","Map","set","encode_","val","allowTransforms","includeInDocumentTransform","methodName","Array","isArray","String","size","from","validate","allowUndefined","_settings","ignoreUndefinedProperties","transform","Precondition","options","_exists","_lastUpdateTime","lastUpdateTime","proto","timestampValue"],"mappings":"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;AACA;AACA;AACA;;;AACI,MAAIE,MAAJ,GAAa;AACT,WAAO,KAAK9B,YAAL,KAAsBN,SAA7B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAIH,GAAJ,GAAU;AACN,WAAO,KAAKU,IAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAI8B,EAAJ,GAAS;AACL,WAAO,KAAK9B,IAAL,CAAU8B,EAAjB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAIpC,UAAJ,GAAiB;AACb,WAAO,KAAKU,WAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAIT,UAAJ,GAAiB;AACb,WAAO,KAAKU,WAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAIR,QAAJ,GAAe;AACX,QAAI,KAAKM,SAAL,KAAmBV,SAAvB,EAAkC;AAC9B,YAAM,IAAIsC,KAAJ,CAAU,uCAAV,CAAN;AACH;;AACD,WAAO,KAAK5B,SAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIQ,EAAAA,IAAI,GAAG;AACH,UAAMc,MAAM,GAAG,KAAK1B,YAApB;;AACA,QAAI0B,MAAM,KAAKhC,SAAf,EAA0B;AACtB,aAAOA,SAAP;AACH,KAJE,CAKH;AACA;;;AACA,QAAI,KAAKH,GAAL,CAAS0C,UAAT,KAAwB9C,OAAO,CAAC+C,gBAAR,EAA5B,EAAwD;AACpD,YAAMC,gBAAgB,GAAG,IAAIjD,WAAW,CAACkD,iBAAhB,CAAkC,KAAK7C,GAAL,CAASY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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst deepEqual = require(\"fast-deep-equal\");\r\nconst assert = require(\"assert\");\r\nconst field_value_1 = require(\"./field-value\");\r\nconst path_1 = require(\"./path\");\r\nconst reference_1 = require(\"./reference\");\r\nconst types_1 = require(\"./types\");\r\nconst util_1 = require(\"./util\");\r\n/**\r\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\r\n * Invoke `.build()' to assemble the final snapshot.\r\n *\r\n * @private\r\n */\r\nclass DocumentSnapshotBuilder {\r\n    // We include the DocumentReference in the constructor in order to allow the\r\n    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\r\n    constructor(ref) {\r\n        this.ref = ref;\r\n    }\r\n    /**\r\n     * Builds the DocumentSnapshot.\r\n     *\r\n     * @private\r\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\r\n     * provided) or a DocumentSnapshot.\r\n     */\r\n    build() {\r\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\r\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\r\n        return this.fieldsProto\r\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\r\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\r\n    }\r\n}\r\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\r\n/**\r\n * A DocumentSnapshot is an immutable representation for a document in a\r\n * Firestore database. The data can be extracted with\r\n * [data()]{@link DocumentSnapshot#data} or\r\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\r\n * specific field.\r\n *\r\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the\r\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\r\n * document's existence.\r\n *\r\n * @class DocumentSnapshot\r\n */\r\nclass DocumentSnapshot {\r\n    /**\r\n     * @hideconstructor\r\n     *\r\n     * @param ref The reference to the document.\r\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\r\n     * this document (or undefined if the document does not exist).\r\n     * @param readTime The time when this snapshot was read  (or undefined if\r\n     * the document exists only locally).\r\n     * @param createTime The time when the document was created (or undefined if\r\n     * the document does not exist).\r\n     * @param updateTime The time when the document was last updated (or undefined\r\n     * if the document does not exist).\r\n     */\r\n    constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\r\n        this._fieldsProto = _fieldsProto;\r\n        this._ref = ref;\r\n        this._serializer = ref.firestore._serializer;\r\n        this._readTime = readTime;\r\n        this._createTime = createTime;\r\n        this._updateTime = updateTime;\r\n    }\r\n    /**\r\n     * Creates a DocumentSnapshot from an object.\r\n     *\r\n     * @private\r\n     * @param ref The reference to the document.\r\n     * @param obj The object to store in the DocumentSnapshot.\r\n     * @return The created DocumentSnapshot.\r\n     */\r\n    static fromObject(ref, obj) {\r\n        const serializer = ref.firestore._serializer;\r\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\r\n    }\r\n    /**\r\n     * Creates a DocumentSnapshot from an UpdateMap.\r\n     *\r\n     * This methods expands the top-level field paths in a JavaScript map and\r\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\r\n     *\r\n     * @private\r\n     * @param ref The reference to the document.\r\n     * @param data The field/value map to expand.\r\n     * @return The created DocumentSnapshot.\r\n     */\r\n    static fromUpdateMap(ref, data) {\r\n        const serializer = ref.firestore._serializer;\r\n        /**\r\n         * Merges 'value' at the field path specified by the path array into\r\n         * 'target'.\r\n         */\r\n        function merge(target, value, path, pos) {\r\n            const key = path[pos];\r\n            const isLast = pos === path.length - 1;\r\n            if (target[key] === undefined) {\r\n                if (isLast) {\r\n                    if (value instanceof field_value_1.FieldTransform) {\r\n                        // If there is already data at this path, we need to retain it.\r\n                        // Otherwise, we don't include it in the DocumentSnapshot.\r\n                        return !util_1.isEmpty(target) ? target : null;\r\n                    }\r\n                    // The merge is done.\r\n                    const leafNode = serializer.encodeValue(value);\r\n                    if (leafNode) {\r\n                        target[key] = leafNode;\r\n                    }\r\n                    return target;\r\n                }\r\n                else {\r\n                    // We need to expand the target object.\r\n                    const childNode = {\r\n                        mapValue: {\r\n                            fields: {},\r\n                        },\r\n                    };\r\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\r\n                    if (nestedValue) {\r\n                        childNode.mapValue.fields = nestedValue;\r\n                        target[key] = childNode;\r\n                        return target;\r\n                    }\r\n                    else {\r\n                        return !util_1.isEmpty(target) ? target : null;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                assert(!isLast, \"Can't merge current value into a nested object\");\r\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\r\n                return target;\r\n            }\r\n        }\r\n        const res = {};\r\n        for (const [key, value] of data) {\r\n            const path = key.toArray();\r\n            merge(res, value, path, 0);\r\n        }\r\n        return new DocumentSnapshot(ref, res);\r\n    }\r\n    /**\r\n     * True if the document exists.\r\n     *\r\n     * @type {boolean}\r\n     * @name DocumentSnapshot#exists\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then((documentSnapshot) => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\r\n     *   }\r\n     * });\r\n     */\r\n    get exists() {\r\n        return this._fieldsProto !== undefined;\r\n    }\r\n    /**\r\n     * A [DocumentReference]{@link DocumentReference} for the document\r\n     * stored in this snapshot.\r\n     *\r\n     * @type {DocumentReference}\r\n     * @name DocumentSnapshot#ref\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then((documentSnapshot) => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\r\n     *   }\r\n     * });\r\n     */\r\n    get ref() {\r\n        return this._ref;\r\n    }\r\n    /**\r\n     * The ID of the document for which this DocumentSnapshot contains data.\r\n     *\r\n     * @type {string}\r\n     * @name DocumentSnapshot#id\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then((documentSnapshot) => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\r\n     *   }\r\n     * });\r\n     */\r\n    get id() {\r\n        return this._ref.id;\r\n    }\r\n    /**\r\n     * The time the document was created. Undefined for documents that don't\r\n     * exist.\r\n     *\r\n     * @type {Timestamp|undefined}\r\n     * @name DocumentSnapshot#createTime\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(documentSnapshot => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     let createTime = documentSnapshot.createTime;\r\n     *     console.log(`Document created at '${createTime.toDate()}'`);\r\n     *   }\r\n     * });\r\n     */\r\n    get createTime() {\r\n        return this._createTime;\r\n    }\r\n    /**\r\n     * The time the document was last updated (at the time the snapshot was\r\n     * generated). Undefined for documents that don't exist.\r\n     *\r\n     * @type {Timestamp|undefined}\r\n     * @name DocumentSnapshot#updateTime\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(documentSnapshot => {\r\n     *   if (documentSnapshot.exists) {\r\n     *     let updateTime = documentSnapshot.updateTime;\r\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\r\n     *   }\r\n     * });\r\n     */\r\n    get updateTime() {\r\n        return this._updateTime;\r\n    }\r\n    /**\r\n     * The time this snapshot was read.\r\n     *\r\n     * @type {Timestamp}\r\n     * @name DocumentSnapshot#readTime\r\n     * @readonly\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(documentSnapshot => {\r\n     *   let readTime = documentSnapshot.readTime;\r\n     *   console.log(`Document read at '${readTime.toDate()}'`);\r\n     * });\r\n     */\r\n    get readTime() {\r\n        if (this._readTime === undefined) {\r\n            throw new Error(\"Called 'readTime' on a local document\");\r\n        }\r\n        return this._readTime;\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\r\n     * the document doesn't exist.\r\n     *\r\n     * @returns {T|undefined} An object containing all fields in the document or\r\n     * 'undefined' if the document doesn't exist.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.get().then(documentSnapshot => {\r\n     *   let data = documentSnapshot.data();\r\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\r\n     * });\r\n     */\r\n    data() {\r\n        const fields = this._fieldsProto;\r\n        if (fields === undefined) {\r\n            return undefined;\r\n        }\r\n        // We only want to use the converter and create a new QueryDocumentSnapshot\r\n        // if a converter has been provided.\r\n        if (this.ref._converter !== types_1.defaultConverter()) {\r\n            const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\r\n            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\r\n        }\r\n        else {\r\n            const obj = {};\r\n            for (const prop of Object.keys(fields)) {\r\n                obj[prop] = this._serializer.decodeValue(fields[prop]);\r\n            }\r\n            return obj;\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `field`.\r\n     *\r\n     * @param {string|FieldPath} field The field path\r\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\r\n     * @returns {*} The data at the specified field location or undefined if no\r\n     * such field exists.\r\n     *\r\n     * @example\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\r\n     *   return documentRef.get();\r\n     * }).then(documentSnapshot => {\r\n     *   let field = documentSnapshot.get('a.b');\r\n     *   console.log(`Retrieved field value: ${field}`);\r\n     * });\r\n     */\r\n    // We deliberately use `any` in the external API to not impose type-checking\r\n    // on end users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(field) {\r\n        path_1.validateFieldPath('field', field);\r\n        const protoField = this.protoField(field);\r\n        if (protoField === undefined) {\r\n            return undefined;\r\n        }\r\n        return this._serializer.decodeValue(protoField);\r\n    }\r\n    /**\r\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\r\n     * representation.\r\n     *\r\n     * @private\r\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\r\n     * @returns The Protobuf-encoded data at the specified field location or\r\n     * undefined if no such field exists.\r\n     */\r\n    protoField(field) {\r\n        let fields = this._fieldsProto;\r\n        if (fields === undefined) {\r\n            return undefined;\r\n        }\r\n        const components = path_1.FieldPath.fromArgument(field).toArray();\r\n        while (components.length > 1) {\r\n            fields = fields[components.shift()];\r\n            if (!fields || !fields.mapValue) {\r\n                return undefined;\r\n            }\r\n            fields = fields.mapValue.fields;\r\n        }\r\n        return fields[components[0]];\r\n    }\r\n    /**\r\n     * Convert a document snapshot to the Firestore 'Write' proto.\r\n     *\r\n     * @private\r\n     */\r\n    toWriteProto() {\r\n        return {\r\n            update: {\r\n                name: this._ref.formattedName,\r\n                fields: this._fieldsProto,\r\n            },\r\n        };\r\n    }\r\n    /**\r\n     * Convert a document snapshot to the Firestore 'Document' proto.\r\n     *\r\n     * @private\r\n     */\r\n    toDocumentProto() {\r\n        return {\r\n            name: this._ref.formattedName,\r\n            createTime: this.createTime,\r\n            updateTime: this.updateTime,\r\n            fields: this._fieldsProto,\r\n        };\r\n    }\r\n    /**\r\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\r\n     * equal to the provided value.\r\n     *\r\n     * @param {*} other The value to compare against.\r\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\r\n     * value.\r\n     */\r\n    isEqual(other) {\r\n        // Since the read time is different on every document read, we explicitly\r\n        // ignore all document metadata in this comparison.\r\n        return (this === other ||\r\n            (other instanceof DocumentSnapshot &&\r\n                this._ref.isEqual(other._ref) &&\r\n                deepEqual(this._fieldsProto, other._fieldsProto)));\r\n    }\r\n}\r\nexports.DocumentSnapshot = DocumentSnapshot;\r\n/**\r\n * A QueryDocumentSnapshot contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\r\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\r\n *\r\n * A QueryDocumentSnapshot offers the same API surface as a\r\n * {@link DocumentSnapshot}. Since query results contain only existing\r\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\r\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\r\n * return 'undefined'.\r\n *\r\n * @class QueryDocumentSnapshot\r\n * @extends DocumentSnapshot\r\n */\r\nclass QueryDocumentSnapshot extends DocumentSnapshot {\r\n    /**\r\n     * The time the document was created.\r\n     *\r\n     * @type {Timestamp}\r\n     * @name QueryDocumentSnapshot#createTime\r\n     * @readonly\r\n     * @override\r\n     *\r\n     * @example\r\n     * let query = firestore.collection('col');\r\n     *\r\n     * query.get().forEach(snapshot => {\r\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\r\n     * });\r\n     */\r\n    get createTime() {\r\n        return super.createTime;\r\n    }\r\n    /**\r\n     * The time the document was last updated (at the time the snapshot was\r\n     * generated).\r\n     *\r\n     * @type {Timestamp}\r\n     * @name QueryDocumentSnapshot#updateTime\r\n     * @readonly\r\n     * @override\r\n     *\r\n     * @example\r\n     * let query = firestore.collection('col');\r\n     *\r\n     * query.get().forEach(snapshot => {\r\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\r\n     * });\r\n     */\r\n    get updateTime() {\r\n        return super.updateTime;\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an object.\r\n     *\r\n     * @override\r\n     *\r\n     * @returns {T} An object containing all fields in the document.\r\n     *\r\n     * @example\r\n     * let query = firestore.collection('col');\r\n     *\r\n     * query.get().forEach(documentSnapshot => {\r\n     *   let data = documentSnapshot.data();\r\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\r\n     * });\r\n     */\r\n    data() {\r\n        const data = super.data();\r\n        if (!data) {\r\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\r\n        }\r\n        return data;\r\n    }\r\n}\r\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\r\n/**\r\n * A Firestore Document Mask contains the field paths affected by an update.\r\n *\r\n * @class\r\n * @private\r\n */\r\nclass DocumentMask {\r\n    /**\r\n     * @private\r\n     * @hideconstructor\r\n     *\r\n     * @param fieldPaths The field paths in this mask.\r\n     */\r\n    constructor(fieldPaths) {\r\n        this._sortedPaths = fieldPaths;\r\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\r\n    }\r\n    /**\r\n     * Creates a document mask with the field paths of a document.\r\n     *\r\n     * @private\r\n     * @param data A map with fields to modify. Only the keys are used to extract\r\n     * the document mask.\r\n     */\r\n    static fromUpdateMap(data) {\r\n        const fieldPaths = [];\r\n        data.forEach((value, key) => {\r\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\r\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\r\n            }\r\n        });\r\n        return new DocumentMask(fieldPaths);\r\n    }\r\n    /**\r\n     * Creates a document mask from an array of field paths.\r\n     *\r\n     * @private\r\n     * @param fieldMask A list of field paths.\r\n     */\r\n    static fromFieldMask(fieldMask) {\r\n        const fieldPaths = [];\r\n        for (const fieldPath of fieldMask) {\r\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\r\n        }\r\n        return new DocumentMask(fieldPaths);\r\n    }\r\n    /**\r\n     * Creates a document mask with the field names of a document.\r\n     *\r\n     * @private\r\n     * @param data An object with fields to modify. Only the keys are used to\r\n     * extract the document mask.\r\n     */\r\n    static fromObject(data) {\r\n        const fieldPaths = [];\r\n        function extractFieldPaths(currentData, currentPath) {\r\n            let isEmpty = true;\r\n            for (const key of Object.keys(currentData)) {\r\n                isEmpty = false;\r\n                // We don't split on dots since fromObject is called with\r\n                // DocumentData.\r\n                const childSegment = new path_1.FieldPath(key);\r\n                const childPath = currentPath\r\n                    ? currentPath.append(childSegment)\r\n                    : childSegment;\r\n                const value = currentData[key];\r\n                if (value instanceof field_value_1.FieldTransform) {\r\n                    if (value.includeInDocumentMask) {\r\n                        fieldPaths.push(childPath);\r\n                    }\r\n                }\r\n                else if (util_1.isPlainObject(value)) {\r\n                    extractFieldPaths(value, childPath);\r\n                }\r\n                else {\r\n                    fieldPaths.push(childPath);\r\n                }\r\n            }\r\n            // Add a field path for an explicitly updated empty map.\r\n            if (currentPath && isEmpty) {\r\n                fieldPaths.push(currentPath);\r\n            }\r\n        }\r\n        extractFieldPaths(data);\r\n        return new DocumentMask(fieldPaths);\r\n    }\r\n    /**\r\n     * Returns true if this document mask contains no fields.\r\n     *\r\n     * @private\r\n     * @return {boolean} Whether this document mask is empty.\r\n     */\r\n    get isEmpty() {\r\n        return this._sortedPaths.length === 0;\r\n    }\r\n    /**\r\n     * Removes the specified values from a sorted field path array.\r\n     *\r\n     * @private\r\n     * @param input A sorted array of FieldPaths.\r\n     * @param values An array of FieldPaths to remove.\r\n     */\r\n    static removeFromSortedArray(input, values) {\r\n        for (let i = 0; i < input.length;) {\r\n            let removed = false;\r\n            for (const fieldPath of values) {\r\n                if (input[i].isEqual(fieldPath)) {\r\n                    input.splice(i, 1);\r\n                    removed = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!removed) {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Removes the field path specified in 'fieldPaths' from this document mask.\r\n     *\r\n     * @private\r\n     * @param fieldPaths An array of FieldPaths.\r\n     */\r\n    removeFields(fieldPaths) {\r\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\r\n    }\r\n    /**\r\n     * Returns whether this document mask contains 'fieldPath'.\r\n     *\r\n     * @private\r\n     * @param fieldPath The field path to test.\r\n     * @return Whether this document mask contains 'fieldPath'.\r\n     */\r\n    contains(fieldPath) {\r\n        for (const sortedPath of this._sortedPaths) {\r\n            const cmp = sortedPath.compareTo(fieldPath);\r\n            if (cmp === 0) {\r\n                return true;\r\n            }\r\n            else if (cmp > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Removes all properties from 'data' that are not contained in this document\r\n     * mask.\r\n     *\r\n     * @private\r\n     * @param data An object to filter.\r\n     * @return A shallow copy of the object filtered by this document mask.\r\n     */\r\n    applyTo(data) {\r\n        /*!\r\n         * Applies this DocumentMask to 'data' and computes the list of field paths\r\n         * that were specified in the mask but are not present in 'data'.\r\n         */\r\n        const applyDocumentMask = data => {\r\n            const remainingPaths = this._sortedPaths.slice(0);\r\n            const processObject = (currentData, currentPath) => {\r\n                let result = null;\r\n                Object.keys(currentData).forEach(key => {\r\n                    const childPath = currentPath\r\n                        ? currentPath.append(key)\r\n                        : new path_1.FieldPath(key);\r\n                    if (this.contains(childPath)) {\r\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\r\n                        result = result || {};\r\n                        result[key] = currentData[key];\r\n                    }\r\n                    else if (util_1.isObject(currentData[key])) {\r\n                        const childObject = processObject(currentData[key], childPath);\r\n                        if (childObject) {\r\n                            result = result || {};\r\n                            result[key] = childObject;\r\n                        }\r\n                    }\r\n                });\r\n                return result;\r\n            };\r\n            // processObject() returns 'null' if the DocumentMask is empty.\r\n            const filteredData = processObject(data) || {};\r\n            return {\r\n                filteredData,\r\n                remainingPaths,\r\n            };\r\n        };\r\n        const result = applyDocumentMask(data);\r\n        if (result.remainingPaths.length !== 0) {\r\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\r\n        }\r\n        return result.filteredData;\r\n    }\r\n    /**\r\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\r\n     *\r\n     * @private\r\n     * @returns A Firestore 'DocumentMask' Proto.\r\n     */\r\n    toProto() {\r\n        if (this.isEmpty) {\r\n            return {};\r\n        }\r\n        const encodedPaths = [];\r\n        for (const fieldPath of this._sortedPaths) {\r\n            encodedPaths.push(fieldPath.formattedName);\r\n        }\r\n        return {\r\n            fieldPaths: encodedPaths,\r\n        };\r\n    }\r\n}\r\nexports.DocumentMask = DocumentMask;\r\n/**\r\n * A Firestore Document Transform.\r\n *\r\n * A DocumentTransform contains pending server-side transforms and their\r\n * corresponding field paths.\r\n *\r\n * @private\r\n * @class\r\n */\r\nclass DocumentTransform {\r\n    /**\r\n     * @private\r\n     * @hideconstructor\r\n     *\r\n     * @param ref The DocumentReference for this transform.\r\n     * @param transforms A Map of FieldPaths to FieldTransforms.\r\n     */\r\n    constructor(ref, transforms) {\r\n        this.ref = ref;\r\n        this.transforms = transforms;\r\n    }\r\n    /**\r\n     * Generates a DocumentTransform from a JavaScript object.\r\n     *\r\n     * @private\r\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\r\n     * @param obj The object to extract the transformations from.\r\n     * @returns The Document Transform.\r\n     */\r\n    static fromObject(ref, obj) {\r\n        const updateMap = new Map();\r\n        for (const prop of Object.keys(obj)) {\r\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\r\n        }\r\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\r\n    }\r\n    /**\r\n     * Generates a DocumentTransform from an Update Map.\r\n     *\r\n     * @private\r\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\r\n     * @param data The update data to extract the transformations from.\r\n     * @returns The Document Transform.\r\n     */\r\n    static fromUpdateMap(ref, data) {\r\n        const transforms = new Map();\r\n        function encode_(val, path, allowTransforms) {\r\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\r\n                if (allowTransforms) {\r\n                    transforms.set(path, val);\r\n                }\r\n                else {\r\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\r\n                }\r\n            }\r\n            else if (Array.isArray(val)) {\r\n                for (let i = 0; i < val.length; ++i) {\r\n                    // We need to verify that no array value contains a document transform\r\n                    encode_(val[i], path.append(String(i)), false);\r\n                }\r\n            }\r\n            else if (util_1.isPlainObject(val)) {\r\n                for (const prop of Object.keys(val)) {\r\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\r\n                }\r\n            }\r\n        }\r\n        data.forEach((value, key) => {\r\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\r\n        });\r\n        return new DocumentTransform(ref, transforms);\r\n    }\r\n    /**\r\n     * Whether this DocumentTransform contains any actionable transformations.\r\n     *\r\n     * @private\r\n     */\r\n    get isEmpty() {\r\n        return this.transforms.size === 0;\r\n    }\r\n    /**\r\n     * Returns the array of fields in this DocumentTransform.\r\n     *\r\n     * @private\r\n     */\r\n    get fields() {\r\n        return Array.from(this.transforms.keys());\r\n    }\r\n    /**\r\n     * Validates the user provided field values in this document transform.\r\n     * @private\r\n     */\r\n    validate() {\r\n        const allowUndefined = !!this.ref.firestore._settings\r\n            .ignoreUndefinedProperties;\r\n        this.transforms.forEach(transform => transform.validate(allowUndefined));\r\n    }\r\n    /**\r\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\r\n     *\r\n     * @private\r\n     * @param serializer The Firestore serializer\r\n     * @returns A list of Firestore 'FieldTransform' Protos\r\n     */\r\n    toProto(serializer) {\r\n        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\r\n    }\r\n}\r\nexports.DocumentTransform = DocumentTransform;\r\n/**\r\n * A Firestore Precondition encapsulates options for database writes.\r\n *\r\n * @private\r\n * @class\r\n */\r\nclass Precondition {\r\n    /**\r\n     * @private\r\n     * @hideconstructor\r\n     *\r\n     * @param options.exists - Whether the referenced document should exist in\r\n     * Firestore,\r\n     * @param options.lastUpdateTime - The last update time of the referenced\r\n     * document in Firestore.\r\n     * @param options\r\n     */\r\n    constructor(options) {\r\n        if (options !== undefined) {\r\n            this._exists = options.exists;\r\n            this._lastUpdateTime = options.lastUpdateTime;\r\n        }\r\n    }\r\n    /**\r\n     * Generates the Protobuf `Preconditon` object for this precondition.\r\n     *\r\n     * @private\r\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\r\n     * preconditions.\r\n     */\r\n    toProto() {\r\n        if (this.isEmpty) {\r\n            return null;\r\n        }\r\n        const proto = {};\r\n        if (this._lastUpdateTime !== undefined) {\r\n            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\r\n        }\r\n        else {\r\n            proto.exists = this._exists;\r\n        }\r\n        return proto;\r\n    }\r\n    /**\r\n     * Whether this DocumentTransform contains any enforcement.\r\n     *\r\n     * @private\r\n     */\r\n    get isEmpty() {\r\n        return this._exists === undefined && !this._lastUpdateTime;\r\n    }\r\n}\r\nexports.Precondition = Precondition;\r\n//# sourceMappingURL=document.js.map"]},"metadata":{},"sourceType":"script"}