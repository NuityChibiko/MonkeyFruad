{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/**\r\n * Helper function. Gets or populates srcset breakpoints using provided parameters\r\n * Either the breakpoints or min_width, max_width, max_images must be provided.\r\n *\r\n * @module utils\r\n * @private\r\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\r\n *\r\n * @return {number[]} Array of breakpoints\r\n *\r\n */\n\n\nfunction generateBreakpoints(srcset) {\n  var breakpoints = srcset.breakpoints || [];\n\n  if (breakpoints.length) {\n    return breakpoints;\n  }\n\n  var _map = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number),\n      _map2 = _slicedToArray(_map, 3),\n      min_width = _map2[0],\n      max_width = _map2[1],\n      max_images = _map2[2];\n\n  if ([min_width, max_width, max_images].some(Number.isNaN)) {\n    throw 'Either (min_width, max_width, max_images) ' + 'or breakpoints must be provided to the image srcset attribute';\n  }\n\n  if (min_width > max_width) {\n    throw 'min_width must be less than max_width';\n  }\n\n  if (max_images <= 0) {\n    throw 'max_images must be a positive integer';\n  } else if (max_images === 1) {\n    min_width = max_width;\n  }\n\n  var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n\n  for (var current = min_width; current < max_width; current += stepSize) {\n    breakpoints.push(current);\n  }\n\n  breakpoints.push(max_width);\n  return breakpoints;\n}\n\nmodule.exports = generateBreakpoints;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/cloudinary/lib-es5/utils/generateBreakpoints.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","generateBreakpoints","srcset","breakpoints","_map","min_width","max_width","max_images","map","Number","_map2","some","isNaN","stepSize","Math","ceil","max","current","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,cAAc,GAAG,YAAY;AAAE,WAASC,aAAT,CAAuBC,GAAvB,EAA4BC,CAA5B,EAA+B;AAAE,QAAIC,IAAI,GAAG,EAAX;AAAe,QAAIC,EAAE,GAAG,IAAT;AAAe,QAAIC,EAAE,GAAG,KAAT;AAAgB,QAAIC,EAAE,GAAGC,SAAT;;AAAoB,QAAI;AAAE,WAAK,IAAIC,EAAE,GAAGP,GAAG,CAACQ,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCC,EAAtC,EAA0C,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyET,EAAE,GAAG,IAA9E,EAAoF;AAAED,QAAAA,IAAI,CAACW,IAAL,CAAUH,EAAE,CAACI,KAAb;;AAAqB,YAAIb,CAAC,IAAIC,IAAI,CAACa,MAAL,KAAgBd,CAAzB,EAA4B;AAAQ;AAAE,KAAvJ,CAAwJ,OAAOe,GAAP,EAAY;AAAEZ,MAAAA,EAAE,GAAG,IAAL;AAAWC,MAAAA,EAAE,GAAGW,GAAL;AAAW,KAA5L,SAAqM;AAAE,UAAI;AAAE,YAAI,CAACb,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAb,EAAyBA,EAAE,CAAC,QAAD,CAAF;AAAiB,OAAhD,SAAyD;AAAE,YAAIH,EAAJ,EAAQ,MAAMC,EAAN;AAAW;AAAE;;AAAC,WAAOH,IAAP;AAAc;;AAAC,SAAO,UAAUF,GAAV,EAAeC,CAAf,EAAkB;AAAE,QAAIgB,KAAK,CAACC,OAAN,CAAclB,GAAd,CAAJ,EAAwB;AAAE,aAAOA,GAAP;AAAa,KAAvC,MAA6C,IAAIQ,MAAM,CAACC,QAAP,IAAmBU,MAAM,CAACnB,GAAD,CAA7B,EAAoC;AAAE,aAAOD,aAAa,CAACC,GAAD,EAAMC,CAAN,CAApB;AAA+B,KAArE,MAA2E;AAAE,YAAM,IAAImB,SAAJ,CAAc,sDAAd,CAAN;AAA8E;AAAE,GAArO;AAAwO,CAAhoB,EAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,mBAAT,CAA6BC,MAA7B,EAAqC;AACnC,MAAIC,WAAW,GAAGD,MAAM,CAACC,WAAP,IAAsB,EAAxC;;AACA,MAAIA,WAAW,CAACR,MAAhB,EAAwB;AACtB,WAAOQ,WAAP;AACD;;AAED,MAAIC,IAAI,GAAG,CAACF,MAAM,CAACG,SAAR,EAAmBH,MAAM,CAACI,SAA1B,EAAqCJ,MAAM,CAACK,UAA5C,EAAwDC,GAAxD,CAA4DC,MAA5D,CAAX;AAAA,MACIC,KAAK,GAAGhC,cAAc,CAAC0B,IAAD,EAAO,CAAP,CAD1B;AAAA,MAEIC,SAAS,GAAGK,KAAK,CAAC,CAAD,CAFrB;AAAA,MAGIJ,SAAS,GAAGI,KAAK,CAAC,CAAD,CAHrB;AAAA,MAIIH,UAAU,GAAGG,KAAK,CAAC,CAAD,CAJtB;;AAMA,MAAI,CAACL,SAAD,EAAYC,SAAZ,EAAuBC,UAAvB,EAAmCI,IAAnC,CAAwCF,MAAM,CAACG,KAA/C,CAAJ,EAA2D;AACzD,UAAM,+CAA+C,+DAArD;AACD;;AAED,MAAIP,SAAS,GAAGC,SAAhB,EAA2B;AACzB,UAAM,uCAAN;AACD;;AAED,MAAIC,UAAU,IAAI,CAAlB,EAAqB;AACnB,UAAM,uCAAN;AACD,GAFD,MAEO,IAAIA,UAAU,KAAK,CAAnB,EAAsB;AAC3BF,IAAAA,SAAS,GAAGC,SAAZ;AACD;;AAED,MAAIO,QAAQ,GAAGC,IAAI,CAACC,IAAL,CAAU,CAACT,SAAS,GAAGD,SAAb,IAA0BS,IAAI,CAACE,GAAL,CAAST,UAAU,GAAG,CAAtB,EAAyB,CAAzB,CAApC,CAAf;;AACA,OAAK,IAAIU,OAAO,GAAGZ,SAAnB,EAA8BY,OAAO,GAAGX,SAAxC,EAAmDW,OAAO,IAAIJ,QAA9D,EAAwE;AACtEV,IAAAA,WAAW,CAACV,IAAZ,CAAiBwB,OAAjB;AACD;;AACDd,EAAAA,WAAW,CAACV,IAAZ,CAAiBa,SAAjB;AACA,SAAOH,WAAP;AACD;;AACDe,MAAM,CAACC,OAAP,GAAiBlB,mBAAjB","sourcesContent":["'use strict';\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\n/**\r\n * Helper function. Gets or populates srcset breakpoints using provided parameters\r\n * Either the breakpoints or min_width, max_width, max_images must be provided.\r\n *\r\n * @module utils\r\n * @private\r\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\r\n *\r\n * @return {number[]} Array of breakpoints\r\n *\r\n */\r\nfunction generateBreakpoints(srcset) {\r\n  var breakpoints = srcset.breakpoints || [];\r\n  if (breakpoints.length) {\r\n    return breakpoints;\r\n  }\r\n\r\n  var _map = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number),\r\n      _map2 = _slicedToArray(_map, 3),\r\n      min_width = _map2[0],\r\n      max_width = _map2[1],\r\n      max_images = _map2[2];\r\n\r\n  if ([min_width, max_width, max_images].some(Number.isNaN)) {\r\n    throw 'Either (min_width, max_width, max_images) ' + 'or breakpoints must be provided to the image srcset attribute';\r\n  }\r\n\r\n  if (min_width > max_width) {\r\n    throw 'min_width must be less than max_width';\r\n  }\r\n\r\n  if (max_images <= 0) {\r\n    throw 'max_images must be a positive integer';\r\n  } else if (max_images === 1) {\r\n    min_width = max_width;\r\n  }\r\n\r\n  var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\r\n  for (var current = min_width; current < max_width; current += stepSize) {\r\n    breakpoints.push(current);\r\n  }\r\n  breakpoints.push(max_width);\r\n  return breakpoints;\r\n}\r\nmodule.exports = generateBreakpoints;"]},"metadata":{},"sourceType":"script"}