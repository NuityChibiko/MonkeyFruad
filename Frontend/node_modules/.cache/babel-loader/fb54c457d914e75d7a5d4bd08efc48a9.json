{"ast":null,"code":"'use strict';\n/**\r\n * Authorization Token\r\n * @module auth_token\r\n */\n\nvar crypto = require('crypto');\n\nvar smart_escape = require('./utils/encoding/smart_escape');\n\nvar unsafe = /([ \"#%&'/:;<=>?@[\\]^`{|}~]+)/g;\n\nfunction digest(message, key) {\n  return crypto.createHmac(\"sha256\", Buffer.from(key, \"hex\")).update(message).digest('hex');\n}\n/**\r\n * Escape url using lowercase hex code\r\n * @param {string} url a url string\r\n * @return {string} escaped url\r\n */\n\n\nfunction escapeToLower(url) {\n  var safeUrl = smart_escape(url, unsafe);\n  return safeUrl.replace(/%../g, function (match) {\n    return match.toLowerCase();\n  });\n}\n/**\r\n * Auth token options\r\n * @typedef {object} authTokenOptions\r\n * @property {string} [token_name=\"__cld_token__\"] The name of the token.\r\n * @property {string} key The secret key required to sign the token.\r\n * @property {string} ip The IP address of the client.\r\n * @property {number} start_time=now The start time of the token in seconds from epoch.\r\n * @property {string} expiration The expiration time of the token in seconds from epoch.\r\n * @property {string} duration The duration of the token (from start_time).\r\n * @property {string} acl The ACL for the token.\r\n * @property {string} url The URL to authentication in case of a URL token.\r\n *\r\n */\n\n/**\r\n * Generate an authorization token\r\n * @param {authTokenOptions} options\r\n * @returns {string} the authorization token\r\n */\n\n\nmodule.exports = function (options) {\n  var tokenName = options.token_name ? options.token_name : \"__cld_token__\";\n  var tokenSeparator = \"~\";\n\n  if (options.expiration == null) {\n    if (options.duration != null) {\n      var start = options.start_time != null ? options.start_time : Math.round(Date.now() / 1000);\n      options.expiration = start + options.duration;\n    } else {\n      throw new Error(\"Must provide either expiration or duration\");\n    }\n  }\n\n  var tokenParts = [];\n\n  if (options.ip != null) {\n    tokenParts.push(`ip=${options.ip}`);\n  }\n\n  if (options.start_time != null) {\n    tokenParts.push(`st=${options.start_time}`);\n  }\n\n  tokenParts.push(`exp=${options.expiration}`);\n\n  if (options.acl != null) {\n    tokenParts.push(`acl=${escapeToLower(options.acl)}`);\n  }\n\n  var toSign = [].concat(tokenParts);\n\n  if (options.url != null && options.acl == null) {\n    var url = escapeToLower(options.url);\n    toSign.push(`url=${url}`);\n  }\n\n  var auth = digest(toSign.join(tokenSeparator), options.key);\n  tokenParts.push(`hmac=${auth}`);\n  return `${tokenName}=${tokenParts.join(tokenSeparator)}`;\n};","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/cloudinary/lib-es5/auth_token.js"],"names":["crypto","require","smart_escape","unsafe","digest","message","key","createHmac","Buffer","from","update","escapeToLower","url","safeUrl","replace","match","toLowerCase","module","exports","options","tokenName","token_name","tokenSeparator","expiration","duration","start","start_time","Math","round","Date","now","Error","tokenParts","ip","push","acl","toSign","concat","auth","join"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * Authorization Token\r\n * @module auth_token\r\n */\r\n\r\nvar crypto = require('crypto');\r\nvar smart_escape = require('./utils/encoding/smart_escape');\r\n\r\nvar unsafe = /([ \"#%&'/:;<=>?@[\\]^`{|}~]+)/g;\r\n\r\nfunction digest(message, key) {\r\n  return crypto.createHmac(\"sha256\", Buffer.from(key, \"hex\")).update(message).digest('hex');\r\n}\r\n\r\n/**\r\n * Escape url using lowercase hex code\r\n * @param {string} url a url string\r\n * @return {string} escaped url\r\n */\r\nfunction escapeToLower(url) {\r\n  var safeUrl = smart_escape(url, unsafe);\r\n  return safeUrl.replace(/%../g, function (match) {\r\n    return match.toLowerCase();\r\n  });\r\n}\r\n\r\n/**\r\n * Auth token options\r\n * @typedef {object} authTokenOptions\r\n * @property {string} [token_name=\"__cld_token__\"] The name of the token.\r\n * @property {string} key The secret key required to sign the token.\r\n * @property {string} ip The IP address of the client.\r\n * @property {number} start_time=now The start time of the token in seconds from epoch.\r\n * @property {string} expiration The expiration time of the token in seconds from epoch.\r\n * @property {string} duration The duration of the token (from start_time).\r\n * @property {string} acl The ACL for the token.\r\n * @property {string} url The URL to authentication in case of a URL token.\r\n *\r\n */\r\n\r\n/**\r\n * Generate an authorization token\r\n * @param {authTokenOptions} options\r\n * @returns {string} the authorization token\r\n */\r\nmodule.exports = function (options) {\r\n  var tokenName = options.token_name ? options.token_name : \"__cld_token__\";\r\n  var tokenSeparator = \"~\";\r\n  if (options.expiration == null) {\r\n    if (options.duration != null) {\r\n      var start = options.start_time != null ? options.start_time : Math.round(Date.now() / 1000);\r\n      options.expiration = start + options.duration;\r\n    } else {\r\n      throw new Error(\"Must provide either expiration or duration\");\r\n    }\r\n  }\r\n  var tokenParts = [];\r\n  if (options.ip != null) {\r\n    tokenParts.push(`ip=${options.ip}`);\r\n  }\r\n  if (options.start_time != null) {\r\n    tokenParts.push(`st=${options.start_time}`);\r\n  }\r\n  tokenParts.push(`exp=${options.expiration}`);\r\n  if (options.acl != null) {\r\n    tokenParts.push(`acl=${escapeToLower(options.acl)}`);\r\n  }\r\n  var toSign = [].concat(tokenParts);\r\n  if (options.url != null && options.acl == null) {\r\n    var url = escapeToLower(options.url);\r\n    toSign.push(`url=${url}`);\r\n  }\r\n  var auth = digest(toSign.join(tokenSeparator), options.key);\r\n  tokenParts.push(`hmac=${auth}`);\r\n  return `${tokenName}=${tokenParts.join(tokenSeparator)}`;\r\n};"]},"metadata":{},"sourceType":"script"}