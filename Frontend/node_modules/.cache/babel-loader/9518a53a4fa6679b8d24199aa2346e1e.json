{"ast":null,"code":"\"use strict\";\n/**\r\n * Various utility functions.\r\n * @namespace\r\n */\n\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\nEnum;\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch = require(\"@protobufjs/fetch\");\nutil.path = require(\"@protobufjs/path\");\n/**\r\n * Node's fs module if available.\r\n * @type {Object.<string,*>}\r\n */\n\nutil.fs = util.inquire(\"fs\");\n/**\r\n * Converts an object's values to an array.\r\n * @param {Object.<string,*>} object Object to convert\r\n * @returns {Array.<*>} Converted array\r\n */\n\nutil.toArray = function toArray(object) {\n  if (object) {\n    var keys = Object.keys(object),\n        array = new Array(keys.length),\n        index = 0;\n\n    while (index < keys.length) array[index] = object[keys[index++]];\n\n    return array;\n  }\n\n  return [];\n};\n/**\r\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\r\n * @param {Array.<*>} array Array to convert\r\n * @returns {Object.<string,*>} Converted object\r\n */\n\n\nutil.toObject = function toObject(array) {\n  var object = {},\n      index = 0;\n\n  while (index < array.length) {\n    var key = array[index++],\n        val = array[index++];\n    if (val !== undefined) object[key] = val;\n  }\n\n  return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe = /\"/g;\n/**\r\n * Tests whether the specified name is a reserved word in JS.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\nutil.isReserved = function isReserved(name) {\n  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\r\n * Returns a safe property accessor for the specified property name.\r\n * @param {string} prop Property name\r\n * @returns {string} Safe accessor\r\n */\n\n\nutil.safeProp = function safeProp(prop) {\n  if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n  return \".\" + prop;\n};\n/**\r\n * Converts the first character of a string to upper case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\n\n\nutil.ucFirst = function ucFirst(str) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n/**\r\n * Converts a string to camel case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\n\nutil.camelCase = function camelCase(str) {\n  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n/**\r\n * Compares reflected fields by id.\r\n * @param {Field} a First field\r\n * @param {Field} b Second field\r\n * @returns {number} Comparison value\r\n */\n\n\nutil.compareFieldsById = function compareFieldsById(a, b) {\n  return a.id - b.id;\n};\n/**\r\n * Decorator helper for types (TypeScript).\r\n * @param {Constructor<T>} ctor Constructor function\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {Type} Reflected type\r\n * @template T extends Message<T>\r\n * @property {Root} root Decorators root\r\n */\n\n\nutil.decorateType = function decorateType(ctor, typeName) {\n  /* istanbul ignore if */\n  if (ctor.$type) {\n    if (typeName && ctor.$type.name !== typeName) {\n      util.decorateRoot.remove(ctor.$type);\n      ctor.$type.name = typeName;\n      util.decorateRoot.add(ctor.$type);\n    }\n\n    return ctor.$type;\n  }\n  /* istanbul ignore next */\n\n\n  if (!Type) Type = require(\"./type\");\n  var type = new Type(typeName || ctor.name);\n  util.decorateRoot.add(type);\n  type.ctor = ctor; // sets up .encode, .decode etc.\n\n  Object.defineProperty(ctor, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  Object.defineProperty(ctor.prototype, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  return type;\n};\n\nvar decorateEnumIndex = 0;\n/**\r\n * Decorator helper for enums (TypeScript).\r\n * @param {Object} object Enum object\r\n * @returns {Enum} Reflected enum\r\n */\n\nutil.decorateEnum = function decorateEnum(object) {\n  /* istanbul ignore if */\n  if (object.$type) return object.$type;\n  /* istanbul ignore next */\n\n  if (!Enum) Enum = require(\"./enum\");\n  var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n  util.decorateRoot.add(enm);\n  Object.defineProperty(object, \"$type\", {\n    value: enm,\n    enumerable: false\n  });\n  return enm;\n};\n/**\r\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {string} path dot '.' delimited path of the property to set\r\n * @param {Object} value the value to set\r\n * @returns {Object.<string,*>} Destination object\r\n */\n\n\nutil.setProperty = function setProperty(dst, path, value) {\n  function setProp(dst, path, value) {\n    var part = path.shift();\n\n    if (path.length > 0) {\n      dst[part] = setProp(dst[part] || {}, path, value);\n    } else {\n      var prevValue = dst[part];\n      if (prevValue) value = [].concat(prevValue).concat(value);\n      dst[part] = value;\n    }\n\n    return dst;\n  }\n\n  if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n  if (!path) throw TypeError(\"path must be specified\");\n  path = path.split(\".\");\n  return setProp(dst, path, value);\n};\n/**\r\n * Decorator root (TypeScript).\r\n * @name util.decorateRoot\r\n * @type {Root}\r\n * @readonly\r\n */\n\n\nObject.defineProperty(util, \"decorateRoot\", {\n  get: function () {\n    return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n  }\n});","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/protobufjs/src/util.js"],"names":["util","module","exports","require","roots","Type","Enum","codegen","fetch","path","fs","inquire","toArray","object","keys","Object","array","Array","length","index","toObject","key","val","undefined","safePropBackslashRe","safePropQuoteRe","isReserved","name","test","safeProp","prop","replace","ucFirst","str","charAt","toUpperCase","substring","camelCaseRe","camelCase","$0","$1","compareFieldsById","a","b","id","decorateType","ctor","typeName","$type","decorateRoot","remove","add","type","defineProperty","value","enumerable","prototype","decorateEnumIndex","decorateEnum","enm","setProperty","dst","setProp","part","shift","prevValue","concat","TypeError","split","get"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\n/**\r\n * Various utility functions.\r\n * @namespace\r\n */\r\nvar util = module.exports = require(\"./util/minimal\");\r\n\r\nvar roots = require(\"./roots\");\r\n\r\nvar Type, // cyclic\r\n    Enum;\r\n\r\nutil.codegen = require(\"@protobufjs/codegen\");\r\nutil.fetch   = require(\"@protobufjs/fetch\");\r\nutil.path    = require(\"@protobufjs/path\");\r\n\r\n/**\r\n * Node's fs module if available.\r\n * @type {Object.<string,*>}\r\n */\r\nutil.fs = util.inquire(\"fs\");\r\n\r\n/**\r\n * Converts an object's values to an array.\r\n * @param {Object.<string,*>} object Object to convert\r\n * @returns {Array.<*>} Converted array\r\n */\r\nutil.toArray = function toArray(object) {\r\n    if (object) {\r\n        var keys  = Object.keys(object),\r\n            array = new Array(keys.length),\r\n            index = 0;\r\n        while (index < keys.length)\r\n            array[index] = object[keys[index++]];\r\n        return array;\r\n    }\r\n    return [];\r\n};\r\n\r\n/**\r\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\r\n * @param {Array.<*>} array Array to convert\r\n * @returns {Object.<string,*>} Converted object\r\n */\r\nutil.toObject = function toObject(array) {\r\n    var object = {},\r\n        index  = 0;\r\n    while (index < array.length) {\r\n        var key = array[index++],\r\n            val = array[index++];\r\n        if (val !== undefined)\r\n            object[key] = val;\r\n    }\r\n    return object;\r\n};\r\n\r\nvar safePropBackslashRe = /\\\\/g,\r\n    safePropQuoteRe     = /\"/g;\r\n\r\n/**\r\n * Tests whether the specified name is a reserved word in JS.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\r\nutil.isReserved = function isReserved(name) {\r\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\r\n};\r\n\r\n/**\r\n * Returns a safe property accessor for the specified property name.\r\n * @param {string} prop Property name\r\n * @returns {string} Safe accessor\r\n */\r\nutil.safeProp = function safeProp(prop) {\r\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop))\r\n        return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\r\n    return \".\" + prop;\r\n};\r\n\r\n/**\r\n * Converts the first character of a string to upper case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.ucFirst = function ucFirst(str) {\r\n    return str.charAt(0).toUpperCase() + str.substring(1);\r\n};\r\n\r\nvar camelCaseRe = /_([a-z])/g;\r\n\r\n/**\r\n * Converts a string to camel case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.camelCase = function camelCase(str) {\r\n    return str.substring(0, 1)\r\n         + str.substring(1)\r\n               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });\r\n};\r\n\r\n/**\r\n * Compares reflected fields by id.\r\n * @param {Field} a First field\r\n * @param {Field} b Second field\r\n * @returns {number} Comparison value\r\n */\r\nutil.compareFieldsById = function compareFieldsById(a, b) {\r\n    return a.id - b.id;\r\n};\r\n\r\n/**\r\n * Decorator helper for types (TypeScript).\r\n * @param {Constructor<T>} ctor Constructor function\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {Type} Reflected type\r\n * @template T extends Message<T>\r\n * @property {Root} root Decorators root\r\n */\r\nutil.decorateType = function decorateType(ctor, typeName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (ctor.$type) {\r\n        if (typeName && ctor.$type.name !== typeName) {\r\n            util.decorateRoot.remove(ctor.$type);\r\n            ctor.$type.name = typeName;\r\n            util.decorateRoot.add(ctor.$type);\r\n        }\r\n        return ctor.$type;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (!Type)\r\n        Type = require(\"./type\");\r\n\r\n    var type = new Type(typeName || ctor.name);\r\n    util.decorateRoot.add(type);\r\n    type.ctor = ctor; // sets up .encode, .decode etc.\r\n    Object.defineProperty(ctor, \"$type\", { value: type, enumerable: false });\r\n    Object.defineProperty(ctor.prototype, \"$type\", { value: type, enumerable: false });\r\n    return type;\r\n};\r\n\r\nvar decorateEnumIndex = 0;\r\n\r\n/**\r\n * Decorator helper for enums (TypeScript).\r\n * @param {Object} object Enum object\r\n * @returns {Enum} Reflected enum\r\n */\r\nutil.decorateEnum = function decorateEnum(object) {\r\n\r\n    /* istanbul ignore if */\r\n    if (object.$type)\r\n        return object.$type;\r\n\r\n    /* istanbul ignore next */\r\n    if (!Enum)\r\n        Enum = require(\"./enum\");\r\n\r\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\r\n    util.decorateRoot.add(enm);\r\n    Object.defineProperty(object, \"$type\", { value: enm, enumerable: false });\r\n    return enm;\r\n};\r\n\r\n\r\n/**\r\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {string} path dot '.' delimited path of the property to set\r\n * @param {Object} value the value to set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nutil.setProperty = function setProperty(dst, path, value) {\r\n    function setProp(dst, path, value) {\r\n        var part = path.shift();\r\n        if (path.length > 0) {\r\n            dst[part] = setProp(dst[part] || {}, path, value);\r\n        } else {\r\n            var prevValue = dst[part];\r\n            if (prevValue)\r\n                value = [].concat(prevValue).concat(value);\r\n            dst[part] = value;\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    if (typeof dst !== \"object\")\r\n        throw TypeError(\"dst must be an object\");\r\n    if (!path)\r\n        throw TypeError(\"path must be specified\");\r\n\r\n    path = path.split(\".\");\r\n    return setProp(dst, path, value);\r\n};\r\n\r\n/**\r\n * Decorator root (TypeScript).\r\n * @name util.decorateRoot\r\n * @type {Root}\r\n * @readonly\r\n */\r\nObject.defineProperty(util, \"decorateRoot\", {\r\n    get: function() {\r\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"script"}