{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nlet fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\nconst statMethods = {\n  stat,\n  lstat\n};\n/**\r\n * @typedef {String} Path\r\n */\n\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\n// fsevents instance helper functions\n\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\r\n * @mixin\r\n */\n\n\nclass FsEventsHandler {\n  /**\r\n   * @param {import('../index').FSWatcher} fsw\r\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat(path);\n      if (this.fsw.closed) return;\n\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\r\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\r\n   * Handle symlinks encountered during directory scan\r\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n   * @param {String} realPath   - real path (in case of symlinks)\r\n   * @param {Function} transform  - path transformer\r\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n   * @returns {Function} closer for the watcher instance\r\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath.dirname(path);\n      const item = sysPath.basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE) {\n          let stats;\n\n          try {\n            stats = await stat(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\r\n   * Handle symlinks encountered during directory scan\r\n   * @param {String} linkPath path to symlink\r\n   * @param {String} fullPath absolute path to the symlink\r\n   * @param {Function} transform pre-existing path transformer\r\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n   * @returns {Promise<void>}\r\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath.join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\r\n   *\r\n   * @param {Path} newPath\r\n   * @param {fs.Stats} stats\r\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\n    const base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\r\n   * Handle added path with fsevents\r\n   * @param {String} path file/dir path or glob pattern\r\n   * @param {Function|Boolean=} transform converts working path to what the user expects\r\n   * @param {Boolean=} forceAdd ensure add is emitted\r\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n   * @returns {Promise<void>}\r\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/chokidar/lib/fsevents-handler.js"],"names":["fs","require","sysPath","promisify","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","match","maj","Number","parseInt","min","undefined","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_ERROR","STR_DATA","STR_END","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","ROOT_GLOBSTAR","DIR_SUFFIX","DOT_SLASH","FUNCTION_TYPE","EMPTY_FN","IDENTITY_FN","Depth","value","isNaN","depth","stat","lstat","realpath","statMethods","FSEventsWatchers","Map","consolidateThreshhold","wrongEventFlags","Set","createFSEventsInstance","path","callback","stop","watch","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","parentPath","cont","get","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","watchedPath","keys","listeners","add","watcher","size","getInfo","forEach","list","event","set","lst","delete","then","Object","freeze","count","canUse","calcDepth","root","i","sameTypes","stats","type","isDirectory","isSymbolicLink","isFile","FsEventsHandler","constructor","fsw","checkIgnored","ipaths","_ignoredPaths","_isIgnored","addOrChange","parent","watchedDir","item","opts","has","handleEvent","checkExists","closed","code","_remove","_getWatchedDir","followSymlinks","curDepth","_addToFsEvents","eventName","_emit","_watchWithFsEvents","transform","globFilter","options","watchCallback","join","relative","basename","ignored","closer","_emitRaw","_emitReady","_handleFsEventsSymlink","linkPath","_symlinkPaths","_incrReadyCount","linkTarget","aliasedPath","_handleError","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","ignoreInitial","initWatch","wh","_addPathCloser","priorDepth","_getWatchHelpers","statMethod","_readdirp","fileFilter","entry","filterPath","directoryFilter","filterDir","on","joinedPath","persistent","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\n\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n\r\nif (fsevents) {\r\n  // TODO: real check\r\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\r\n  if (mtch && mtch[1] && mtch[2]) {\r\n    const maj = Number.parseInt(mtch[1], 10);\r\n    const min = Number.parseInt(mtch[2], 10);\r\n    if (maj === 8 && min < 16) {\r\n      fsevents = undefined;\r\n    }\r\n  }\r\n}\r\n\r\nconst {\r\n  EV_ADD,\r\n  EV_CHANGE,\r\n  EV_ADD_DIR,\r\n  EV_UNLINK,\r\n  EV_ERROR,\r\n  STR_DATA,\r\n  STR_END,\r\n  FSEVENT_CREATED,\r\n  FSEVENT_MODIFIED,\r\n  FSEVENT_DELETED,\r\n  FSEVENT_MOVED,\r\n  // FSEVENT_CLONED,\r\n  FSEVENT_UNKNOWN,\r\n  FSEVENT_TYPE_FILE,\r\n  FSEVENT_TYPE_DIRECTORY,\r\n  FSEVENT_TYPE_SYMLINK,\r\n\r\n  ROOT_GLOBSTAR,\r\n  DIR_SUFFIX,\r\n  DOT_SLASH,\r\n  FUNCTION_TYPE,\r\n  EMPTY_FN,\r\n  IDENTITY_FN\r\n} = require('./constants');\r\n\r\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\r\n\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst realpath = promisify(fs.realpath);\r\n\r\nconst statMethods = { stat, lstat };\r\n\r\n/**\r\n * @typedef {String} Path\r\n */\r\n\r\n/**\r\n * @typedef {Object} FsEventsWatchContainer\r\n * @property {Set<Function>} listeners\r\n * @property {Function} rawEmitter\r\n * @property {{stop: Function}} watcher\r\n */\r\n\r\n// fsevents instance helper functions\r\n/**\r\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n * @type {Map<Path,FsEventsWatchContainer>}\r\n */\r\nconst FSEventsWatchers = new Map();\r\n\r\n// Threshold of duplicate path prefixes at which to start\r\n// consolidating going forward\r\nconst consolidateThreshhold = 10;\r\n\r\nconst wrongEventFlags = new Set([\r\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\r\n]);\r\n\r\n/**\r\n * Instantiates the fsevents interface\r\n * @param {Path} path path to be watched\r\n * @param {Function} callback called when fsevents is bound and ready\r\n * @returns {{stop: Function}} new fsevents instance\r\n */\r\nconst createFSEventsInstance = (path, callback) => {\r\n  const stop = fsevents.watch(path, callback);\r\n  return {stop};\r\n};\r\n\r\n/**\r\n * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n * the same file tree.\r\n * @param {Path} path           - to be watched\r\n * @param {Path} realPath       - real path for symlinks\r\n * @param {Function} listener   - called when fsevents emits events\r\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n * @returns {Function} closer\r\n */\r\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\r\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\r\n  const parentPath = sysPath.dirname(watchPath);\r\n  let cont = FSEventsWatchers.get(watchPath);\r\n\r\n  // If we've accumulated a substantial number of paths that\r\n  // could have been consolidated by watching one directory\r\n  // above the current one, create a watcher on the parent\r\n  // path instead, so that we do consolidate going forward.\r\n  if (couldConsolidate(parentPath)) {\r\n    watchPath = parentPath;\r\n  }\r\n\r\n  const resolvedPath = sysPath.resolve(path);\r\n  const hasSymlink = resolvedPath !== realPath;\r\n\r\n  const filteredListener = (fullPath, flags, info) => {\r\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\r\n    if (\r\n      fullPath === resolvedPath ||\r\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\r\n    ) listener(fullPath, flags, info);\r\n  };\r\n\r\n  // check if there is already a watcher on a parent path\r\n  // modifies `watchPath` to the parent path when it finds a match\r\n  let watchedParent = false;\r\n  for (const watchedPath of FSEventsWatchers.keys()) {\r\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\r\n      watchPath = watchedPath;\r\n      cont = FSEventsWatchers.get(watchPath);\r\n      watchedParent = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (cont || watchedParent) {\r\n    cont.listeners.add(filteredListener);\r\n  } else {\r\n    cont = {\r\n      listeners: new Set([filteredListener]),\r\n      rawEmitter,\r\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\r\n        if (!cont.listeners.size) return;\r\n        const info = fsevents.getInfo(fullPath, flags);\r\n        cont.listeners.forEach(list => {\r\n          list(fullPath, flags, info);\r\n        });\r\n\r\n        cont.rawEmitter(info.event, fullPath, info);\r\n      })\r\n    };\r\n    FSEventsWatchers.set(watchPath, cont);\r\n  }\r\n\r\n  // removes this instance's listeners and closes the underlying fsevents\r\n  // instance if there are no more listeners left\r\n  return () => {\r\n    const lst = cont.listeners;\r\n\r\n    lst.delete(filteredListener);\r\n    if (!lst.size) {\r\n      FSEventsWatchers.delete(watchPath);\r\n      if (cont.watcher) return cont.watcher.stop().then(() => {\r\n        cont.rawEmitter = cont.watcher = undefined;\r\n        Object.freeze(cont);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n// Decide whether or not we should start a new higher-level\r\n// parent watcher\r\nconst couldConsolidate = (path) => {\r\n  let count = 0;\r\n  for (const watchPath of FSEventsWatchers.keys()) {\r\n    if (watchPath.indexOf(path) === 0) {\r\n      count++;\r\n      if (count >= consolidateThreshhold) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// returns boolean indicating whether fsevents can be used\r\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\r\n\r\n// determines subdirectory traversal levels from root to path\r\nconst calcDepth = (path, root) => {\r\n  let i = 0;\r\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\r\n  return i;\r\n};\r\n\r\n// returns boolean indicating whether the fsevents' event info has the same type\r\n// as the one returned by fs.stat\r\nconst sameTypes = (info, stats) => (\r\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\r\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\r\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\r\n)\r\n\r\n/**\r\n * @mixin\r\n */\r\nclass FsEventsHandler {\r\n\r\n/**\r\n * @param {import('../index').FSWatcher} fsw\r\n */\r\nconstructor(fsw) {\r\n  this.fsw = fsw;\r\n}\r\ncheckIgnored(path, stats) {\r\n  const ipaths = this.fsw._ignoredPaths;\r\n  if (this.fsw._isIgnored(path, stats)) {\r\n    ipaths.add(path);\r\n    if (stats && stats.isDirectory()) {\r\n      ipaths.add(path + ROOT_GLOBSTAR);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  ipaths.delete(path);\r\n  ipaths.delete(path + ROOT_GLOBSTAR);\r\n}\r\n\r\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\r\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n}\r\n\r\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  try {\r\n    const stats = await stat(path)\r\n    if (this.fsw.closed) return;\r\n    if (sameTypes(info, stats)) {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  } catch (error) {\r\n    if (error.code === 'EACCES') {\r\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    } else {\r\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n    }\r\n  }\r\n}\r\n\r\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n  if (this.fsw.closed || this.checkIgnored(path)) return;\r\n\r\n  if (event === EV_UNLINK) {\r\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\r\n    // suppress unlink events on never before seen files\r\n    if (isDirectory || watchedDir.has(item)) {\r\n      this.fsw._remove(parent, item, isDirectory);\r\n    }\r\n  } else {\r\n    if (event === EV_ADD) {\r\n      // track new directories\r\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\r\n\r\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\r\n        // push symlinks back to the top of the stack to get handled\r\n        const curDepth = opts.depth === undefined ?\r\n          undefined : calcDepth(fullPath, realPath) + 1;\r\n        return this._addToFsEvents(path, false, true, curDepth);\r\n      }\r\n\r\n      // track new paths\r\n      // (other than symlinks being followed, which will be tracked soon)\r\n      this.fsw._getWatchedDir(parent).add(item);\r\n    }\r\n    /**\r\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n     */\r\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\r\n    this.fsw._emit(eventName, path);\r\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n * @param {String} realPath   - real path (in case of symlinks)\r\n * @param {Function} transform  - path transformer\r\n * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n * @returns {Function} closer for the watcher instance\r\n*/\r\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\r\n  if (this.fsw.closed) return;\r\n  if (this.fsw._isIgnored(watchPath)) return;\r\n  const opts = this.fsw.options;\r\n  const watchCallback = async (fullPath, flags, info) => {\r\n    if (this.fsw.closed) return;\r\n    if (\r\n      opts.depth !== undefined &&\r\n      calcDepth(fullPath, realPath) > opts.depth\r\n    ) return;\r\n    const path = transform(sysPath.join(\r\n      watchPath, sysPath.relative(watchPath, fullPath)\r\n    ));\r\n    if (globFilter && !globFilter(path)) return;\r\n    // ensure directories are tracked\r\n    const parent = sysPath.dirname(path);\r\n    const item = sysPath.basename(path);\r\n    const watchedDir = this.fsw._getWatchedDir(\r\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\r\n    );\r\n\r\n    // correct for wrong events emitted\r\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\r\n      if (typeof opts.ignored === FUNCTION_TYPE) {\r\n        let stats;\r\n        try {\r\n          stats = await stat(path);\r\n        } catch (error) {}\r\n        if (this.fsw.closed) return;\r\n        if (this.checkIgnored(path, stats)) return;\r\n        if (sameTypes(info, stats)) {\r\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        } else {\r\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n        }\r\n      } else {\r\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    } else {\r\n      switch (info.event) {\r\n      case FSEVENT_CREATED:\r\n      case FSEVENT_MODIFIED:\r\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      case FSEVENT_DELETED:\r\n      case FSEVENT_MOVED:\r\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n      }\r\n    }\r\n  };\r\n\r\n  const closer = setFSEventsListener(\r\n    watchPath,\r\n    realPath,\r\n    watchCallback,\r\n    this.fsw._emitRaw\r\n  );\r\n\r\n  this.fsw._emitReady();\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered during directory scan\r\n * @param {String} linkPath path to symlink\r\n * @param {String} fullPath absolute path to the symlink\r\n * @param {Function} transform pre-existing path transformer\r\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n * @returns {Promise<void>}\r\n */\r\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\r\n  // don't follow the same symlink more than once\r\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\r\n\r\n  this.fsw._symlinkPaths.set(fullPath, true);\r\n  this.fsw._incrReadyCount();\r\n\r\n  try {\r\n    const linkTarget = await realpath(linkPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(linkTarget)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n\r\n    this.fsw._incrReadyCount();\r\n\r\n    // add the linkTarget for watching with a wrapper for transform\r\n    // that causes emitted paths to incorporate the link's path\r\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\r\n      let aliasedPath = linkPath;\r\n      if (linkTarget && linkTarget !== DOT_SLASH) {\r\n        aliasedPath = path.replace(linkTarget, linkPath);\r\n      } else if (path !== DOT_SLASH) {\r\n        aliasedPath = sysPath.join(linkPath, path);\r\n      }\r\n      return transform(aliasedPath);\r\n    }, false, curDepth);\r\n  } catch(error) {\r\n    if (this.fsw._handleError(error)) {\r\n      return this.fsw._emitReady();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Path} newPath\r\n * @param {fs.Stats} stats\r\n */\r\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\r\n  const pp = processPath(newPath);\r\n  const isDir = stats.isDirectory();\r\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\r\n  const base = sysPath.basename(pp);\r\n\r\n  // ensure empty dirs get tracked\r\n  if (isDir) this.fsw._getWatchedDir(pp);\r\n  if (dirObj.has(base)) return;\r\n  dirObj.add(base);\r\n\r\n  if (!opts.ignoreInitial || forceAdd === true) {\r\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\r\n  }\r\n}\r\n\r\ninitWatch(realPath, path, wh, processPath) {\r\n  if (this.fsw.closed) return;\r\n  const closer = this._watchWithFsEvents(\r\n    wh.watchPath,\r\n    sysPath.resolve(realPath || wh.watchPath),\r\n    processPath,\r\n    wh.globFilter\r\n  );\r\n  this.fsw._addPathCloser(path, closer);\r\n}\r\n\r\n/**\r\n * Handle added path with fsevents\r\n * @param {String} path file/dir path or glob pattern\r\n * @param {Function|Boolean=} transform converts working path to what the user expects\r\n * @param {Boolean=} forceAdd ensure add is emitted\r\n * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n * @returns {Promise<void>}\r\n */\r\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const opts = this.fsw.options;\r\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\r\n\r\n  const wh = this.fsw._getWatchHelpers(path);\r\n\r\n  // evaluate what is at the path we're being asked to watch\r\n  try {\r\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n      throw null;\r\n    }\r\n    if (stats.isDirectory()) {\r\n      // emit addDir unless this is a glob parent\r\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\r\n\r\n      // don't recurse further if it would exceed depth setting\r\n      if (priorDepth && priorDepth > opts.depth) return;\r\n\r\n      // scan the contents of the dir\r\n      this.fsw._readdirp(wh.watchPath, {\r\n        fileFilter: entry => wh.filterPath(entry),\r\n        directoryFilter: entry => wh.filterDir(entry),\r\n        ...Depth(opts.depth - (priorDepth || 0))\r\n      }).on(STR_DATA, (entry) => {\r\n        // need to check filterPath on dirs b/c filterDir is less restrictive\r\n        if (this.fsw.closed) {\r\n          return;\r\n        }\r\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\r\n\r\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\r\n        const {fullPath} = entry;\r\n\r\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\r\n          // preserve the current depth here since it can't be derived from\r\n          // real paths past the symlink\r\n          const curDepth = opts.depth === undefined ?\r\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\r\n\r\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\r\n        } else {\r\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\r\n        }\r\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\r\n        this.fsw._emitReady();\r\n      });\r\n    } else {\r\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\r\n      this.fsw._emitReady();\r\n    }\r\n  } catch (error) {\r\n    if (!error || this.fsw._handleError(error)) {\r\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\r\n      this.fsw._emitReady();\r\n      this.fsw._emitReady();\r\n    }\r\n  }\r\n\r\n  if (opts.persistent && forceAdd !== true) {\r\n    if (typeof transform === FUNCTION_TYPE) {\r\n      // realpath has already been resolved\r\n      this.initWatch(undefined, path, wh, processPath);\r\n    } else {\r\n      let realPath;\r\n      try {\r\n        realPath = await realpath(wh.watchPath);\r\n      } catch (e) {}\r\n      this.initWatch(realPath, path, wh, processPath);\r\n    }\r\n  }\r\n}\r\n\r\n}\r\n\r\nmodule.exports = FsEventsHandler;\r\nmodule.exports.canUse = canUse;\r\n"]},"metadata":{},"sourceType":"script"}