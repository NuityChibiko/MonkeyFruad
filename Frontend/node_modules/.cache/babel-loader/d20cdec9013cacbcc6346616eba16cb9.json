{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\n\nconst _ = require(\"lodash\");\n\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\n\nclass Context {\n  constructor(fields, locations, stack, optional, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n\n  get errors() {\n    return this._errors;\n  }\n\n  getData(options = {\n    requiredOnly: false\n  }) {\n    // Have to store this.optional in a const otherwise TS thinks the value could have changed\n    // when the functions below run\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional.nullable ? value != null : true, value => optional.checkFalsy ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location'); // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n\n\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n    });\n  }\n\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n\n    instance.value = value;\n  }\n\n  addError(message, valueOrNestedErrors, meta) {\n    const msg = message || this.message || 'Invalid value';\n\n    if (meta) {\n      this._errors.push({\n        value: valueOrNestedErrors,\n        msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n        param: meta.path,\n        location: meta.location\n      });\n    } else {\n      this._errors.push({\n        msg,\n        param: '_error',\n        nestedErrors: valueOrNestedErrors\n      });\n    }\n  }\n\n}\n\nexports.Context = Context;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/express-validator/src/context.js"],"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","constructor","fields","locations","stack","optional","message","_errors","dataMap","Map","errors","getData","options","requiredOnly","checks","undefined","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","assign","setData","get","Error","addError","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Context = void 0;\r\nconst _ = require(\"lodash\");\r\nfunction getDataMapKey(path, location) {\r\n    return `${location}:${path}`;\r\n}\r\nclass Context {\r\n    constructor(fields, locations, stack, optional, message) {\r\n        this.fields = fields;\r\n        this.locations = locations;\r\n        this.stack = stack;\r\n        this.optional = optional;\r\n        this.message = message;\r\n        this._errors = [];\r\n        this.dataMap = new Map();\r\n    }\r\n    get errors() {\r\n        return this._errors;\r\n    }\r\n    getData(options = { requiredOnly: false }) {\r\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\r\n        // when the functions below run\r\n        const { optional } = this;\r\n        const checks = options.requiredOnly && optional\r\n            ? [\r\n                (value) => value !== undefined,\r\n                (value) => (optional.nullable ? value != null : true),\r\n                (value) => (optional.checkFalsy ? value : true),\r\n            ]\r\n            : [];\r\n        return _([...this.dataMap.values()])\r\n            .groupBy('originalPath')\r\n            .flatMap((instances, group) => {\r\n            const locations = _.uniqBy(instances, 'location');\r\n            // #331 - When multiple locations are involved, all of them must pass the validation.\r\n            // If none of the locations contain the field, we at least include one for error reporting.\r\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\r\n            // paths, so we may want to skip this filtering.\r\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\r\n                const withValue = instances.filter(instance => instance.value !== undefined);\r\n                return withValue.length ? withValue : [instances[0]];\r\n            }\r\n            return instances;\r\n        })\r\n            .filter(instance => checks.every(check => check(instance.value)))\r\n            .valueOf();\r\n    }\r\n    addFieldInstances(instances) {\r\n        instances.forEach(instance => {\r\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\r\n        });\r\n    }\r\n    setData(path, value, location) {\r\n        const instance = this.dataMap.get(getDataMapKey(path, location));\r\n        if (!instance) {\r\n            throw new Error('Attempt to write data that did not pre-exist in context');\r\n        }\r\n        instance.value = value;\r\n    }\r\n    addError(message, valueOrNestedErrors, meta) {\r\n        const msg = message || this.message || 'Invalid value';\r\n        if (meta) {\r\n            this._errors.push({\r\n                value: valueOrNestedErrors,\r\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\r\n                param: meta.path,\r\n                location: meta.location,\r\n            });\r\n        }\r\n        else {\r\n            this._errors.push({\r\n                msg,\r\n                param: '_error',\r\n                nestedErrors: valueOrNestedErrors,\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.Context = Context;\r\n"]},"metadata":{},"sourceType":"script"}