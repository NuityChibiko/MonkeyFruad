{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst {\n  Readable\n} = require('stream');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n/**\r\n * @typedef {Object} EntryInfo\r\n * @property {String} path\r\n * @property {String} fullPath\r\n * @property {fs.Stats=} stats\r\n * @property {fs.Dirent=} dirent\r\n * @property {String} basename\r\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {\n        path: sysPath.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            return this._onError(new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`));\n          }\n\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\r\n * @typedef {Object} ReaddirpArguments\r\n * @property {Function=} fileFilter\r\n * @property {Function=} directoryFilter\r\n * @property {String=} type\r\n * @property {Number=} depth\r\n * @property {String=} root\r\n * @property {Boolean=} lstat\r\n * @property {Boolean=} bigint\r\n */\n\n/**\r\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\r\n * @param {String} root Root directory\r\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\r\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/readdirp/index.js"],"names":["fs","require","Readable","sysPath","promisify","picomatch","readdir","stat","lstat","realpath","BANG","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","slice","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","process","platform","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","map","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","Error","readdirp","TypeError","readdirpPromise","reject","on","promise","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst { Readable } = require('stream');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\nconst picomatch = require('picomatch');\r\n\r\nconst readdir = promisify(fs.readdir);\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst realpath = promisify(fs.realpath);\r\n\r\n/**\r\n * @typedef {Object} EntryInfo\r\n * @property {String} path\r\n * @property {String} fullPath\r\n * @property {fs.Stats=} stats\r\n * @property {fs.Dirent=} dirent\r\n * @property {String} basename\r\n */\r\n\r\nconst BANG = '!';\r\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\r\nconst FILE_TYPE = 'files';\r\nconst DIR_TYPE = 'directories';\r\nconst FILE_DIR_TYPE = 'files_directories';\r\nconst EVERYTHING_TYPE = 'all';\r\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\r\n\r\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\r\n\r\nconst normalizeFilter = filter => {\r\n  if (filter === undefined) return;\r\n  if (typeof filter === 'function') return filter;\r\n\r\n  if (typeof filter === 'string') {\r\n    const glob = picomatch(filter.trim());\r\n    return entry => glob(entry.basename);\r\n  }\r\n\r\n  if (Array.isArray(filter)) {\r\n    const positive = [];\r\n    const negative = [];\r\n    for (const item of filter) {\r\n      const trimmed = item.trim();\r\n      if (trimmed.charAt(0) === BANG) {\r\n        negative.push(picomatch(trimmed.slice(1)));\r\n      } else {\r\n        positive.push(picomatch(trimmed));\r\n      }\r\n    }\r\n\r\n    if (negative.length > 0) {\r\n      if (positive.length > 0) {\r\n        return entry =>\r\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\r\n      }\r\n      return entry => !negative.some(f => f(entry.basename));\r\n    }\r\n    return entry => positive.some(f => f(entry.basename));\r\n  }\r\n};\r\n\r\nclass ReaddirpStream extends Readable {\r\n  static get defaultOptions() {\r\n    return {\r\n      root: '.',\r\n      /* eslint-disable no-unused-vars */\r\n      fileFilter: (path) => true,\r\n      directoryFilter: (path) => true,\r\n      /* eslint-enable no-unused-vars */\r\n      type: FILE_TYPE,\r\n      lstat: false,\r\n      depth: 2147483648,\r\n      alwaysStat: false\r\n    };\r\n  }\r\n\r\n  constructor(options = {}) {\r\n    super({\r\n      objectMode: true,\r\n      autoDestroy: true,\r\n      highWaterMark: options.highWaterMark || 4096\r\n    });\r\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\r\n    const { root, type } = opts;\r\n\r\n    this._fileFilter = normalizeFilter(opts.fileFilter);\r\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\r\n\r\n    const statMethod = opts.lstat ? lstat : stat;\r\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\r\n    if (process.platform === 'win32' && stat.length === 3) {\r\n      this._stat = path => statMethod(path, { bigint: true });\r\n    } else {\r\n      this._stat = statMethod;\r\n    }\r\n\r\n    this._maxDepth = opts.depth;\r\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n    this._wantsEverything = type === EVERYTHING_TYPE;\r\n    this._root = sysPath.resolve(root);\r\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\r\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\r\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\r\n\r\n    // Launch stream with one parent, the root dir.\r\n    this.parents = [this._exploreDir(root, 1)];\r\n    this.reading = false;\r\n    this.parent = undefined;\r\n  }\r\n\r\n  async _read(batch) {\r\n    if (this.reading) return;\r\n    this.reading = true;\r\n\r\n    try {\r\n      while (!this.destroyed && batch > 0) {\r\n        const { path, depth, files = [] } = this.parent || {};\r\n\r\n        if (files.length > 0) {\r\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\r\n          for (const entry of await Promise.all(slice)) {\r\n            if (this.destroyed) return;\r\n\r\n            const entryType = await this._getEntryType(entry);\r\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\r\n              if (depth <= this._maxDepth) {\r\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\r\n              }\r\n\r\n              if (this._wantsDir) {\r\n                this.push(entry);\r\n                batch--;\r\n              }\r\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\r\n              if (this._wantsFile) {\r\n                this.push(entry);\r\n                batch--;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          const parent = this.parents.pop();\r\n          if (!parent) {\r\n            this.push(null);\r\n            break;\r\n          }\r\n          this.parent = await parent;\r\n          if (this.destroyed) return;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.destroy(error);\r\n    } finally {\r\n      this.reading = false;\r\n    }\r\n  }\r\n\r\n  async _exploreDir(path, depth) {\r\n    let files;\r\n    try {\r\n      files = await readdir(path, this._rdOptions);\r\n    } catch (error) {\r\n      this._onError(error);\r\n    }\r\n    return {files, depth, path};\r\n  }\r\n\r\n  async _formatEntry(dirent, path) {\r\n    let entry;\r\n    try {\r\n      const basename = this._isDirent ? dirent.name : dirent;\r\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\r\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\r\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\r\n    } catch (err) {\r\n      this._onError(err);\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  _onError(err) {\r\n    if (isNormalFlowError(err) && !this.destroyed) {\r\n      this.emit('warn', err);\r\n    } else {\r\n      this.destroy(err);\r\n    }\r\n  }\r\n\r\n  async _getEntryType(entry) {\r\n    // entry may be undefined, because a warning or an error were emitted\r\n    // and the statsProp is undefined\r\n    const stats = entry && entry[this._statsProp];\r\n    if (!stats) {\r\n      return;\r\n    }\r\n    if (stats.isFile()) {\r\n      return 'file';\r\n    }\r\n    if (stats.isDirectory()) {\r\n      return 'directory';\r\n    }\r\n    if (stats && stats.isSymbolicLink()) {\r\n      const full = entry.fullPath;\r\n      try {\r\n        const entryRealPath = await realpath(full);\r\n        const entryRealPathStats = await lstat(entryRealPath);\r\n        if (entryRealPathStats.isFile()) {\r\n          return 'file';\r\n        }\r\n        if (entryRealPathStats.isDirectory()) {\r\n          const len = entryRealPath.length;\r\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\r\n            return this._onError(new Error(\r\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\r\n            ));\r\n          }\r\n          return 'directory';\r\n        }\r\n      } catch (error) {\r\n        this._onError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  _includeAsFile(entry) {\r\n    const stats = entry && entry[this._statsProp];\r\n\r\n    return stats && this._wantsEverything && !stats.isDirectory();\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} ReaddirpArguments\r\n * @property {Function=} fileFilter\r\n * @property {Function=} directoryFilter\r\n * @property {String=} type\r\n * @property {Number=} depth\r\n * @property {String=} root\r\n * @property {Boolean=} lstat\r\n * @property {Boolean=} bigint\r\n */\r\n\r\n/**\r\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\r\n * @param {String} root Root directory\r\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\r\n */\r\nconst readdirp = (root, options = {}) => {\r\n  let type = options.entryType || options.type;\r\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\r\n  if (type) options.type = type;\r\n  if (!root) {\r\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\r\n  } else if (typeof root !== 'string') {\r\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\r\n  } else if (type && !ALL_TYPES.includes(type)) {\r\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\r\n  }\r\n\r\n  options.root = root;\r\n  return new ReaddirpStream(options);\r\n};\r\n\r\nconst readdirpPromise = (root, options = {}) => {\r\n  return new Promise((resolve, reject) => {\r\n    const files = [];\r\n    readdirp(root, options)\r\n      .on('data', entry => files.push(entry))\r\n      .on('end', () => resolve(files))\r\n      .on('error', error => reject(error));\r\n  });\r\n};\r\n\r\nreaddirp.promise = readdirpPromise;\r\nreaddirp.ReaddirpStream = ReaddirpStream;\r\nreaddirp.default = readdirp;\r\n\r\nmodule.exports = readdirp;\r\n"]},"metadata":{},"sourceType":"script"}