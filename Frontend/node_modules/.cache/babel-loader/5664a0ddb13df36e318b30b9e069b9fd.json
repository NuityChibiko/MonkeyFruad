{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst isBinaryPath = require('is-binary-path');\n\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\nconst statMethods = {\n  lstat,\n  stat\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n/**\r\n * @typedef {String} Path\r\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\r\n * @typedef {Object} FsWatchContainer\r\n * @property {Set} listeners\r\n * @property {Set} errHandlers\r\n * @property {Set} rawEmitters\r\n * @property {fs.FSWatcher=} watcher\r\n * @property {Boolean=} watcherUnusable\r\n */\n\n/**\r\n * @type {Map<String,FsWatchContainer>}\r\n */\n\n\nconst FsWatchInstances = new Map();\n/**\r\n * Instantiates the fs_watch interface\r\n * @param {String} path to be watched\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Function} listener main event handler\r\n * @param {Function} errHandler emits info about errors\r\n * @param {Function} emitRaw emits raw event data\r\n * @returns {fs.FSWatcher} new fsevents instance\r\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\r\n * Helper for passing fs_watch event data to a collection of listeners\r\n * @param {Path} fullPath absolute path bound to fs_watch instance\r\n * @param {String} type listener type\r\n * @param {*=} val1 arguments to be passed to listeners\r\n * @param {*=} val2\r\n * @param {*=} val3\r\n */\n\n\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n/**\r\n * Instantiates the fs_watch interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Object} handlers container for event listener functions\r\n */\n\n\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  let watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nconst FsWatchFileInstances = new Map();\n/**\r\n * Instantiates the fs_watchFile interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path to be watched\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options options to be passed to fs_watchFile\r\n * @param {Object} handlers container for event listener functions\r\n * @returns {Function} closer\r\n */\n\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n\n  let listeners = new Set();\n  let rawEmitters = new Set();\n  const copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\r\n * @mixin\r\n */\n\n\nclass NodeFsHandler {\n  /**\r\n   * @param {import(\"../index\").FSWatcher} fsW\r\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n  /**\r\n   * Watch file for changes with fs_watchFile or fs_watch.\r\n   * @param {String} path to file or dir\r\n   * @param {Function} listener on fs change\r\n   * @returns {Function} closer for the watcher instance\r\n   */\n\n\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath.dirname(path);\n    const basename = sysPath.basename(path);\n\n    const parent = this.fsw._getWatchedDir(directory);\n\n    parent.add(basename);\n    const absolutePath = sysPath.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN;\n    let closer;\n\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n\n    return closer;\n  }\n  /**\r\n   * Watch a file and emit add event if warranted.\r\n   * @param {Path} file Path\r\n   * @param {fs.Stats} stats result of fs_stat\r\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n   * @returns {Function} closer for the watcher instance\r\n   */\n\n\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const dirname = sysPath.dirname(file);\n    const basename = sysPath.basename(file);\n\n    const parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n    let prevStats = stats; // if the file is already being watched, do nothing\n\n    if (parent.has(basename)) return;\n\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat(file);\n          if (this.fsw.closed) return; // Check that change event was not fired because of changed only accessTime.\n\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE, file, newStats);\n          }\n\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n\n            prevStats = newStats;\n\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        } // add is about to be emitted if file not already tracked in parent\n\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n\n        prevStats = newStats;\n      }\n    }; // kick off the watcher\n\n\n    const closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n\n      this.fsw._emit(EV_ADD, file, stats);\n    }\n\n    return closer;\n  }\n  /**\r\n   * Handle symlinks encountered while reading a dir.\r\n   * @param {Object} entry returned by readdirp\r\n   * @param {String} directory path of dir being read\r\n   * @param {String} path of this item\r\n   * @param {String} item basename of this item\r\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\r\n   */\n\n\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const full = entry.fullPath;\n\n    const dir = this.fsw._getWatchedDir(directory);\n\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n\n      const linkPath = await fsrealpath(path);\n      if (this.fsw.closed) return;\n\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n\n          this.fsw._emit(EV_CHANGE, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n\n        this.fsw._symlinkPaths.set(full, linkPath);\n\n        this.fsw._emit(EV_ADD, path, entry.stats);\n      }\n\n      this.fsw._emitReady();\n\n      return true;\n    } // don't follow the same symlink more than once\n\n\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n\n    this.fsw._symlinkPaths.set(full, true);\n  }\n\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, EMPTY_STR);\n\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    const previous = this.fsw._getWatchedDir(wh.path);\n\n    const current = new Set();\n\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const item = entry.path;\n      let path = sysPath.join(directory, item);\n      current.add(item);\n\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      } // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR, this._boundHandleError);\n\n    return new Promise(resolve => stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n  /**\r\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\r\n   * @param {String} dir fs path\r\n   * @param {fs.Stats} stats\r\n   * @param {Boolean} initialAdd\r\n   * @param {Number} depth relative to user-supplied path\r\n   * @param {String} target child path targeted for watch\r\n   * @param {Object} wh Common watch helpers for this path\r\n   * @param {String} realpath\r\n   * @returns {Promise<Function>} closer for the watcher instance.\r\n   */\n\n\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n\n    const tracked = parentDir.has(sysPath.basename(dir));\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n    } // ensure dir is tracked (harmless if redundant)\n\n\n    parentDir.add(sysPath.basename(dir));\n\n    this.fsw._getWatchedDir(dir);\n\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n\n    return closer;\n  }\n  /**\r\n   * Handle added file, directory, or glob pattern.\r\n   * Delegates call to _handleFile / _handleDir after checks.\r\n   * @param {String} path to file or ir\r\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n   * @param {Object} priorWh depth relative to user-supplied path\r\n   * @param {Number} depth Child path actually targeted for watch\r\n   * @param {String=} target Child path actually targeted for watch\r\n   * @returns {Promise}\r\n   */\n\n\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n\n    const wh = this.fsw._getWatchHelpers(path, depth);\n\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n\n      wh.filterPath = entry => priorWh.filterPath(entry);\n\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    } // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n      let closer;\n\n      if (stats.isDirectory()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (path !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(targetPath, true);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath.dirname(wh.watchPath);\n\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n        this.fsw._emit(EV_ADD, wh.watchPath, stats);\n\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n\n      ready();\n\n      this.fsw._addPathCloser(path, closer);\n\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n\n}\n\nmodule.exports = NodeFsHandler;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Frontend/node_modules/chokidar/lib/nodefs-handler.js"],"names":["fs","require","sysPath","promisify","isBinaryPath","isWindows","isLinux","EMPTY_FN","EMPTY_STR","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","EV_CHANGE","EV_ADD","EV_ADD_DIR","EV_ERROR","STR_DATA","STR_END","BRACE_START","STAR","THROTTLE_MODE_WATCH","open","stat","lstat","close","fsrealpath","realpath","statMethods","foreach","val","fn","Set","forEach","addAndConvert","main","prop","item","container","add","clearItem","cont","key","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","on","broadcastErr","watcherUnusable","code","fd","err","listeners","errHandlers","rawEmitters","undefined","Object","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","prev","currmtime","mtimeMs","NodeFsHandler","constructor","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","opts","directory","dirname","basename","parent","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","stats","initialAdd","closed","prevStats","has","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","entry","full","dir","followSymlinks","_incrReadyCount","linkPath","_symlinkPaths","_emitReady","_handleRead","wh","target","depth","throttler","hasGlob","previous","current","stream","_readdirp","fileFilter","filterPath","directoryFilter","filterDir","isSymbolicLink","relative","_addToNodeFs","Promise","once","wasThrottled","getChildren","filter","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","statMethod","watchPath","follow","includes","isDirectory","targetPath","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst sysPath = require('path');\r\nconst { promisify } = require('util');\r\nconst isBinaryPath = require('is-binary-path');\r\nconst {\r\n  isWindows,\r\n  isLinux,\r\n  EMPTY_FN,\r\n  EMPTY_STR,\r\n  KEY_LISTENERS,\r\n  KEY_ERR,\r\n  KEY_RAW,\r\n  HANDLER_KEYS,\r\n  EV_CHANGE,\r\n  EV_ADD,\r\n  EV_ADD_DIR,\r\n  EV_ERROR,\r\n  STR_DATA,\r\n  STR_END,\r\n  BRACE_START,\r\n  STAR\r\n} = require('./constants');\r\n\r\nconst THROTTLE_MODE_WATCH = 'watch';\r\n\r\nconst open = promisify(fs.open);\r\nconst stat = promisify(fs.stat);\r\nconst lstat = promisify(fs.lstat);\r\nconst close = promisify(fs.close);\r\nconst fsrealpath = promisify(fs.realpath);\r\n\r\nconst statMethods = { lstat, stat };\r\n\r\n// TODO: emit errors properly. Example: EMFILE on Macos.\r\nconst foreach = (val, fn) => {\r\n  if (val instanceof Set) {\r\n    val.forEach(fn);\r\n  } else {\r\n    fn(val);\r\n  }\r\n};\r\n\r\nconst addAndConvert = (main, prop, item) => {\r\n  let container = main[prop];\r\n  if (!(container instanceof Set)) {\r\n    main[prop] = container = new Set([container]);\r\n  }\r\n  container.add(item);\r\n};\r\n\r\nconst clearItem = cont => key => {\r\n  const set = cont[key];\r\n  if (set instanceof Set) {\r\n    set.clear();\r\n  } else {\r\n    delete cont[key];\r\n  }\r\n};\r\n\r\nconst delFromSet = (main, prop, item) => {\r\n  const container = main[prop];\r\n  if (container instanceof Set) {\r\n    container.delete(item);\r\n  } else if (container === item) {\r\n    delete main[prop];\r\n  }\r\n};\r\n\r\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\r\n\r\n/**\r\n * @typedef {String} Path\r\n */\r\n\r\n// fs_watch helpers\r\n\r\n// object to hold per-process fs_watch instances\r\n// (may be shared across chokidar FSWatcher instances)\r\n\r\n/**\r\n * @typedef {Object} FsWatchContainer\r\n * @property {Set} listeners\r\n * @property {Set} errHandlers\r\n * @property {Set} rawEmitters\r\n * @property {fs.FSWatcher=} watcher\r\n * @property {Boolean=} watcherUnusable\r\n */\r\n\r\n/**\r\n * @type {Map<String,FsWatchContainer>}\r\n */\r\nconst FsWatchInstances = new Map();\r\n\r\n/**\r\n * Instantiates the fs_watch interface\r\n * @param {String} path to be watched\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Function} listener main event handler\r\n * @param {Function} errHandler emits info about errors\r\n * @param {Function} emitRaw emits raw event data\r\n * @returns {fs.FSWatcher} new fsevents instance\r\n */\r\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\r\n  const handleEvent = (rawEvent, evPath) => {\r\n    listener(path);\r\n    emitRaw(rawEvent, evPath, {watchedPath: path});\r\n\r\n    // emit based on events occurring for files from a directory's watcher in\r\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\r\n    if (evPath && path !== evPath) {\r\n      fsWatchBroadcast(\r\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\r\n      );\r\n    }\r\n  };\r\n  try {\r\n    return fs.watch(path, options, handleEvent);\r\n  } catch (error) {\r\n    errHandler(error);\r\n  }\r\n}\r\n\r\n/**\r\n * Helper for passing fs_watch event data to a collection of listeners\r\n * @param {Path} fullPath absolute path bound to fs_watch instance\r\n * @param {String} type listener type\r\n * @param {*=} val1 arguments to be passed to listeners\r\n * @param {*=} val2\r\n * @param {*=} val3\r\n */\r\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\r\n  const cont = FsWatchInstances.get(fullPath);\r\n  if (!cont) return;\r\n  foreach(cont[type], (listener) => {\r\n    listener(val1, val2, val3);\r\n  });\r\n};\r\n\r\n/**\r\n * Instantiates the fs_watch interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options to be passed to fs_watch\r\n * @param {Object} handlers container for event listener functions\r\n */\r\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\r\n  const {listener, errHandler, rawEmitter} = handlers;\r\n  let cont = FsWatchInstances.get(fullPath);\r\n\r\n  /** @type {fs.FSWatcher=} */\r\n  let watcher;\r\n  if (!options.persistent) {\r\n    watcher = createFsWatchInstance(\r\n      path, options, listener, errHandler, rawEmitter\r\n    );\r\n    return watcher.close.bind(watcher);\r\n  }\r\n  if (cont) {\r\n    addAndConvert(cont, KEY_LISTENERS, listener);\r\n    addAndConvert(cont, KEY_ERR, errHandler);\r\n    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n  } else {\r\n    watcher = createFsWatchInstance(\r\n      path,\r\n      options,\r\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\r\n      errHandler, // no need to use broadcast here\r\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\r\n    );\r\n    if (!watcher) return;\r\n    watcher.on(EV_ERROR, async (error) => {\r\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\r\n      cont.watcherUnusable = true; // documented since Node 10.4.1\r\n      // Workaround for https://github.com/joyent/node/issues/4337\r\n      if (isWindows && error.code === 'EPERM') {\r\n        try {\r\n          const fd = await open(path, 'r');\r\n          await close(fd);\r\n          broadcastErr(error);\r\n        } catch (err) {}\r\n      } else {\r\n        broadcastErr(error);\r\n      }\r\n    });\r\n    cont = {\r\n      listeners: listener,\r\n      errHandlers: errHandler,\r\n      rawEmitters: rawEmitter,\r\n      watcher\r\n    };\r\n    FsWatchInstances.set(fullPath, cont);\r\n  }\r\n  // const index = cont.listeners.indexOf(listener);\r\n\r\n  // removes this instance's listeners and closes the underlying fs_watch\r\n  // instance if there are no more listeners left\r\n  return () => {\r\n    delFromSet(cont, KEY_LISTENERS, listener);\r\n    delFromSet(cont, KEY_ERR, errHandler);\r\n    delFromSet(cont, KEY_RAW, rawEmitter);\r\n    if (isEmptySet(cont.listeners)) {\r\n      // Check to protect against issue gh-730.\r\n      // if (cont.watcherUnusable) {\r\n      cont.watcher.close();\r\n      // }\r\n      FsWatchInstances.delete(fullPath);\r\n      HANDLER_KEYS.forEach(clearItem(cont));\r\n      cont.watcher = undefined;\r\n      Object.freeze(cont);\r\n    }\r\n  };\r\n};\r\n\r\n// fs_watchFile helpers\r\n\r\n// object to hold per-process fs_watchFile instances\r\n// (may be shared across chokidar FSWatcher instances)\r\nconst FsWatchFileInstances = new Map();\r\n\r\n/**\r\n * Instantiates the fs_watchFile interface or binds listeners\r\n * to an existing one covering the same file system entry\r\n * @param {String} path to be watched\r\n * @param {String} fullPath absolute path\r\n * @param {Object} options options to be passed to fs_watchFile\r\n * @param {Object} handlers container for event listener functions\r\n * @returns {Function} closer\r\n */\r\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\r\n  const {listener, rawEmitter} = handlers;\r\n  let cont = FsWatchFileInstances.get(fullPath);\r\n\r\n  /* eslint-disable no-unused-vars, prefer-destructuring */\r\n  let listeners = new Set();\r\n  let rawEmitters = new Set();\r\n\r\n  const copts = cont && cont.options;\r\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\r\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\r\n    // This creates some unlikely edge case issues if the user mixes\r\n    // settings in a very weird way, but solving for those cases\r\n    // doesn't seem worthwhile for the added complexity.\r\n    listeners = cont.listeners;\r\n    rawEmitters = cont.rawEmitters;\r\n    fs.unwatchFile(fullPath);\r\n    cont = undefined;\r\n  }\r\n\r\n  /* eslint-enable no-unused-vars, prefer-destructuring */\r\n\r\n  if (cont) {\r\n    addAndConvert(cont, KEY_LISTENERS, listener);\r\n    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n  } else {\r\n    // TODO\r\n    // listeners.add(listener);\r\n    // rawEmitters.add(rawEmitter);\r\n    cont = {\r\n      listeners: listener,\r\n      rawEmitters: rawEmitter,\r\n      options,\r\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\r\n        foreach(cont.rawEmitters, (rawEmitter) => {\r\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\r\n        });\r\n        const currmtime = curr.mtimeMs;\r\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\r\n          foreach(cont.listeners, (listener) => listener(path, curr));\r\n        }\r\n      })\r\n    };\r\n    FsWatchFileInstances.set(fullPath, cont);\r\n  }\r\n  // const index = cont.listeners.indexOf(listener);\r\n\r\n  // Removes this instance's listeners and closes the underlying fs_watchFile\r\n  // instance if there are no more listeners left.\r\n  return () => {\r\n    delFromSet(cont, KEY_LISTENERS, listener);\r\n    delFromSet(cont, KEY_RAW, rawEmitter);\r\n    if (isEmptySet(cont.listeners)) {\r\n      FsWatchFileInstances.delete(fullPath);\r\n      fs.unwatchFile(fullPath);\r\n      cont.options = cont.watcher = undefined;\r\n      Object.freeze(cont);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * @mixin\r\n */\r\nclass NodeFsHandler {\r\n\r\n/**\r\n * @param {import(\"../index\").FSWatcher} fsW\r\n */\r\nconstructor(fsW) {\r\n  this.fsw = fsW;\r\n  this._boundHandleError = (error) => fsW._handleError(error);\r\n}\r\n\r\n/**\r\n * Watch file for changes with fs_watchFile or fs_watch.\r\n * @param {String} path to file or dir\r\n * @param {Function} listener on fs change\r\n * @returns {Function} closer for the watcher instance\r\n */\r\n_watchWithNodeFs(path, listener) {\r\n  const opts = this.fsw.options;\r\n  const directory = sysPath.dirname(path);\r\n  const basename = sysPath.basename(path);\r\n  const parent = this.fsw._getWatchedDir(directory);\r\n  parent.add(basename);\r\n  const absolutePath = sysPath.resolve(path);\r\n  const options = {persistent: opts.persistent};\r\n  if (!listener) listener = EMPTY_FN;\r\n\r\n  let closer;\r\n  if (opts.usePolling) {\r\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\r\n      opts.binaryInterval : opts.interval;\r\n    closer = setFsWatchFileListener(path, absolutePath, options, {\r\n      listener,\r\n      rawEmitter: this.fsw._emitRaw\r\n    });\r\n  } else {\r\n    closer = setFsWatchListener(path, absolutePath, options, {\r\n      listener,\r\n      errHandler: this._boundHandleError,\r\n      rawEmitter: this.fsw._emitRaw\r\n    });\r\n  }\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Watch a file and emit add event if warranted.\r\n * @param {Path} file Path\r\n * @param {fs.Stats} stats result of fs_stat\r\n * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n * @returns {Function} closer for the watcher instance\r\n */\r\n_handleFile(file, stats, initialAdd) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const dirname = sysPath.dirname(file);\r\n  const basename = sysPath.basename(file);\r\n  const parent = this.fsw._getWatchedDir(dirname);\r\n  // stats is always present\r\n  let prevStats = stats;\r\n\r\n  // if the file is already being watched, do nothing\r\n  if (parent.has(basename)) return;\r\n\r\n  const listener = async (path, newStats) => {\r\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\r\n    if (!newStats || newStats.mtimeMs === 0) {\r\n      try {\r\n        const newStats = await stat(file);\r\n        if (this.fsw.closed) return;\r\n        // Check that change event was not fired because of changed only accessTime.\r\n        const at = newStats.atimeMs;\r\n        const mt = newStats.mtimeMs;\r\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n          this.fsw._emit(EV_CHANGE, file, newStats);\r\n        }\r\n        if (isLinux && prevStats.ino !== newStats.ino) {\r\n          this.fsw._closeFile(path)\r\n          prevStats = newStats;\r\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\r\n        } else {\r\n          prevStats = newStats;\r\n        }\r\n      } catch (error) {\r\n        // Fix issues where mtime is null but file is still present\r\n        this.fsw._remove(dirname, basename);\r\n      }\r\n      // add is about to be emitted if file not already tracked in parent\r\n    } else if (parent.has(basename)) {\r\n      // Check that change event was not fired because of changed only accessTime.\r\n      const at = newStats.atimeMs;\r\n      const mt = newStats.mtimeMs;\r\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n        this.fsw._emit(EV_CHANGE, file, newStats);\r\n      }\r\n      prevStats = newStats;\r\n    }\r\n  }\r\n  // kick off the watcher\r\n  const closer = this._watchWithNodeFs(file, listener);\r\n\r\n  // emit an add event if we're supposed to\r\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\r\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\r\n    this.fsw._emit(EV_ADD, file, stats);\r\n  }\r\n\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle symlinks encountered while reading a dir.\r\n * @param {Object} entry returned by readdirp\r\n * @param {String} directory path of dir being read\r\n * @param {String} path of this item\r\n * @param {String} item basename of this item\r\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\r\n */\r\nasync _handleSymlink(entry, directory, path, item) {\r\n  if (this.fsw.closed) {\r\n    return;\r\n  }\r\n  const full = entry.fullPath;\r\n  const dir = this.fsw._getWatchedDir(directory);\r\n\r\n  if (!this.fsw.options.followSymlinks) {\r\n    // watch symlink directly (don't follow) and detect changes\r\n    this.fsw._incrReadyCount();\r\n    const linkPath = await fsrealpath(path);\r\n    if (this.fsw.closed) return;\r\n    if (dir.has(item)) {\r\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\r\n        this.fsw._symlinkPaths.set(full, linkPath);\r\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\r\n      }\r\n    } else {\r\n      dir.add(item);\r\n      this.fsw._symlinkPaths.set(full, linkPath);\r\n      this.fsw._emit(EV_ADD, path, entry.stats);\r\n    }\r\n    this.fsw._emitReady();\r\n    return true;\r\n  }\r\n\r\n  // don't follow the same symlink more than once\r\n  if (this.fsw._symlinkPaths.has(full)) {\r\n    return true;\r\n  }\r\n\r\n  this.fsw._symlinkPaths.set(full, true);\r\n}\r\n\r\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\r\n  // Normalize the directory name on Windows\r\n  directory = sysPath.join(directory, EMPTY_STR);\r\n\r\n  if (!wh.hasGlob) {\r\n    throttler = this.fsw._throttle('readdir', directory, 1000);\r\n    if (!throttler) return;\r\n  }\r\n\r\n  const previous = this.fsw._getWatchedDir(wh.path);\r\n  const current = new Set();\r\n\r\n  let stream = this.fsw._readdirp(directory, {\r\n    fileFilter: entry => wh.filterPath(entry),\r\n    directoryFilter: entry => wh.filterDir(entry),\r\n    depth: 0\r\n  }).on(STR_DATA, async (entry) => {\r\n    if (this.fsw.closed) {\r\n      stream = undefined;\r\n      return;\r\n    }\r\n    const item = entry.path;\r\n    let path = sysPath.join(directory, item);\r\n    current.add(item);\r\n\r\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\r\n      return;\r\n    }\r\n\r\n    if (this.fsw.closed) {\r\n      stream = undefined;\r\n      return;\r\n    }\r\n    // Files that present in current directory snapshot\r\n    // but absent in previous are added to watch list and\r\n    // emit `add` event.\r\n    if (item === target || !target && !previous.has(item)) {\r\n      this.fsw._incrReadyCount();\r\n\r\n      // ensure relativeness of path is preserved in case of watcher reuse\r\n      path = sysPath.join(dir, sysPath.relative(dir, path));\r\n\r\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\r\n    }\r\n  }).on(EV_ERROR, this._boundHandleError);\r\n\r\n  return new Promise(resolve =>\r\n    stream.once(STR_END, () => {\r\n      if (this.fsw.closed) {\r\n        stream = undefined;\r\n        return;\r\n      }\r\n      const wasThrottled = throttler ? throttler.clear() : false;\r\n\r\n      resolve();\r\n\r\n      // Files that absent in current directory snapshot\r\n      // but present in previous emit `remove` event\r\n      // and are removed from @watched[directory].\r\n      previous.getChildren().filter((item) => {\r\n        return item !== directory &&\r\n          !current.has(item) &&\r\n          // in case of intersecting globs;\r\n          // a path may have been filtered out of this readdir, but\r\n          // shouldn't be removed because it matches a different glob\r\n          (!wh.hasGlob || wh.filterPath({\r\n            fullPath: sysPath.resolve(directory, item)\r\n          }));\r\n      }).forEach((item) => {\r\n        this.fsw._remove(directory, item);\r\n      });\r\n\r\n      stream = undefined;\r\n\r\n      // one more time for any missed in case changes came in extremely quickly\r\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * Read directory to add / remove files from `@watched` list and re-read it on change.\r\n * @param {String} dir fs path\r\n * @param {fs.Stats} stats\r\n * @param {Boolean} initialAdd\r\n * @param {Number} depth relative to user-supplied path\r\n * @param {String} target child path targeted for watch\r\n * @param {Object} wh Common watch helpers for this path\r\n * @param {String} realpath\r\n * @returns {Promise<Function>} closer for the watcher instance.\r\n */\r\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\r\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\r\n  const tracked = parentDir.has(sysPath.basename(dir));\r\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\r\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\r\n  }\r\n\r\n  // ensure dir is tracked (harmless if redundant)\r\n  parentDir.add(sysPath.basename(dir));\r\n  this.fsw._getWatchedDir(dir);\r\n  let throttler;\r\n  let closer;\r\n\r\n  const oDepth = this.fsw.options.depth;\r\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\r\n    if (!target) {\r\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\r\n      if (this.fsw.closed) return;\r\n    }\r\n\r\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\r\n      // if current directory is removed, do nothing\r\n      if (stats && stats.mtimeMs === 0) return;\r\n\r\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\r\n    });\r\n  }\r\n  return closer;\r\n}\r\n\r\n/**\r\n * Handle added file, directory, or glob pattern.\r\n * Delegates call to _handleFile / _handleDir after checks.\r\n * @param {String} path to file or ir\r\n * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n * @param {Object} priorWh depth relative to user-supplied path\r\n * @param {Number} depth Child path actually targeted for watch\r\n * @param {String=} target Child path actually targeted for watch\r\n * @returns {Promise}\r\n */\r\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\r\n  const ready = this.fsw._emitReady;\r\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\r\n    ready();\r\n    return false;\r\n  }\r\n\r\n  const wh = this.fsw._getWatchHelpers(path, depth);\r\n  if (!wh.hasGlob && priorWh) {\r\n    wh.hasGlob = priorWh.hasGlob;\r\n    wh.globFilter = priorWh.globFilter;\r\n    wh.filterPath = entry => priorWh.filterPath(entry);\r\n    wh.filterDir = entry => priorWh.filterDir(entry);\r\n  }\r\n\r\n  // evaluate what is at the path we're being asked to watch\r\n  try {\r\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n    if (this.fsw.closed) return;\r\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n      ready();\r\n      return false;\r\n    }\r\n\r\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\r\n    let closer;\r\n    if (stats.isDirectory()) {\r\n      const targetPath = follow ? await fsrealpath(path) : path;\r\n      if (this.fsw.closed) return;\r\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\r\n      if (this.fsw.closed) return;\r\n      // preserve this symlink's target path\r\n      if (path !== targetPath && targetPath !== undefined) {\r\n        this.fsw._symlinkPaths.set(targetPath, true);\r\n      }\r\n    } else if (stats.isSymbolicLink()) {\r\n      const targetPath = follow ? await fsrealpath(path) : path;\r\n      if (this.fsw.closed) return;\r\n      const parent = sysPath.dirname(wh.watchPath);\r\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\r\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\r\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\r\n      if (this.fsw.closed) return;\r\n\r\n      // preserve this symlink's target path\r\n      if (targetPath !== undefined) {\r\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\r\n      }\r\n    } else {\r\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\r\n    }\r\n    ready();\r\n\r\n    this.fsw._addPathCloser(path, closer);\r\n    return false;\r\n\r\n  } catch (error) {\r\n    if (this.fsw._handleError(error)) {\r\n      ready();\r\n      return path;\r\n    }\r\n  }\r\n}\r\n\r\n}\r\n\r\nmodule.exports = NodeFsHandler;\r\n"]},"metadata":{},"sourceType":"script"}