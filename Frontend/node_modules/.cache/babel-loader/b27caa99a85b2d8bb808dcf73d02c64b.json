{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst query_partition_1 = require(\"./query-partition\");\n\nconst util_1 = require(\"./util\");\n\nconst logger_1 = require(\"./logger\");\n\nconst reference_1 = require(\"./reference\");\n\nconst path_1 = require(\"./path\");\n\nconst validate_1 = require(\"./validate\");\n/**\r\n * A `CollectionGroup` refers to all documents that are contained in a\r\n * collection or subcollection with a specific collection ID.\r\n *\r\n * @class CollectionGroup\r\n */\n\n\nclass CollectionGroup extends reference_1.Query {\n  /** @hideconstructor */\n  constructor(firestore, collectionId, converter) {\n    super(firestore, reference_1.QueryOptions.forCollectionGroupQuery(collectionId, converter));\n  }\n  /**\r\n   * Partitions a query by returning partition cursors that can be used to run\r\n   * the query in parallel. The returned cursors are split points that can be\r\n   * used as starting and end points for individual query invocations.\r\n   *\r\n   * @example\r\n   * const query = firestore.collectionGroup('collectionId');\r\n   * for await (const partition of query.getPartitions(42)) {\r\n   *   const partitionedQuery = partition.toQuery();\r\n   *   const querySnapshot = await partitionedQuery.get();\r\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n   * }\r\n   *\r\n   * @param {number} desiredPartitionCount The desired maximum number of\r\n   * partition points. The number must be strictly positive. The actual number\r\n   * of partitions returned may be fewer.\r\n   * @return {AsyncIterable<QueryPartition>} An AsyncIterable of\r\n   * `QueryPartition`s.\r\n   */\n\n\n  async *getPartitions(desiredPartitionCount) {\n    var _a;\n\n    validate_1.validateInteger('desiredPartitionCount', desiredPartitionCount, {\n      minValue: 1\n    });\n    const tag = util_1.requestTag();\n    await this.firestore.initializeIfNeeded(tag);\n    let lastValues = undefined;\n    let partitionCount = 0;\n\n    if (desiredPartitionCount > 1) {\n      // Partition queries require explicit ordering by __name__.\n      const queryWithDefaultOrder = this.orderBy(path_1.FieldPath.documentId());\n      const request = queryWithDefaultOrder.toProto(); // Since we are always returning an extra partition (with an empty endBefore\n      // cursor), we reduce the desired partition count by one.\n\n      request.partitionCount = desiredPartitionCount - 1;\n      const stream = await this.firestore.requestStream('partitionQueryStream', request, tag);\n      stream.resume();\n\n      for await (const currentCursor of stream) {\n        ++partitionCount;\n        const currentValues = (_a = currentCursor.values) !== null && _a !== void 0 ? _a : [];\n        yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, lastValues, currentValues);\n        lastValues = currentValues;\n      }\n    }\n\n    logger_1.logger('Firestore.getPartitions', tag, 'Received %d partitions', partitionCount); // Return the extra partition with the empty cursor.\n\n    yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, lastValues, undefined);\n  }\n  /**\r\n   * Applies a custom data converter to this `CollectionGroup`, allowing you\r\n   * to use your own custom model objects with Firestore. When you call get()\r\n   * on the returned `CollectionGroup`, the provided converter will convert\r\n   * between Firestore data and your custom type U.\r\n   *\r\n   * Using the converter allows you to specify generic type arguments when\r\n   * storing and retrieving objects from Firestore.\r\n   *\r\n   * @example\r\n   * class Post {\r\n   *   constructor(readonly title: string, readonly author: string) {}\r\n   *\r\n   *   toString(): string {\r\n   *     return this.title + ', by ' + this.author;\r\n   *   }\r\n   * }\r\n   *\r\n   * const postConverter = {\r\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n   *     return {title: post.title, author: post.author};\r\n   *   },\r\n   *   fromFirestore(\r\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n   *   ): Post {\r\n   *     const data = snapshot.data();\r\n   *     return new Post(data.title, data.author);\r\n   *   }\r\n   * };\r\n   *\r\n   * const querySnapshot = await Firestore()\r\n   *   .collectionGroup('posts')\r\n   *   .withConverter(postConverter)\r\n   *   .get();\r\n   * for (const doc of querySnapshot.docs) {\r\n   *   const post = doc.data();\r\n   *   post.title; // string\r\n   *   post.toString(); // Should be defined\r\n   *   post.someNonExistentProperty; // TS error\r\n   * }\r\n   *\r\n   * @param {FirestoreDataConverter} converter Converts objects to and from\r\n   * Firestore.\r\n   * @return {CollectionGroup} A `CollectionGroup<U>` that uses the provided\r\n   * converter.\r\n   */\n\n\n  withConverter(converter) {\n    return new CollectionGroup(this.firestore, this._queryOptions.collectionId, converter);\n  }\n\n}\n\nexports.CollectionGroup = CollectionGroup;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/firestore/build/src/collection-group.js"],"names":["Object","defineProperty","exports","value","query_partition_1","require","util_1","logger_1","reference_1","path_1","validate_1","CollectionGroup","Query","constructor","firestore","collectionId","converter","QueryOptions","forCollectionGroupQuery","getPartitions","desiredPartitionCount","_a","validateInteger","minValue","tag","requestTag","initializeIfNeeded","lastValues","undefined","partitionCount","queryWithDefaultOrder","orderBy","FieldPath","documentId","request","toProto","stream","requestStream","resume","currentCursor","currentValues","values","QueryPartition","_firestore","_queryOptions","logger","withConverter"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst query_partition_1 = require(\"./query-partition\");\r\nconst util_1 = require(\"./util\");\r\nconst logger_1 = require(\"./logger\");\r\nconst reference_1 = require(\"./reference\");\r\nconst path_1 = require(\"./path\");\r\nconst validate_1 = require(\"./validate\");\r\n/**\r\n * A `CollectionGroup` refers to all documents that are contained in a\r\n * collection or subcollection with a specific collection ID.\r\n *\r\n * @class CollectionGroup\r\n */\r\nclass CollectionGroup extends reference_1.Query {\r\n    /** @hideconstructor */\r\n    constructor(firestore, collectionId, converter) {\r\n        super(firestore, reference_1.QueryOptions.forCollectionGroupQuery(collectionId, converter));\r\n    }\r\n    /**\r\n     * Partitions a query by returning partition cursors that can be used to run\r\n     * the query in parallel. The returned cursors are split points that can be\r\n     * used as starting and end points for individual query invocations.\r\n     *\r\n     * @example\r\n     * const query = firestore.collectionGroup('collectionId');\r\n     * for await (const partition of query.getPartitions(42)) {\r\n     *   const partitionedQuery = partition.toQuery();\r\n     *   const querySnapshot = await partitionedQuery.get();\r\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\r\n     * }\r\n     *\r\n     * @param {number} desiredPartitionCount The desired maximum number of\r\n     * partition points. The number must be strictly positive. The actual number\r\n     * of partitions returned may be fewer.\r\n     * @return {AsyncIterable<QueryPartition>} An AsyncIterable of\r\n     * `QueryPartition`s.\r\n     */\r\n    async *getPartitions(desiredPartitionCount) {\r\n        var _a;\r\n        validate_1.validateInteger('desiredPartitionCount', desiredPartitionCount, {\r\n            minValue: 1,\r\n        });\r\n        const tag = util_1.requestTag();\r\n        await this.firestore.initializeIfNeeded(tag);\r\n        let lastValues = undefined;\r\n        let partitionCount = 0;\r\n        if (desiredPartitionCount > 1) {\r\n            // Partition queries require explicit ordering by __name__.\r\n            const queryWithDefaultOrder = this.orderBy(path_1.FieldPath.documentId());\r\n            const request = queryWithDefaultOrder.toProto();\r\n            // Since we are always returning an extra partition (with an empty endBefore\r\n            // cursor), we reduce the desired partition count by one.\r\n            request.partitionCount = desiredPartitionCount - 1;\r\n            const stream = await this.firestore.requestStream('partitionQueryStream', request, tag);\r\n            stream.resume();\r\n            for await (const currentCursor of stream) {\r\n                ++partitionCount;\r\n                const currentValues = (_a = currentCursor.values) !== null && _a !== void 0 ? _a : [];\r\n                yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, lastValues, currentValues);\r\n                lastValues = currentValues;\r\n            }\r\n        }\r\n        logger_1.logger('Firestore.getPartitions', tag, 'Received %d partitions', partitionCount);\r\n        // Return the extra partition with the empty cursor.\r\n        yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, lastValues, undefined);\r\n    }\r\n    /**\r\n     * Applies a custom data converter to this `CollectionGroup`, allowing you\r\n     * to use your own custom model objects with Firestore. When you call get()\r\n     * on the returned `CollectionGroup`, the provided converter will convert\r\n     * between Firestore data and your custom type U.\r\n     *\r\n     * Using the converter allows you to specify generic type arguments when\r\n     * storing and retrieving objects from Firestore.\r\n     *\r\n     * @example\r\n     * class Post {\r\n     *   constructor(readonly title: string, readonly author: string) {}\r\n     *\r\n     *   toString(): string {\r\n     *     return this.title + ', by ' + this.author;\r\n     *   }\r\n     * }\r\n     *\r\n     * const postConverter = {\r\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\r\n     *     return {title: post.title, author: post.author};\r\n     *   },\r\n     *   fromFirestore(\r\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\r\n     *   ): Post {\r\n     *     const data = snapshot.data();\r\n     *     return new Post(data.title, data.author);\r\n     *   }\r\n     * };\r\n     *\r\n     * const querySnapshot = await Firestore()\r\n     *   .collectionGroup('posts')\r\n     *   .withConverter(postConverter)\r\n     *   .get();\r\n     * for (const doc of querySnapshot.docs) {\r\n     *   const post = doc.data();\r\n     *   post.title; // string\r\n     *   post.toString(); // Should be defined\r\n     *   post.someNonExistentProperty; // TS error\r\n     * }\r\n     *\r\n     * @param {FirestoreDataConverter} converter Converts objects to and from\r\n     * Firestore.\r\n     * @return {CollectionGroup} A `CollectionGroup<U>` that uses the provided\r\n     * converter.\r\n     */\r\n    withConverter(converter) {\r\n        return new CollectionGroup(this.firestore, this._queryOptions.collectionId, converter);\r\n    }\r\n}\r\nexports.CollectionGroup = CollectionGroup;\r\n//# sourceMappingURL=collection-group.js.map"]},"metadata":{},"sourceType":"script"}