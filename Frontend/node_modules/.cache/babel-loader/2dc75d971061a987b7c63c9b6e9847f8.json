{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2015 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\r\n * @module common/paginator\r\n */\n\nconst arrify = require(\"arrify\");\n\nconst extend = require(\"extend\");\n\nconst resource_stream_1 = require(\"./resource-stream\");\n\nObject.defineProperty(exports, \"ResourceStream\", {\n  enumerable: true,\n  get: function () {\n    return resource_stream_1.ResourceStream;\n  }\n});\n/*! Developer Documentation\r\n *\r\n * paginator is used to auto-paginate `nextQuery` methods as well as\r\n * streamifying them.\r\n *\r\n * Before:\r\n *\r\n *   search.query('done=true', function(err, results, nextQuery) {\r\n *     search.query(nextQuery, function(err, results, nextQuery) {});\r\n *   });\r\n *\r\n * After:\r\n *\r\n *   search.query('done=true', function(err, results) {});\r\n *\r\n * Methods to extend should be written to accept callbacks and return a\r\n * `nextQuery`.\r\n */\n\nclass Paginator {\n  /**\r\n   * Cache the original method, then overwrite it on the Class's prototype.\r\n   *\r\n   * @param {function} Class - The parent class of the methods to extend.\r\n   * @param {string|string[]} methodNames - Name(s) of the methods to extend.\r\n   */\n  // tslint:disable-next-line:variable-name\n  extend(Class, methodNames) {\n    methodNames = arrify(methodNames);\n    methodNames.forEach(methodName => {\n      const originalMethod = Class.prototype[methodName]; // map the original method to a private member\n\n      Class.prototype[methodName + '_'] = originalMethod; // overwrite the original to auto-paginate\n\n      /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n      Class.prototype[methodName] = function (...args) {\n        const parsedArguments = paginator.parseArguments_(args);\n        return paginator.run_(parsedArguments, originalMethod.bind(this));\n      };\n    });\n  }\n  /**\r\n   * Wraps paginated API calls in a readable object stream.\r\n   *\r\n   * This method simply calls the nextQuery recursively, emitting results to a\r\n   * stream. The stream ends when `nextQuery` is null.\r\n   *\r\n   * `maxResults` will act as a cap for how many results are fetched and emitted\r\n   * to the stream.\r\n   *\r\n   * @param {string} methodName - Name of the method to streamify.\r\n   * @return {function} - Wrapped function.\r\n   */\n\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n\n  streamify(methodName) {\n    return function (\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    ...args) {\n      const parsedArguments = paginator.parseArguments_(args);\n      const originalMethod = this[methodName + '_'] || this[methodName];\n      return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n    };\n  }\n  /**\r\n   * Parse a pseudo-array `arguments` for a query and callback.\r\n   *\r\n   * @param {array} args - The original `arguments` pseduo-array that the original\r\n   *     method received.\r\n   */\n\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n\n  parseArguments_(args) {\n    let query;\n    let autoPaginate = true;\n    let maxApiCalls = -1;\n    let maxResults = -1;\n    let callback;\n    const firstArgument = args[0];\n    const lastArgument = args[args.length - 1];\n\n    if (typeof firstArgument === 'function') {\n      callback = firstArgument;\n    } else {\n      query = firstArgument;\n    }\n\n    if (typeof lastArgument === 'function') {\n      callback = lastArgument;\n    }\n\n    if (typeof query === 'object') {\n      query = extend(true, {}, query); // Check if the user only asked for a certain amount of results.\n\n      if (query.maxResults && typeof query.maxResults === 'number') {\n        // `maxResults` is used API-wide.\n        maxResults = query.maxResults;\n      } else if (typeof query.pageSize === 'number') {\n        // `pageSize` is Pub/Sub's `maxResults`.\n        maxResults = query.pageSize;\n      }\n\n      if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n        maxApiCalls = query.maxApiCalls;\n        delete query.maxApiCalls;\n      } // maxResults is the user specified limit.\n\n\n      if (maxResults !== -1 || query.autoPaginate === false) {\n        autoPaginate = false;\n      }\n    }\n\n    const parsedArguments = {\n      query: query || {},\n      autoPaginate,\n      maxApiCalls,\n      maxResults,\n      callback\n    };\n    parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n    delete parsedArguments.streamOptions.autoPaginate;\n    delete parsedArguments.streamOptions.maxResults;\n    delete parsedArguments.streamOptions.pageSize;\n    return parsedArguments;\n  }\n  /**\r\n   * This simply checks to see if `autoPaginate` is set or not, if it's true\r\n   * then we buffer all results, otherwise simply call the original method.\r\n   *\r\n   * @param {array} parsedArguments - Parsed arguments from the original method\r\n   *     call.\r\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\r\n   *     commonly an object, but to make the API more simple, it can also be a\r\n   *     string in some places.\r\n   * @param {function=} parsedArguments.callback - Callback function.\r\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\r\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\r\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\r\n   * @param {function} originalMethod - The cached method that accepts a callback\r\n   *     and returns `nextQuery` to receive more results.\r\n   */\n\n\n  run_(parsedArguments, originalMethod) {\n    const query = parsedArguments.query;\n    const callback = parsedArguments.callback;\n\n    if (!parsedArguments.autoPaginate) {\n      return originalMethod(query, callback);\n    }\n\n    const results = new Array();\n    const promise = new Promise((resolve, reject) => {\n      paginator.runAsStream_(parsedArguments, originalMethod).on('error', reject).on('data', data => results.push(data)).on('end', () => resolve(results));\n    });\n\n    if (!callback) {\n      return promise.then(results => [results]);\n    }\n\n    promise.then(results => callback(null, results), err => callback(err));\n  }\n  /**\r\n   * This method simply calls the nextQuery recursively, emitting results to a\r\n   * stream. The stream ends when `nextQuery` is null.\r\n   *\r\n   * `maxResults` will act as a cap for how many results are fetched and emitted\r\n   * to the stream.\r\n   *\r\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\r\n   *     commonly an object, but to make the API more simple, it can also be a\r\n   *     string in some places.\r\n   * @param {function=} parsedArguments.callback - Callback function.\r\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\r\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\r\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\r\n   * @param {function} originalMethod - The cached method that accepts a callback\r\n   *     and returns `nextQuery` to receive more results.\r\n   * @return {stream} - Readable object stream.\r\n   */\n\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n\n  runAsStream_(parsedArguments, originalMethod) {\n    return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n  }\n\n}\n\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;","map":{"version":3,"sources":["D:/PROJECT ALL/MonkeyFruad/Backend/node_modules/@google-cloud/paginator/build/src/index.js"],"names":["Object","defineProperty","exports","value","ResourceStream","paginator","Paginator","arrify","require","extend","resource_stream_1","enumerable","get","Class","methodNames","forEach","methodName","originalMethod","prototype","args","parsedArguments","parseArguments_","run_","bind","streamify","runAsStream_","query","autoPaginate","maxApiCalls","maxResults","callback","firstArgument","lastArgument","length","pageSize","streamOptions","results","Array","promise","Promise","resolve","reject","on","data","push","then","err"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2015 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\r\n/*!\r\n * @module common/paginator\r\n */\r\nconst arrify = require(\"arrify\");\r\nconst extend = require(\"extend\");\r\nconst resource_stream_1 = require(\"./resource-stream\");\r\nObject.defineProperty(exports, \"ResourceStream\", { enumerable: true, get: function () { return resource_stream_1.ResourceStream; } });\r\n/*! Developer Documentation\r\n *\r\n * paginator is used to auto-paginate `nextQuery` methods as well as\r\n * streamifying them.\r\n *\r\n * Before:\r\n *\r\n *   search.query('done=true', function(err, results, nextQuery) {\r\n *     search.query(nextQuery, function(err, results, nextQuery) {});\r\n *   });\r\n *\r\n * After:\r\n *\r\n *   search.query('done=true', function(err, results) {});\r\n *\r\n * Methods to extend should be written to accept callbacks and return a\r\n * `nextQuery`.\r\n */\r\nclass Paginator {\r\n    /**\r\n     * Cache the original method, then overwrite it on the Class's prototype.\r\n     *\r\n     * @param {function} Class - The parent class of the methods to extend.\r\n     * @param {string|string[]} methodNames - Name(s) of the methods to extend.\r\n     */\r\n    // tslint:disable-next-line:variable-name\r\n    extend(Class, methodNames) {\r\n        methodNames = arrify(methodNames);\r\n        methodNames.forEach(methodName => {\r\n            const originalMethod = Class.prototype[methodName];\r\n            // map the original method to a private member\r\n            Class.prototype[methodName + '_'] = originalMethod;\r\n            // overwrite the original to auto-paginate\r\n            /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n            Class.prototype[methodName] = function (...args) {\r\n                const parsedArguments = paginator.parseArguments_(args);\r\n                return paginator.run_(parsedArguments, originalMethod.bind(this));\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Wraps paginated API calls in a readable object stream.\r\n     *\r\n     * This method simply calls the nextQuery recursively, emitting results to a\r\n     * stream. The stream ends when `nextQuery` is null.\r\n     *\r\n     * `maxResults` will act as a cap for how many results are fetched and emitted\r\n     * to the stream.\r\n     *\r\n     * @param {string} methodName - Name of the method to streamify.\r\n     * @return {function} - Wrapped function.\r\n     */\r\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n    streamify(methodName) {\r\n        return function (\r\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n        ...args) {\r\n            const parsedArguments = paginator.parseArguments_(args);\r\n            const originalMethod = this[methodName + '_'] || this[methodName];\r\n            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\r\n        };\r\n    }\r\n    /**\r\n     * Parse a pseudo-array `arguments` for a query and callback.\r\n     *\r\n     * @param {array} args - The original `arguments` pseduo-array that the original\r\n     *     method received.\r\n     */\r\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n    parseArguments_(args) {\r\n        let query;\r\n        let autoPaginate = true;\r\n        let maxApiCalls = -1;\r\n        let maxResults = -1;\r\n        let callback;\r\n        const firstArgument = args[0];\r\n        const lastArgument = args[args.length - 1];\r\n        if (typeof firstArgument === 'function') {\r\n            callback = firstArgument;\r\n        }\r\n        else {\r\n            query = firstArgument;\r\n        }\r\n        if (typeof lastArgument === 'function') {\r\n            callback = lastArgument;\r\n        }\r\n        if (typeof query === 'object') {\r\n            query = extend(true, {}, query);\r\n            // Check if the user only asked for a certain amount of results.\r\n            if (query.maxResults && typeof query.maxResults === 'number') {\r\n                // `maxResults` is used API-wide.\r\n                maxResults = query.maxResults;\r\n            }\r\n            else if (typeof query.pageSize === 'number') {\r\n                // `pageSize` is Pub/Sub's `maxResults`.\r\n                maxResults = query.pageSize;\r\n            }\r\n            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\r\n                maxApiCalls = query.maxApiCalls;\r\n                delete query.maxApiCalls;\r\n            }\r\n            // maxResults is the user specified limit.\r\n            if (maxResults !== -1 || query.autoPaginate === false) {\r\n                autoPaginate = false;\r\n            }\r\n        }\r\n        const parsedArguments = {\r\n            query: query || {},\r\n            autoPaginate,\r\n            maxApiCalls,\r\n            maxResults,\r\n            callback,\r\n        };\r\n        parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\r\n        delete parsedArguments.streamOptions.autoPaginate;\r\n        delete parsedArguments.streamOptions.maxResults;\r\n        delete parsedArguments.streamOptions.pageSize;\r\n        return parsedArguments;\r\n    }\r\n    /**\r\n     * This simply checks to see if `autoPaginate` is set or not, if it's true\r\n     * then we buffer all results, otherwise simply call the original method.\r\n     *\r\n     * @param {array} parsedArguments - Parsed arguments from the original method\r\n     *     call.\r\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\r\n     *     commonly an object, but to make the API more simple, it can also be a\r\n     *     string in some places.\r\n     * @param {function=} parsedArguments.callback - Callback function.\r\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\r\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\r\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\r\n     * @param {function} originalMethod - The cached method that accepts a callback\r\n     *     and returns `nextQuery` to receive more results.\r\n     */\r\n    run_(parsedArguments, originalMethod) {\r\n        const query = parsedArguments.query;\r\n        const callback = parsedArguments.callback;\r\n        if (!parsedArguments.autoPaginate) {\r\n            return originalMethod(query, callback);\r\n        }\r\n        const results = new Array();\r\n        const promise = new Promise((resolve, reject) => {\r\n            paginator\r\n                .runAsStream_(parsedArguments, originalMethod)\r\n                .on('error', reject)\r\n                .on('data', (data) => results.push(data))\r\n                .on('end', () => resolve(results));\r\n        });\r\n        if (!callback) {\r\n            return promise.then(results => [results]);\r\n        }\r\n        promise.then(results => callback(null, results), (err) => callback(err));\r\n    }\r\n    /**\r\n     * This method simply calls the nextQuery recursively, emitting results to a\r\n     * stream. The stream ends when `nextQuery` is null.\r\n     *\r\n     * `maxResults` will act as a cap for how many results are fetched and emitted\r\n     * to the stream.\r\n     *\r\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\r\n     *     commonly an object, but to make the API more simple, it can also be a\r\n     *     string in some places.\r\n     * @param {function=} parsedArguments.callback - Callback function.\r\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\r\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\r\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\r\n     * @param {function} originalMethod - The cached method that accepts a callback\r\n     *     and returns `nextQuery` to receive more results.\r\n     * @return {stream} - Readable object stream.\r\n     */\r\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n    runAsStream_(parsedArguments, originalMethod) {\r\n        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\r\n    }\r\n}\r\nexports.Paginator = Paginator;\r\nconst paginator = new Paginator();\r\nexports.paginator = paginator;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}